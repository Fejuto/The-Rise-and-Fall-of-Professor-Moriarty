<haxe>
	<class path="ApplicationMain" params="" file="export/flash/haxe/ApplicationMain.hx">
		<mPreloader static="1"><c path="NMEPreloader"/></mPreloader>
		<main public="1" set="method" line="10" static="1"><f a=""><e path="Void"/></f></main>
		<flashTrace set="method" line="42" static="1"><f a="v:?pos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></flashTrace>
		<begin set="method" line="52" static="1"><f a=""><e path="Void"/></f></begin>
		<onEnter set="method" line="76" static="1"><f a="_">
	<unknown/>
	<e path="Void"/>
</f></onEnter>
		<getAsset public="1" set="method" line="92" static="1"><f a="inName">
	<c path="String"/>
	<d/>
</f></getAsset>
		<preloader_onComplete set="method" line="491" static="1"><f a="event">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></preloader_onComplete>
	</class>
	<class path="flash.events.IEventDispatcher" params="" file="/usr/lib/haxe/std/flash/events/IEventDispatcher.hx" extern="1" interface="1">
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></willTrigger>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
	</class>
	<class path="flash.events.EventDispatcher" params="" file="/usr/lib/haxe/std/flash/events/EventDispatcher.hx" extern="1">
		<implements path="flash.events.IEventDispatcher"/>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></willTrigger>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
		<new public="1" set="method"><f a="?target">
	<c path="flash.events.IEventDispatcher"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.media.Sound" params="" file="/usr/lib/haxe/std/flash/media/Sound.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<play public="1" set="method"><f a="?startTime:?loops:?sndTransform">
	<c path="Float"/>
	<c path="Int"/>
	<c path="flash.media.SoundTransform"/>
	<c path="flash.media.SoundChannel"/>
</f></play>
		<loadPCMFromByteArray public="1">
			<f a="bytes:samples:?format:?stereo:?sampleRate">
				<c path="flash.utils.ByteArray"/>
				<t path="UInt"/>
				<c path="String"/>
				<e path="Bool"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</loadPCMFromByteArray>
		<loadCompressedDataFromByteArray public="1">
			<f a="bytes:bytesLength">
				<c path="flash.utils.ByteArray"/>
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</loadCompressedDataFromByteArray>
		<load public="1" set="method"><f a="stream:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.media.SoundLoaderContext"/>
	<e path="Void"/>
</f></load>
		<extract public="1" set="method">
			<f a="target:length:?startPosition">
				<c path="flash.utils.ByteArray"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</extract>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<url public="1" set="null"><c path="String"/></url>
		<length public="1" set="null"><c path="Float"/></length>
		<isURLInaccessible public="1" set="null">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isURLInaccessible>
		<isBuffering public="1" set="null"><e path="Bool"/></isBuffering>
		<id3 public="1" set="null"><c path="flash.media.ID3Info"/></id3>
		<bytesTotal public="1" set="null"><c path="Int"/></bytesTotal>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<new public="1" set="method"><f a="?stream:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.media.SoundLoaderContext"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="NME_assets_data_beep_mp3" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.media.Sound"/>
		<new public="1" set="method" line="505"><f a="?stream:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.media.SoundLoaderContext"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.text.Font" params="" file="/usr/lib/haxe/std/flash/text/Font.hx" extern="1">
		<enumerateFonts public="1" set="method" static="1"><f a="?enumerateDeviceFonts">
	<e path="Bool"/>
	<c path="Array"><c path="flash.text.Font"/></c>
</f></enumerateFonts>
		<registerFont public="1" set="method" static="1"><f a="font">
	<c path="Class"><d/></c>
	<e path="Void"/>
</f></registerFont>
		<hasGlyphs public="1" set="method"><f a="str">
	<c path="String"/>
	<e path="Bool"/>
</f></hasGlyphs>
		<fontType public="1" set="null"><e path="flash.text.FontType"/></fontType>
		<fontStyle public="1" set="null"><e path="flash.text.FontStyle"/></fontStyle>
		<fontName public="1" set="null"><c path="String"/></fontName>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_courier_ttf" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.text.Font"/>
		<new public="1" set="method" line="506"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_nokiafc22_ttf" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.text.Font"/>
		<new public="1" set="method" line="507"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.IBitmapDrawable" params="" file="/usr/lib/haxe/std/flash/display/IBitmapDrawable.hx" extern="1" interface="1"/>
	<class path="flash.display.BitmapData" params="" file="/usr/lib/haxe/std/flash/display/BitmapData.hx" extern="1">
		<implements path="flash.display.IBitmapDrawable"/>
		<unlock public="1" set="method"><f a="?changeRect">
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></unlock>
		<threshold public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="String"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<t path="UInt"/>
</f></threshold>
		<setVector public="1" set="method">
			<f a="rect:inputVector">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><t path="UInt"/></c>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</setVector>
		<setPixels public="1" set="method"><f a="rect:inputByteArray">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></setPixels>
		<setPixel32 public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setPixel32>
		<setPixel public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setPixel>
		<scroll public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></scroll>
		<pixelDissolve public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?randomSeed:?numPixels:?fillColor">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<c path="Int"/>
</f></pixelDissolve>
		<perlinNoise public="1" set="method"><f a="baseX:baseY:numOctaves:randomSeed:stitch:fractalNoise:?channelOptions:?grayScale:?offsets">
	<c path="Float"/>
	<c path="Float"/>
	<t path="UInt"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<c path="Array"><c path="flash.geom.Point"/></c>
	<e path="Void"/>
</f></perlinNoise>
		<paletteMap public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?redArray:?greenArray:?blueArray:?alphaArray">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<e path="Void"/>
</f></paletteMap>
		<noise public="1" set="method"><f a="randomSeed:?low:?high:?channelOptions:?grayScale">
	<c path="Int"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></noise>
		<merge public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></merge>
		<lock public="1" set="method"><f a=""><e path="Void"/></f></lock>
		<hitTest public="1" set="method"><f a="firstPoint:firstAlphaThreshold:secondObject:?secondBitmapDataPoint:?secondAlphaThreshold">
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<d/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<e path="Bool"/>
</f></hitTest>
		<histogram public="1" set="method">
			<f a="?hRect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><c path="flash.Vector"><c path="Float"/></c></c>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</histogram>
		<getVector public="1" set="method">
			<f a="rect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><t path="UInt"/></c>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</getVector>
		<getPixels public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
</f></getPixels>
		<getPixel32 public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
</f></getPixel32>
		<getPixel public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
</f></getPixel>
		<getColorBoundsRect public="1" set="method"><f a="mask:color:?findColor">
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<c path="flash.geom.Rectangle"/>
</f></getColorBoundsRect>
		<generateFilterRect public="1" set="method"><f a="sourceRect:filter">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.filters.BitmapFilter"/>
	<c path="flash.geom.Rectangle"/>
</f></generateFilterRect>
		<floodFill public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></floodFill>
		<fillRect public="1" set="method"><f a="rect:color">
	<c path="flash.geom.Rectangle"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></fillRect>
		<encode public="1">
			<f a="rect:compressor:?byteArray">
				<c path="flash.geom.Rectangle"/>
				<d/>
				<c path="flash.utils.ByteArray"/>
				<c path="flash.utils.ByteArray"/>
			</f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</encode>
		<drawWithQuality public="1">
			<f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing:?quality">
				<c path="flash.display.IBitmapDrawable"/>
				<c path="flash.geom.Matrix"/>
				<c path="flash.geom.ColorTransform"/>
				<e path="flash.display.BlendMode"/>
				<c path="flash.geom.Rectangle"/>
				<e path="Bool"/>
				<e path="flash.display.StageQuality"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</drawWithQuality>
		<draw public="1" set="method"><f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing">
	<c path="flash.display.IBitmapDrawable"/>
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="flash.display.BlendMode"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></draw>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<copyPixels public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?alphaBitmapData:?alphaPoint:?mergeAlpha">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></copyPixels>
		<copyChannel public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></copyChannel>
		<compare public="1" set="method"><f a="otherBitmapData">
	<c path="flash.display.BitmapData"/>
	<d/>
</f></compare>
		<colorTransform public="1" set="method"><f a="rect:colorTransform">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="Void"/>
</f></colorTransform>
		<clone public="1" set="method"><f a=""><c path="flash.display.BitmapData"/></f></clone>
		<applyFilter public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:filter">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.filters.BitmapFilter"/>
	<e path="Void"/>
</f></applyFilter>
		<width public="1" set="null"><c path="Int"/></width>
		<transparent public="1" set="null"><e path="Bool"/></transparent>
		<rect public="1" set="null"><c path="flash.geom.Rectangle"/></rect>
		<height public="1" set="null"><c path="Int"/></height>
		<new public="1" set="method"><f a="width:height:?transparent:?fillColor">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="NME_assets_data_autotiles_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="508"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_autotiles_alt_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="509"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_base_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="510"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_button_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="511"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_button_a_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="512"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_button_b_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="513"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_button_c_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="514"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_button_down_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="515"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_button_left_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="516"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_button_right_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="517"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_button_up_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="518"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_button_x_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="519"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_button_y_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="520"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_cursor_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="521"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_default_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="522"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_fontdata10pt_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="523"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_fontdata11pt_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="524"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_handle_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="525"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_logo_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="526"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_logo_corners_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="527"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_logo_light_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="528"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_stick_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="529"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_flixel_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="530"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_open_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="531"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_pause_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="532"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_play_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="533"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_record_off_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="534"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_record_on_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="535"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_restart_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="536"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_step_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="537"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_stop_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="538"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vis_bounds_png" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="539"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_autotiles_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="540"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_autotiles_alt_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="541"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_base_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="542"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_button_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="543"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_button_a_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="544"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_button_b_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="545"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_button_c_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="546"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_button_down_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="547"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_button_left_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="548"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_button_right_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="549"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_button_up_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="550"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_button_x_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="551"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_button_y_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="552"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_cursor_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="553"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_default_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="554"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_fontdata11" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="555"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_fontdata12" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="556"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_handle_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="557"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_logo_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="558"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_logo_corners_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="559"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_logo_light_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="560"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_stick_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="561"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_flixel_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="562"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_open_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="563"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_pause_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="564"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_play_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="565"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_record_off_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="566"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_record_on_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="567"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_restart_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="568"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_step_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="569"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_stop_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="570"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vis_bounds_png1" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="571"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_flixel_png2" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="572"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_open_png2" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="573"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_pause_png2" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="574"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_play_png2" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="575"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_record_off_png2" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="576"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_record_on_png2" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="577"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_restart_png2" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="578"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_step_png2" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="579"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vcr_stop_png2" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="580"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_data_vis_bounds_png2" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="581"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.utils.IDataInput" params="" file="/usr/lib/haxe/std/flash/utils/IDataInput.hx" extern="1" interface="1">
		<readUnsignedShort public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedInt>
		<readUnsignedByte public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedByte>
		<readUTFBytes public="1" set="method"><f a="length">
	<t path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readShort public="1" set="method"><f a=""><c path="Int"/></f></readShort>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<t path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readInt public="1" set="method"><f a=""><c path="Int"/></f></readInt>
		<readFloat public="1" set="method"><f a=""><c path="Float"/></f></readFloat>
		<readDouble public="1" set="method"><f a=""><c path="Float"/></f></readDouble>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></readBytes>
		<readByte public="1" set="method"><f a=""><c path="Int"/></f></readByte>
		<readBoolean public="1" set="method"><f a=""><e path="Bool"/></f></readBoolean>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<bytesAvailable public="1" set="null"><t path="UInt"/></bytesAvailable>
	</class>
	<class path="flash.utils.IDataOutput" params="" file="/usr/lib/haxe/std/flash/utils/IDataOutput.hx" extern="1" interface="1">
		<writeUnsignedInt public="1" set="method"><f a="value">
	<t path="UInt"/>
	<e path="Void"/>
</f></writeUnsignedInt>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTFBytes>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTF>
		<writeShort public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeShort>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<e path="Void"/>
</f></writeObject>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></writeMultiByte>
		<writeInt public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt>
		<writeFloat public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></writeBytes>
		<writeByte public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBoolean public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></writeBoolean>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
	</class>
	<class path="flash.utils.ByteArray" params="" file="/usr/lib/haxe/std/flash/utils/ByteArray.hx" extern="1">
		<implements path="flash.utils.IDataInput"/>
		<implements path="flash.utils.IDataOutput"/>
		<defaultObjectEncoding public="1" static="1"><t path="UInt"/></defaultObjectEncoding>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<t path="UInt"/>
	<e path="Void"/>
</f></writeUnsignedInt>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTFBytes>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTF>
		<writeShort public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeShort>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<e path="Void"/>
</f></writeObject>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></writeMultiByte>
		<writeInt public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt>
		<writeFloat public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></writeBytes>
		<writeByte public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBoolean public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></writeBoolean>
		<uncompress public="1" set="method"><f a=""><e path="Void"/></f></uncompress>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<readUnsignedShort public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedInt>
		<readUnsignedByte public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedByte>
		<readUTFBytes public="1" set="method"><f a="length">
	<t path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readShort public="1" set="method"><f a=""><c path="Int"/></f></readShort>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<t path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readInt public="1" set="method"><f a=""><c path="Int"/></f></readInt>
		<readFloat public="1" set="method"><f a=""><c path="Float"/></f></readFloat>
		<readDouble public="1" set="method"><f a=""><c path="Float"/></f></readDouble>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></readBytes>
		<readByte public="1" set="method"><f a=""><c path="Int"/></f></readByte>
		<readBoolean public="1" set="method"><f a=""><e path="Bool"/></f></readBoolean>
		<inflate public="1" set="method">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</inflate>
		<deflate public="1" set="method">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</deflate>
		<compress public="1" set="method"><f a=""><e path="Void"/></f></compress>
		<clear public="1" set="method">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clear>
		<position public="1"><t path="UInt"/></position>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<length public="1"><t path="UInt"/></length>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<bytesAvailable public="1" set="null"><t path="UInt"/></bytesAvailable>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NME_assets_rise_library_swf" params="" file="export/flash/haxe/ApplicationMain.hx" module="ApplicationMain">
		<extends path="flash.utils.ByteArray"/>
		<new public="1" set="method" line="582"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="Array" params="T" file="/usr/lib/haxe/std/Array.hx" extern="1">
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a copy of the Array. The values are not
		copied, only the Array structure.</haxe_doc>
		</copy>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.</haxe_doc>
		</remove>
		<insert public="1" set="method">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.</haxe_doc>
		</insert>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds the element [x] at the start of the array.</haxe_doc>
		</unshift>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a displayable representation of the Array content.</haxe_doc>
		</toString>
		<splice public="1" set="method">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Removes [len] elements starting from [pos] an returns them.</haxe_doc>
		</splice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].]]></haxe_doc>
		</sort>
		<slice public="1" set="method">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.</haxe_doc>
		</slice>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element and returns it.</haxe_doc>
		</shift>
		<reverse public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Reverse the order of elements of the Array.</haxe_doc>
		</reverse>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Adds the element [x] at the end of the array.</haxe_doc>
		</push>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of the array and returns it.</haxe_doc>
		</pop>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a representation of an array with [sep] for separating each element.</haxe_doc>
		</join>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending [a] to [this].</haxe_doc>
		</concat>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The length of the Array</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.</haxe_doc>
	</class>
	<class path="Class" params="T" file="/usr/lib/haxe/std/Class.hx" extern="1"><haxe_doc>An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="Date" params="" file="/usr/lib/haxe/std/Date.hx" extern="1">
		<now public="1" set="method" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" set="method" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a timestamp [t] which is the number of
		milliseconds elapsed since 1st January 1970.</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a formated string of one of the following formats :
		[YYYY-MM-DD hh:mm:ss] or [YYYY-MM-DD] or [hh:mm:ss]. The first two formats
		are expressed in local time, the third in UTC Epoch.</haxe_doc>
		</fromString>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation for the Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See [DateTools.format] for
		other formating rules.</haxe_doc>
		</toString>
		<getDay public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the week day of the date (0-6 range).</haxe_doc>
		</getDay>
		<getDate public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the day of the date (1-31 range).</haxe_doc>
		</getDate>
		<getMonth public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the month of the date (0-11 range).</haxe_doc>
		</getMonth>
		<getFullYear public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the full year of the date.</haxe_doc>
		</getFullYear>
		<getSeconds public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the seconds of the date (0-59 range).</haxe_doc>
		</getSeconds>
		<getMinutes public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the minutes value of the date (0-59 range).</haxe_doc>
		</getMinutes>
		<getHours public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the hours value of the date (0-23 range).</haxe_doc>
		</getHours>
		<getTime public="1" set="method">
			<f a=""><c path="Float"/></f>
			<haxe_doc>Returns the timestamp of the date. It's the number of milliseconds
		elapsed since 1st January 1970. It might only have a per-second precision
		depending on the platforms.</haxe_doc>
		</getTime>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Creates a new date object.</haxe_doc>
		</new>
		<haxe_doc>The Date class is used for date manipulation. There is some extra functions
	available in the [DateTools] class.</haxe_doc>
	</class>
	<class path="EReg" params="" file="/usr/lib/haxe/std/flash/_std/EReg.hx">
		<customReplace public="1" set="method" line="74">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>For each occurence of the pattern in the string [s], the function [f] is called and
		can return the string that needs to be replaced. All occurences are matched anyway,
		and setting the [g] flag might cause some incorrect behavior on some platforms.</haxe_doc>
		</customReplace>
		<replace public="1" set="method" line="70">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replaces a pattern by another string. The [by] format can
		contains [$1] to [$9] that will correspond to groups matched
		while replacing. [$$] means the [$] character.</haxe_doc>
		</replace>
		<split public="1" set="method" line="63">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Split a string by using the regular expression to match
		the separators.</haxe_doc>
		</split>
		<matchedPos public="1" set="method" line="58">
			<f a=""><a>
	<pos><c path="Int"/></pos>
	<len><c path="Int"/></len>
</a></f>
			<haxe_doc>Returns the position of the matched substring within the
		original matched string.</haxe_doc>
		</matchedPos>
		<matchedRight public="1" set="method" line="51">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part of the string that was at the right of
		of the matched substring.</haxe_doc>
		</matchedRight>
		<matchedLeft public="1" set="method" line="45">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part of the string that was as the left of
		of the matched substring.</haxe_doc>
		</matchedLeft>
		<matched public="1" set="method" line="41">
			<f a="n">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a matched group or throw an expection if there
		is no such group. If [n = 0], the whole matched substring
		is returned.</haxe_doc>
		</matched>
		<match public="1" set="method" line="35">
			<f a="s">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the regular expression matches the String.
		Updates the internal state accordingly.</haxe_doc>
		</match>
		<result><c path="+Array"/></result>
		<r><c path="flash.utils.RegExp"/></r>
		<new public="1" set="method" line="31">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern [r] and
		options [opt].</haxe_doc>
		</new>
		<haxe_doc>Regular expressions are a way to find regular patterns into
	Strings. Have a look at the tutorial on haXe website to learn
	how to use them.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="Enum" params="T" file="/usr/lib/haxe/std/Enum.hx" extern="1"><haxe_doc>An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="EnumValue" params="" file="/usr/lib/haxe/std/EnumValue.hx" extern="1"><haxe_doc>An abstract type that represents any enum value.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="Hash" params="T" file="/usr/lib/haxe/std/flash/_std/Hash.hx">
		<toString public="1" set="method" line="66">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an displayable representation of the hashtable content.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="57">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>Returns an iterator of all values in the hashtable.</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="53">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an iterator of all keys in the hashtable.</haxe_doc>
		</keys>
		<remove public="1" set="method" line="46">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes a hashtable entry. Returns [true] if
		there was such entry.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="42">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.</haxe_doc>
		</exists>
		<get public="1" set="method" line="38">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="Hash.T"/></t>
			</f>
			<haxe_doc>Get a value for the given key.</haxe_doc>
		</get>
		<set public="1" set="method" line="34">
			<f a="key:value">
				<c path="String"/>
				<c path="Hash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set a value for the given key.</haxe_doc>
		</set>
		<h><c path="flash.utils.Dictionary"/></h>
		<new public="1" set="method" line="30">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty hashtable.</haxe_doc>
		</new>
		<haxe_doc>Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="IntHash" params="T" file="/usr/lib/haxe/std/flash/_std/IntHash.hx">
		<toString public="1" set="method" line="65">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an displayable representation of the hashtable content.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="56">
			<f a=""><t path="Iterator"><c path="IntHash.T"/></t></f>
			<haxe_doc>Returns an iterator of all values in the hashtable.</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="52">
			<f a=""><t path="Iterator"><c path="Int"/></t></f>
			<haxe_doc>Returns an iterator of all keys in the hashtable.</haxe_doc>
		</keys>
		<remove public="1" set="method" line="46">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes a hashtable entry. Returns [true] if
		there was such entry.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="42">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.</haxe_doc>
		</exists>
		<get public="1" set="method" line="38">
			<f a="key">
				<c path="Int"/>
				<t path="Null"><c path="IntHash.T"/></t>
			</f>
			<haxe_doc>Get a value for the given key.</haxe_doc>
		</get>
		<set public="1" set="method" line="34">
			<f a="key:value">
				<c path="Int"/>
				<c path="IntHash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set a value for the given key.</haxe_doc>
		</set>
		<h><c path="flash.utils.Dictionary"/></h>
		<new public="1" set="method" line="30">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty hashtable.</haxe_doc>
		</new>
		<haxe_doc>Hashtable over a set of elements, using [Int] as keys.
	On Flash and Javascript, the underlying structure is an Object.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="IntIter" params="" file="/usr/lib/haxe/std/IntIter.hx">
		<next public="1" set="method" line="53">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Moves to the next item of the iterator.</haxe_doc>
		</next>
		<hasNext public="1" set="method" line="46">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Returns true if the iterator has other items, false otherwise.</haxe_doc>
		</hasNext>
		<max><c path="Int"/></max>
		<min><c path="Int"/></min>
		<new public="1" set="method" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.]]></haxe_doc>
		</new>
		<haxe_doc>Integer iterator. Used for interval implementation.</haxe_doc>
	</class>
	<class path="flash.display.DisplayObject" params="" file="/usr/lib/haxe/std/flash/display/DisplayObject.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="flash.display.IBitmapDrawable"/>
		<localToGlobal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></localToGlobal>
		<local3DToGlobal public="1" set="method">
			<f a="point3d">
				<c path="flash.geom.Vector3D"/>
				<c path="flash.geom.Point"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</local3DToGlobal>
		<hitTestPoint public="1" set="method"><f a="x:y:?shapeFlag">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></hitTestPoint>
		<hitTestObject public="1" set="method"><f a="obj">
	<c path="flash.display.DisplayObject"/>
	<e path="Bool"/>
</f></hitTestObject>
		<globalToLocal3D public="1" set="method">
			<f a="point">
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Vector3D"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</globalToLocal3D>
		<globalToLocal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></globalToLocal>
		<getRect public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getRect>
		<getBounds public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getBounds>
		<z public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</z>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<width public="1"><c path="Float"/></width>
		<visible public="1"><e path="Bool"/></visible>
		<transform public="1"><c path="flash.geom.Transform"/></transform>
		<stage public="1" set="null"><c path="flash.display.Stage"/></stage>
		<scrollRect public="1"><c path="flash.geom.Rectangle"/></scrollRect>
		<scaleZ public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</scaleZ>
		<scaleY public="1"><c path="Float"/></scaleY>
		<scaleX public="1"><c path="Float"/></scaleX>
		<scale9Grid public="1"><c path="flash.geom.Rectangle"/></scale9Grid>
		<rotationZ public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationZ>
		<rotationY public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationY>
		<rotationX public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationX>
		<rotation public="1"><c path="Float"/></rotation>
		<root public="1" set="null"><c path="flash.display.DisplayObject"/></root>
		<parent public="1" set="null"><c path="flash.display.DisplayObjectContainer"/></parent>
		<opaqueBackground public="1"><t path="Null"><t path="UInt"/></t></opaqueBackground>
		<name public="1"><c path="String"/></name>
		<mouseY public="1" set="null"><c path="Float"/></mouseY>
		<mouseX public="1" set="null"><c path="Float"/></mouseX>
		<mask public="1"><c path="flash.display.DisplayObject"/></mask>
		<loaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></loaderInfo>
		<height public="1"><c path="Float"/></height>
		<filters public="1"><c path="Array"><c path="flash.filters.BitmapFilter"/></c></filters>
		<cacheAsBitmap public="1"><e path="Bool"/></cacheAsBitmap>
		<blendShader public="1" get="null">
			<c path="flash.display.Shader"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</blendShader>
		<blendMode public="1"><e path="flash.display.BlendMode"/></blendMode>
		<alpha public="1"><c path="Float"/></alpha>
		<accessibilityProperties public="1"><c path="flash.accessibility.AccessibilityProperties"/></accessibilityProperties>
	</class>
	<class path="flash.display.InteractiveObject" params="" file="/usr/lib/haxe/std/flash/display/InteractiveObject.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<requestSoftKeyboard public="1">
			<f a=""><e path="Bool"/></f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</requestSoftKeyboard>
		<tabIndex public="1"><c path="Int"/></tabIndex>
		<tabEnabled public="1"><e path="Bool"/></tabEnabled>
		<softKeyboardInputAreaOfInterest public="1">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</softKeyboardInputAreaOfInterest>
		<needsSoftKeyboard public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</needsSoftKeyboard>
		<mouseEnabled public="1"><e path="Bool"/></mouseEnabled>
		<focusRect public="1"><d/></focusRect>
		<doubleClickEnabled public="1"><e path="Bool"/></doubleClickEnabled>
		<contextMenu public="1"><c path="flash.ui.ContextMenu"/></contextMenu>
		<accessibilityImplementation public="1"><c path="flash.accessibility.AccessibilityImplementation"/></accessibilityImplementation>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.DisplayObjectContainer" params="" file="/usr/lib/haxe/std/flash/display/DisplayObjectContainer.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<swapChildrenAt public="1" set="method"><f a="index1:index2">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></swapChildrenAt>
		<swapChildren public="1" set="method"><f a="child1:child2">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
	<e path="Void"/>
</f></swapChildren>
		<setChildIndex public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setChildIndex>
		<removeChildren public="1">
			<f a="?beginIndex:?endIndex">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</removeChildren>
		<removeChildAt public="1" set="method"><f a="index">
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChildAt>
		<removeChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChild>
		<getObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="flash.display.DisplayObject"/></c>
</f></getObjectsUnderPoint>
		<getChildIndex public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
</f></getChildIndex>
		<getChildByName public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildByName>
		<getChildAt public="1" set="method"><f a="index">
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildAt>
		<contains public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<e path="Bool"/>
</f></contains>
		<areInaccessibleObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></areInaccessibleObjectsUnderPoint>
		<addChildAt public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></addChildAt>
		<addChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></addChild>
		<textSnapshot public="1" set="null"><c path="flash.text.TextSnapshot"/></textSnapshot>
		<tabChildren public="1"><e path="Bool"/></tabChildren>
		<numChildren public="1" set="null"><c path="Int"/></numChildren>
		<mouseChildren public="1"><e path="Bool"/></mouseChildren>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.Sprite" params="" file="/usr/lib/haxe/std/flash/display/Sprite.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<stopTouchDrag public="1" set="method">
			<f a="touchPointID">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</stopTouchDrag>
		<stopDrag public="1" set="method"><f a=""><e path="Void"/></f></stopDrag>
		<startTouchDrag public="1" set="method">
			<f a="touchPointID:?lockCenter:?bounds">
				<c path="Int"/>
				<e path="Bool"/>
				<c path="flash.geom.Rectangle"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</startTouchDrag>
		<startDrag public="1" set="method"><f a="?lockCenter:?bounds">
	<e path="Bool"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></startDrag>
		<useHandCursor public="1"><e path="Bool"/></useHandCursor>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<hitArea public="1"><c path="flash.display.Sprite"/></hitArea>
		<graphics public="1" set="null"><c path="flash.display.Graphics"/></graphics>
		<dropTarget public="1" set="null"><c path="flash.display.DisplayObject"/></dropTarget>
		<buttonMode public="1"><e path="Bool"/></buttonMode>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="Main" params="" file="source/Main.hx">
		<extends path="flash.display.Sprite"/>
		<main public="1" set="method" line="63" static="1"><f a=""><e path="Void"/></f></main>
		<initialize set="method" line="56"><f a=""><e path="Void"/></f></initialize>
		<init set="method" line="29"><f a="?e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></init>
		<new public="1" set="method" line="19"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* @author Joshua Granick</haxe_doc>
	</class>
	<class path="Math" params="" file="/usr/lib/haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><c path="Float"/></PI>
		<NaN public="1" set="null" static="1"><c path="Float"/></NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></POSITIVE_INFINITY>
		<abs public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></abs>
		<min public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<max public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<sin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sin>
		<cos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></cos>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></atan2>
		<tan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></tan>
		<exp public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></exp>
		<log public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></log>
		<sqrt public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sqrt>
		<round public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></round>
		<floor public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<ceil public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<atan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></atan>
		<asin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></acos>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></pow>
		<random public="1" set="method" static="1"><f a=""><c path="Float"/></f></random>
		<isFinite public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isFinite>
		<isNaN public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isNaN>
		<haxe_doc>This class defines mathematical functions and constants.</haxe_doc>
	</class>
	<class path="org.flixel.FlxBasic" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/FlxBasic.hx">
		<_ACTIVECOUNT public="1" static="1"><c path="Int"/></_ACTIVECOUNT>
		<_VISIBLECOUNT public="1" static="1"><c path="Int"/></_VISIBLECOUNT>
		<updateFrameData public="1" set="method" line="371"><f a=""><e path="Void"/></f></updateFrameData>
		<updateLayerInfo public="1" set="method" line="338"><f a="?updateAtlas">
	<e path="Bool"/>
	<e path="Void"/>
</f></updateLayerInfo>
		<_tween><c path="org.flixel.tweens.FlxTween"/></_tween>
		<getTween set="method" line="262"><f a=""><e path="Bool"/></f></getTween>
		<hasTween public="1" get="getTween" set="null"><e path="Bool"/></hasTween>
		<updateTweens public="1" get="inline" set="null" line="241"><f a=""><e path="Void"/></f></updateTweens>
		<clearTweens public="1" set="method" line="228"><f a="?destroy">
	<e path="Bool"/>
	<e path="Void"/>
</f></clearTweens>
		<removeTween public="1" set="method" line="199"><f a="t:?destroy">
	<c path="org.flixel.tweens.FlxTween"/>
	<e path="Bool"/>
	<c path="org.flixel.tweens.FlxTween"/>
</f></removeTween>
		<addTween public="1" set="method" line="177"><f a="t:?start">
	<c path="org.flixel.tweens.FlxTween"/>
	<e path="Bool"/>
	<c path="org.flixel.tweens.FlxTween"/>
</f></addTween>
		<toString public="1" set="method" line="172">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Convert object to readable string name.  Useful for debugging, save games, etc.</haxe_doc>
		</toString>
		<revive public="1" set="method" line="163">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Handy function for bringing game objects "back to life". Just sets alive and exists back to true.
	 * In practice, this function is most often called by <code>FlxObject.reset()</code>.]]></haxe_doc>
		</revive>
		<kill public="1" set="method" line="153">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Handy function for "killing" game objects.
	 * Default behavior is to flag them as nonexistent AND dead.
	 * However, if you want the "corpse" to remain in the game,
	 * like to animate an effect or whatever, you should override this,
	 * setting only alive to false, and leaving exists true.</haxe_doc>
		</kill>
		<drawDebug public="1" set="method" line="144">
			<f a="?Camera">
				<c path="org.flixel.FlxCamera"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Override this function to draw custom "debug mode" graphics to the
	 * specified camera while the debugger's visual mode is toggled on.
	 * @param	Camera	Which camera to draw the debug visuals to.</haxe_doc>
		</drawDebug>
		<draw public="1" set="method" line="119">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Override this function to control how the object is drawn.
	 * Overriding <code>draw()</code> is rarely necessary, but can be very useful.]]></haxe_doc>
		</draw>
		<postUpdate public="1" set="method" line="113">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Post-update is called right after <code>update()</code> on each object in the game loop.]]></haxe_doc>
		</postUpdate>
		<update public="1" set="method" line="108">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Override this function to update your class's position and appearance.
	 * This is where most of your game rules and behavioral code will go.</haxe_doc>
		</update>
		<preUpdate public="1" set="method" line="99">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Pre-update is called right before <code>update()</code> on each object in the game loop.]]></haxe_doc>
		</preUpdate>
		<destroy public="1" set="method" line="80">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Override this function to null out variables or manually call
	 * <code>destroy()</code> on class members if necessary.
	 * Don't forget to call <code>super.destroy()</code>!]]></haxe_doc>
		</destroy>
		<autoClear public="1">
			<e path="Bool"/>
			<haxe_doc>* If the Tweener should clear on removal. For Entities, this is when they are
	 * removed from a World, and for World this is when the active World is switched.</haxe_doc>
		</autoClear>
		<ignoreDrawDebug public="1">
			<e path="Bool"/>
			<haxe_doc>* Setting this to true will prevent the object from appearing
	 * when the visual debug mode in the debugger overlay is toggled on.</haxe_doc>
		</ignoreDrawDebug>
		<cameras public="1">
			<c path="Array"><c path="org.flixel.FlxCamera"/></c>
			<haxe_doc><![CDATA[* An array of camera objects that this object will use during <code>draw()</code>.
	 * This value will initialize itself during the first draw to automatically
	 * point at the main camera list out in <code>FlxG</code> unless you already set it.
	 * You can also change it afterward too, very flexible!]]></haxe_doc>
		</cameras>
		<alive public="1">
			<e path="Bool"/>
			<haxe_doc><![CDATA[* Useful state for many game objects - "dead" (!alive) vs alive.
	 * <code>kill()</code> and <code>revive()</code> both flip this switch (along with exists, but you can override that).]]></haxe_doc>
		</alive>
		<visible public="1">
			<e path="Bool"/>
			<haxe_doc><![CDATA[* Controls whether <code>draw()</code> is automatically called by FlxState/FlxGroup.]]></haxe_doc>
		</visible>
		<active public="1">
			<e path="Bool"/>
			<haxe_doc><![CDATA[* Controls whether <code>update()</code> is automatically called by FlxState/FlxGroup.]]></haxe_doc>
		</active>
		<exists public="1">
			<e path="Bool"/>
			<haxe_doc><![CDATA[* Controls whether <code>update()</code> and <code>draw()</code> are automatically called by FlxState/FlxGroup.]]></haxe_doc>
		</exists>
		<ID public="1">
			<c path="Int"/>
			<haxe_doc>* IDs seem like they could be pretty useful, huh?
	 * They're not actually used for anything yet though.</haxe_doc>
		</ID>
		<new public="1" set="method" line="63">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Instantiate the basic flixel object.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* This is a useful "generic" Flixel object.
 * Both <code>FlxObject</code> and <code>FlxGroup</code> extend this class,
 * as do the plugins.  Has no size, position or graphical data.]]></haxe_doc>
	</class>
	<class path="org.flixel.FlxGroup" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/FlxGroup.hx">
		<extends path="org.flixel.FlxBasic"/>
		<ASCENDING public="1" get="inline" set="null" line="19" static="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[* Use with <code>sort()</code> to sort in ascending order.]]></haxe_doc>
		</ASCENDING>
		<DESCENDING public="1" get="inline" set="null" line="23" static="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[* Use with <code>sort()</code> to sort in descending order.]]></haxe_doc>
		</DESCENDING>
		<sortHandler set="method" line="656">
			<f a="Obj1:Obj2">
				<c path="org.flixel.FlxBasic"/>
				<c path="org.flixel.FlxBasic"/>
				<c path="Int"/>
			</f>
			<haxe_doc>* Helper function for the sort process.
	 * @param 	Obj1	The first object being sorted.
	 * @param	Obj2	The second object being sorted.
	 * @return	An integer value: -1 (Obj1 before Obj2), 0 (same), or 1 (Obj1 after Obj2).</haxe_doc>
		</sortHandler>
		<kill public="1" set="method" line="635" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Calls kill on the group's members and then on the group itself.</haxe_doc>
		</kill>
		<clear public="1" set="method" line="626">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Remove all instances of <code>FlxBasic</code> subclass (FlxSprite, FlxBlock, etc) from the list.
	 * WARNING: does not destroy() or kill() any of these objects!]]></haxe_doc>
		</clear>
		<getRandom public="1" set="method" line="609">
			<f a="?StartIndex:?Length">
				<c path="Int"/>
				<c path="Int"/>
				<c path="org.flixel.FlxBasic"/>
			</f>
			<haxe_doc><![CDATA[* Returns a member at random from the group.
	 * 
	 * @param	StartIndex	Optional offset off the front of the array. Default value is 0, or the beginning of the array.
	 * @param	Length		Optional restriction on the number of values you want to randomly select from.
	 * 
	 * @return	A <code>FlxBasic</code> from the members list.]]></haxe_doc>
		</getRandom>
		<countDead public="1" set="method" line="578">
			<f a=""><c path="Int"/></f>
			<haxe_doc><![CDATA[* Call this function to find out how many members of the group are dead.
	 * @return	The number of <code>FlxBasic</code>s flagged as dead.  Returns -1 if group is empty.]]></haxe_doc>
		</countDead>
		<countLiving public="1" set="method" line="551">
			<f a=""><c path="Int"/></f>
			<haxe_doc><![CDATA[* Call this function to find out how many members of the group are not dead.
	 * @return	The number of <code>FlxBasic</code>s flagged as not dead.  Returns -1 if group is empty.]]></haxe_doc>
		</countLiving>
		<getFirstDead public="1" set="method" line="532">
			<f a=""><c path="org.flixel.FlxBasic"/></f>
			<haxe_doc><![CDATA[* Call this function to retrieve the first object with dead == true in the group.
	 * This is handy for checking if everything's wiped out, or choosing a squad leader, etc.
	 * 
	 * @return	A <code>FlxBasic</code> currently flagged as dead.]]></haxe_doc>
		</getFirstDead>
		<getFirstAlive public="1" set="method" line="511">
			<f a=""><c path="org.flixel.FlxBasic"/></f>
			<haxe_doc><![CDATA[* Call this function to retrieve the first object with dead == false in the group.
	 * This is handy for checking if everything's wiped out, or choosing a squad leader, etc.
	 * 
	 * @return	A <code>FlxBasic</code> currently flagged as not dead.]]></haxe_doc>
		</getFirstAlive>
		<getFirstExtant public="1" set="method" line="490">
			<f a=""><c path="org.flixel.FlxBasic"/></f>
			<haxe_doc><![CDATA[* Call this function to retrieve the first object with exists == true in the group.
	 * This is handy for checking if everything's wiped out, or choosing a squad leader, etc.
	 * @return	A <code>FlxBasic</code> currently flagged as existing.]]></haxe_doc>
		</getFirstExtant>
		<getFirstNull public="1" set="method" line="466">
			<f a=""><c path="Int"/></f>
			<haxe_doc><![CDATA[* Call this function to retrieve the first index set to 'null'.
	 * Returns -1 if no index stores a null object.
	 * @return	An <code>int</code> indicating the first null slot in the group.]]></haxe_doc>
		</getFirstNull>
		<getFirstAvailable public="1" set="method" line="446">
			<f a="?ObjectClass">
				<c path="Class"><c path="org.flixel.FlxBasic"/></c>
				<c path="org.flixel.FlxBasic"/>
			</f>
			<haxe_doc><![CDATA[* Call this function to retrieve the first object with exists == false in the group.
	 * This is handy for recycling in general, e.g. respawning enemies.
	 * @param	ObjectClass		An optional parameter that lets you narrow the results to instances of this particular class.
	 * @return	A <code>FlxBasic</code> currently flagged as not existing.]]></haxe_doc>
		</getFirstAvailable>
		<callAll public="1" set="method" line="419">
			<f a="FunctionName:?Recurse">
				<c path="String"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Go through and call the specified function on all members of the group.
	 * Currently only works on functions that have no required parameters.
	 * @param	FunctionName	The string representation of the function you want to call on each object, for example "kill()" or "init()".
	 * @param	Recurse			Default value is true, meaning if <code>callAll()</code> encounters a member that is a group, it will call <code>callAll()</code> on that group rather than calling the group's function.]]></haxe_doc>
		</callAll>
		<setAll public="1" set="method" line="392">
			<f a="VariableName:Value:?Recurse">
				<c path="String"/>
				<d/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Go through and set the specified variable to the specified value on all members of the group.
	 * @param	VariableName	The string representation of the variable name you want to modify, for example "visible" or "scrollFactor".
	 * @param	Value			The value you want to assign to that variable.
	 * @param	Recurse			Default value is true, meaning if <code>setAll()</code> encounters a member that is a group, it will call <code>setAll()</code> on that group rather than modifying its variable.]]></haxe_doc>
		</setAll>
		<sort public="1" set="method" line="379">
			<f a="?Index:?Order">
				<c path="String"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Call this function to sort the group according to a particular value and order.
	 * For example, to sort game objects for Zelda-style overlaps you might call
	 * <code>myGroup.sort("y",ASCENDING)</code> at the bottom of your
	 * <code>FlxState.update()</code> override.  To sort all existing objects after
	 * a big explosion or bomb attack, you might call <code>myGroup.sort("exists",DESCENDING)</code>.
	 * @param	Index	The <code>String</code> name of the member variable you want to sort on.  Default value is "y".
	 * @param	Order	A <code>FlxGroup</code> constant that defines the sort order.  Possible values are <code>ASCENDING</code> and <code>DESCENDING</code>.  Default value is <code>ASCENDING</code>.]]></haxe_doc>
		</sort>
		<replace public="1" set="method" line="359">
			<f a="OldObject:NewObject">
				<c path="org.flixel.FlxBasic"/>
				<c path="org.flixel.FlxBasic"/>
				<c path="org.flixel.FlxBasic"/>
			</f>
			<haxe_doc><![CDATA[* Replaces an existing <code>FlxBasic</code> with a new one.
	 * @param	OldObject	The object you want to replace.
	 * @param	NewObject	The new object you want to use instead.
	 * @return	The new object.]]></haxe_doc>
		</replace>
		<remove public="1" set="method" line="334">
			<f a="Object:?Splice">
				<c path="org.flixel.FlxBasic"/>
				<e path="Bool"/>
				<c path="org.flixel.FlxBasic"/>
			</f>
			<haxe_doc><![CDATA[* Removes an object from the group.
	 * @param	Object	The <code>FlxBasic</code> you want to remove.
	 * @param	Splice	Whether the object should be cut from the array entirely or not.
	 * @return	The removed object.]]></haxe_doc>
		</remove>
		<recycle public="1" set="method" line="290">
			<f a="?ObjectClass">
				<c path="Class"><c path="org.flixel.FlxBasic"/></c>
				<c path="org.flixel.FlxBasic"/>
			</f>
			<haxe_doc><![CDATA[* Recycling is designed to help you reuse game objects without always re-allocating or "newing" them.
	 * <p>If you specified a maximum size for this group (like in FlxEmitter),
	 * then recycle will employ what we're calling "rotating" recycling.
	 * Recycle() will first check to see if the group is at capacity yet.
	 * If group is not yet at capacity, recycle() returns a new object.
	 * If the group IS at capacity, then recycle() just returns the next object in line.</p>
	 * <p>If you did NOT specify a maximum size for this group,
	 * then recycle() will employ what we're calling "grow-style" recycling.
	 * Recycle() will return either the first object with exists == false,
	 * or, finding none, add a new object to the array,
	 * doubling the size of the array if necessary.</p>
	 * <p>WARNING: If this function needs to create a new object,
	 * and no object class was provided, it will return null
	 * instead of a valid object!</p>
	 * @param	ObjectClass		The class type you want to recycle (e.g. FlxSprite, EvilRobot, etc). Do NOT "new" the class in the parameter!
	 * @return	A reference to the object that was created.  Don't forget to cast it back to the Class you want (e.g. myObject = myGroup.recycle(myObjectClass) as myObjectClass;).]]></haxe_doc>
		</recycle>
		<add public="1" set="method" line="181">
			<f a="Object">
				<c path="org.flixel.FlxBasic"/>
				<c path="org.flixel.FlxBasic"/>
			</f>
			<haxe_doc><![CDATA[* Adds a new <code>FlxBasic</code> subclass (FlxBasic, FlxSprite, Enemy, etc) to the group.
	 * FlxGroup will try to replace a null member of the array first.
	 * Failing that, FlxGroup will add it to the end of the member array,
	 * assuming there is room for it, and doubling the size of the array if necessary.
	 * <p>WARNING: If the group has a maxSize that has already been met,
	 * the object will NOT be added to the group!</p>
	 * @param	Object		The object you want to add to the group.
	 * @return	The same <code>FlxBasic</code> object that was passed in.]]></haxe_doc>
		</add>
		<setMaxSize set="method" line="142">
			<f a="Size">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</setMaxSize>
		<draw public="1" set="method" line="125" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Automatically goes through and calls render on everything you added.</haxe_doc>
		</draw>
		<update public="1" set="method" line="95" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Automatically goes through and calls update on everything you added.</haxe_doc>
		</update>
		<preUpdate public="1" set="method" line="90" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Just making sure we don't increment the active objects count.</haxe_doc>
		</preUpdate>
		<destroy public="1" set="method" line="67" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Override this function to handle any deleting or "shutdown" type operations you might need,
	 * such as removing traditional Flash children like Sprite objects.</haxe_doc>
		</destroy>
		<_sortOrder>
			<c path="Int"/>
			<haxe_doc>* Helper for sort.</haxe_doc>
		</_sortOrder>
		<_sortIndex>
			<c path="String"/>
			<haxe_doc>* Helper for sort.</haxe_doc>
		</_sortIndex>
		<_marker>
			<c path="Int"/>
			<haxe_doc><![CDATA[* Internal helper variable for recycling objects a la <code>FlxEmitter</code>.]]></haxe_doc>
		</_marker>
		<length public="1">
			<c path="Int"/>
			<haxe_doc>* The number of entries in the members array.
	 * For performance and safety you should check this variable
	 * instead of members.length unless you really know what you're doing!</haxe_doc>
		</length>
		<members public="1">
			<c path="Array"><c path="org.flixel.FlxBasic"/></c>
			<haxe_doc><![CDATA[* Array of all the <code>FlxBasic</code>s that exist in this group.]]></haxe_doc>
		</members>
		<maxSize public="1" set="setMaxSize">
			<c path="Int"/>
			<haxe_doc>* The maximum capacity of this group.  Default is 0, meaning no max capacity, and the group can just grow.</haxe_doc>
		</maxSize>
		<new public="1" set="method" line="53">
			<f a="?MaxSize">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* This is an organizational class that can update and render a bunch of <code>FlxBasic</code>s.
 * NOTE: Although <code>FlxGroup</code> extends <code>FlxBasic</code>, it will not automatically
 * add itself to the global collisions quad tree, it will only add its members.]]></haxe_doc>
	</class>
	<class path="org.flixel.FlxState" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/FlxState.hx">
		<extends path="org.flixel.FlxGroup"/>
		<getLayerFor public="1" set="method" line="208">
			<f a="KeyInBitmapCache">
				<c path="String"/>
				<c path="org.flixel.FlxLayer"/>
			</f>
			<haxe_doc>* Gets the layer for specified key from bitmap cache in FlxG. Creates new layer for it if there wasn't such a layer 
	 * @param	KeyInBitmapCache	key from bitmap cache in FlxG
	 * @return	required layer</haxe_doc>
		</getLayerFor>
		<removeLayer public="1" set="method" line="189">
			<f a="Layer">
				<c path="org.flixel.FlxLayer"/>
				<c path="org.flixel.FlxLayer"/>
			</f>
			<haxe_doc>* Removes layer from state
	 * @param	Layer	layer to remove
	 * @return	removed layer if it was in the state, or null if it wasn't.</haxe_doc>
		</removeLayer>
		<addLayer public="1" set="method" line="174">
			<f a="Layer">
				<c path="org.flixel.FlxLayer"/>
				<c path="org.flixel.FlxLayer"/>
			</f>
			<haxe_doc>* Adds layer at the top of layer stack. May remove layer and add it again to the state if layer was in the state already.
	 * @param	Layer	layer to add
	 * @return	added 	layer</haxe_doc>
		</addLayer>
		<swapLayersAt public="1" set="method" line="160">
			<f a="id1:id2">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Swaps layers at specified indices.</haxe_doc>
		</swapLayersAt>
		<swapLayers public="1" set="method" line="147">
			<f a="layer1:layer2">
				<c path="org.flixel.FlxLayer"/>
				<c path="org.flixel.FlxLayer"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Swaps specified layer</haxe_doc>
		</swapLayers>
		<removeLayerAt public="1" set="method" line="134">
			<f a="index">
				<c path="Int"/>
				<c path="org.flixel.FlxLayer"/>
			</f>
			<haxe_doc>* Removes layer at specified index. May return null if layer wasn't added to state before.</haxe_doc>
		</removeLayerAt>
		<addLayerAt public="1" set="method" line="99">
			<f a="layer:index">
				<c path="org.flixel.FlxLayer"/>
				<c path="Int"/>
				<c path="org.flixel.FlxLayer"/>
			</f>
			<haxe_doc>* Adds layer at specified index. Adds it at the top of layer stack if index is more than maxIndex, and at the bottom if index is less than zero.</haxe_doc>
		</addLayerAt>
		<getMaxIndex public="1" set="method" line="91">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* Retutns max index</haxe_doc>
		</getMaxIndex>
		<getLayerIndex public="1" set="method" line="82">
			<f a="layer">
				<c path="org.flixel.FlxLayer"/>
				<c path="Int"/>
			</f>
			<haxe_doc>* Returns layer index. May return -1 if layer isn't on layer stack</haxe_doc>
		</getLayerIndex>
		<getLayerAt public="1" set="method" line="70">
			<f a="index">
				<c path="Int"/>
				<c path="org.flixel.FlxLayer"/>
			</f>
			<haxe_doc>* Gets the layer at specified index. May return null if index is out of bounds (less than zero of more than maxIndex).</haxe_doc>
		</getLayerAt>
		<create public="1" set="method" line="63">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* This function is called after the game engine successfully switches states.
	 * Override this function, NOT the constructor, to initialize or set up your game state.
	 * We do NOT recommend overriding the constructor, unless you want some crazy unpredictable things to happen!</haxe_doc>
		</create>
		<destroy public="1" set="method" line="25" override="1"><f a=""><e path="Void"/></f></destroy>
		<_layers>
			<c path="Array"><c path="org.flixel.FlxLayer"/></c>
			<haxe_doc>* active layers</haxe_doc>
		</_layers>
		<new public="1" set="method" line="19"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* This is the basic game "state" object - e.g. in a simple game
 * you might have a menu state and a play state.
 * It is for all intents and purpose a fancy FlxGroup.
 * And really, it's not even that fancy.</haxe_doc>
	</class>
	<class path="MenuState" params="" file="source/MenuState.hx">
		<extends path="org.flixel.FlxState"/>
		<update public="1" set="method" line="32" override="1"><f a=""><e path="Void"/></f></update>
		<destroy public="1" set="method" line="27" override="1"><f a=""><e path="Void"/></f></destroy>
		<create public="1" set="method" line="17" override="1"><f a=""><e path="Void"/></f></create>
		<new public="1" set="method" line="15"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="NMEPreloader" params="" file="export/flash/haxe/NMEPreloader.hx">
		<extends path="flash.display.Sprite"/>
		<onUpdate public="1" set="method" line="82"><f a="bytesLoaded:bytesTotal">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></onUpdate>
		<onLoaded public="1" set="method" line="76"><f a=""><e path="Void"/></f></onLoaded>
		<onInit public="1" set="method" line="70"><f a=""><e path="Void"/></f></onInit>
		<getWidth public="1" set="method" line="64"><f a=""><c path="Float"/></f></getWidth>
		<getHeight public="1" set="method" line="58"><f a=""><c path="Float"/></f></getHeight>
		<getBackgroundColor public="1" set="method" line="52"><f a=""><c path="Int"/></f></getBackgroundColor>
		<progress><t path="nme.display.Sprite"/></progress>
		<outline><t path="nme.display.Sprite"/></outline>
		<new public="1" set="method" line="11"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="org.flixel.FlxGame" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/FlxGame.hx">
		<extends path="flash.display.Sprite"/>
		<clickableArea public="1" static="1">
			<t path="nme.display.Sprite"/>
			<haxe_doc>* This sprite is needed in c++ version of games.</haxe_doc>
		</clickableArea>
		<getDebugger public="1" set="method" line="1088"><f a=""><c path="org.flixel.system.FlxDebugger"/></f></getDebugger>
		<debugger public="1" get="getDebugger" set="null"><c path="org.flixel.system.FlxDebugger"/></debugger>
		<createFocusScreen set="method" line="1045">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Sets up the darkened overlay with the big white "play" button that appears when a flixel game loses focus.</haxe_doc>
		</createFocusScreen>
		<createSoundTray set="method" line="970">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Sets up the "sound tray", the little volume meter that pops down sometimes.</haxe_doc>
		</createSoundTray>
		<create set="method" line="861">
			<f a="FlashEvent">
				<t path="nme.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Used to instantiate the guts of the flixel game object once we have a valid reference to the root.
	 * 
	 * @param	FlashEvent	Just a Flash system event, not too important for our purposes.</haxe_doc>
		</create>
		<draw set="method" line="831">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Goes through the game state and draws all the game objects and special effects.</haxe_doc>
		</draw>
		<update set="method" line="807">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* This function is called by step() and updates the actual game state.
	 * May be called multiple times per "frame" or draw call.</haxe_doc>
		</update>
		<updateSoundTray set="method" line="772">
			<f a="MS">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* This function just updates the soundtray object.</haxe_doc>
		</updateSoundTray>
		<step set="method" line="676">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* This is the main game update logic section.
	 * The onEnterFrame() handler is in charge of calling this
	 * the appropriate number of times each frame.
	 * This block handles state changes, replays, all that good stuff.</haxe_doc>
		</step>
		<switchState set="method" line="632">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* If there is a state change requested during the update loop,
	 * this function handles actual destroying the old state and related processes,
	 * and calls creates on the new state and plugs it into the game object.</haxe_doc>
		</switchState>
		<resetGame get="inline" set="null" line="619">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Internal method to create a new instance of iState and reset the game.
	 * This gets called when the game is created, as well as when a new state is requested.</haxe_doc>
		</resetGame>
		<onEnterFrame set="method" line="567">
			<f a="?FlashEvent">
				<t path="nme.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Handles the onEnterFrame call and figures out how many updates and draw calls to do.
	 * @param	FlashEvent	Flash event.</haxe_doc>
		</onEnterFrame>
		<onFocusLost set="method" line="550">
			<f a="?FlashEvent">
				<t path="nme.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Internal event handler for input and focus.
	 * @param	FlashEvent	Flash event.</haxe_doc>
		</onFocusLost>
		<onFocus set="method" line="534">
			<f a="?FlashEvent">
				<t path="nme.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Internal event handler for input and focus.
	 * @param	FlashEvent	Flash event.</haxe_doc>
		</onFocus>
		<onTouchMove get="inline" set="null" line="478">
			<f a="FlashEvent">
				<t path="nme.events.TouchEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Internal event handler for input and focus.
	 * @param	FlashEvent	Flash touch event.</haxe_doc>
		</onTouchMove>
		<onTouchEnd get="inline" set="null" line="469">
			<f a="FlashEvent">
				<t path="nme.events.TouchEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Internal event handler for input and focus.
	 * @param	FlashEvent	Flash touch event.</haxe_doc>
		</onTouchEnd>
		<onTouchBegin get="inline" set="null" line="460">
			<f a="FlashEvent">
				<t path="nme.events.TouchEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Internal event handler for input and focus.
	 * @param	FlashEvent	Flash touch event.</haxe_doc>
		</onTouchBegin>
		<onMouseWheel set="method" line="447">
			<f a="FlashEvent">
				<t path="nme.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Internal event handler for input and focus.
	 * @param	FlashEvent	Flash mouse event.</haxe_doc>
		</onMouseWheel>
		<onMouseUp set="method" line="434">
			<f a="FlashEvent">
				<t path="nme.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Internal event handler for input and focus.
	 * @param	FlashEvent	Flash mouse event.</haxe_doc>
		</onMouseUp>
		<onMouseDown set="method" line="390">
			<f a="FlashEvent">
				<t path="nme.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Internal event handler for input and focus.
	 * @param	FlashEvent	Flash mouse event.</haxe_doc>
		</onMouseDown>
		<onKeyDown set="method" line="352">
			<f a="FlashEvent">
				<t path="nme.events.KeyboardEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Internal event handler for input and focus.
	 * @param	FlashEvent	Flash keyboard event.</haxe_doc>
		</onKeyDown>
		<onKeyUp set="method" line="284">
			<f a="FlashEvent">
				<t path="nme.events.KeyboardEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Internal event handler for input and focus.
	 * @param	FlashEvent	Flash keyboard event.</haxe_doc>
		</onKeyUp>
		<showSoundTray set="method" line="258">
			<f a="?Silent">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Makes the little volume tray slide out.
	 * @param	Silent	Whether or not it should beep.</haxe_doc>
		</showSoundTray>
		<_replayCallback public="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* This function, if set, is triggered when the callback stops playing.</haxe_doc>
		</_replayCallback>
		<_replayTimer public="1">
			<c path="Int"/>
			<haxe_doc>* Helps time out a replay if necessary.</haxe_doc>
		</_replayTimer>
		<_replayCancelKeys public="1">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>* Array that keeps track of keypresses that can cancel a replay.
	 * Handy for skipping cutscenes or getting out of attract modes!</haxe_doc>
		</_replayCancelKeys>
		<_recording public="1">
			<e path="Bool"/>
			<haxe_doc>* Flag for whether a new recording is being made.</haxe_doc>
		</_recording>
		<_replaying public="1">
			<e path="Bool"/>
			<haxe_doc>* Flag for whether a replay is currently playing.</haxe_doc>
		</_replaying>
		<_recordingRequested public="1">
			<e path="Bool"/>
			<haxe_doc>* Flag for whether a new recording was requested.</haxe_doc>
		</_recordingRequested>
		<_replayRequested public="1">
			<e path="Bool"/>
			<haxe_doc>* Flag for whether a playback of a recording was requested.</haxe_doc>
		</_replayRequested>
		<_replay public="1">
			<c path="org.flixel.system.FlxReplay"/>
			<haxe_doc>* Container for a game replay object.</haxe_doc>
		</_replay>
		<_debuggerUp public="1">
			<e path="Bool"/>
			<haxe_doc>* A handy boolean that keeps track of whether the debugger exists and is currently visible.</haxe_doc>
		</_debuggerUp>
		<_debugger public="1">
			<c path="org.flixel.system.FlxDebugger"/>
			<haxe_doc>* The debugger overlay object.</haxe_doc>
		</_debugger>
		<_soundTrayBars>
			<c path="Array"><t path="nme.display.Bitmap"/></c>
			<haxe_doc>* Helps display the volume bars on the sound tray.</haxe_doc>
		</_soundTrayBars>
		<_updateSoundTray>
			<e path="Bool"/>
			<haxe_doc>* Because reading any data from DisplayObject is insanely expensive in hxcpp, keep track of whether we need to update it or not.</haxe_doc>
		</_updateSoundTray>
		<_soundTrayTimer>
			<c path="Float"/>
			<haxe_doc>* Helps us auto-hide the sound tray after a volume change.</haxe_doc>
		</_soundTrayTimer>
		<_soundTray>
			<t path="nme.display.Sprite"/>
			<haxe_doc><![CDATA[* The sound tray display container (see <code>createSoundTray()</code>).]]></haxe_doc>
		</_soundTray>
		<_focus>
			<t path="nme.display.Sprite"/>
			<haxe_doc><![CDATA[* The "focus lost" screen (see <code>createFocusScreen()</code>).]]></haxe_doc>
		</_focus>
		<_requestedReset public="1">
			<e path="Bool"/>
			<haxe_doc>* A flag for keeping track of whether a game reset was requested or not.</haxe_doc>
		</_requestedReset>
		<_requestedState public="1">
			<c path="org.flixel.FlxState"/>
			<haxe_doc>* If a state change was requested, the new state object is stored here until we switch to it.</haxe_doc>
		</_requestedState>
		<_maxAccumulation public="1">
			<c path="Int"/>
			<haxe_doc>* Max allowable accumulation (see _accumulator).
	 * Should always (and automatically) be set to roughly 2x the flash player framerate.</haxe_doc>
		</_maxAccumulation>
		<_flashFramerate public="1">
			<c path="Int"/>
			<haxe_doc>* Framerate of the Flash player (NOT the game loop). Default = 30.</haxe_doc>
		</_flashFramerate>
		<_stepSeconds public="1">
			<c path="Float"/>
			<haxe_doc>* Optimization so we don't have to divide _step by 1000 to get its value in seconds every frame. Supposed to be internal.</haxe_doc>
		</_stepSeconds>
		<_step public="1">
			<c path="Int"/>
			<haxe_doc>* Milliseconds of time per step of the game loop.  FlashEvent.g. 60 fps = 16ms. Supposed to be internal.</haxe_doc>
		</_step>
		<_elapsedMS public="1">
			<c path="Int"/>
			<haxe_doc>* Milliseconds of time since last step. Supposed to be internal.</haxe_doc>
		</_elapsedMS>
		<_lostFocus>
			<e path="Bool"/>
			<haxe_doc>* Whether the Flash player lost focus.</haxe_doc>
		</_lostFocus>
		<_accumulator>
			<c path="Int"/>
			<haxe_doc>* Total number of milliseconds elapsed since last update loop.
	 * Counts down as we step through the game loop.</haxe_doc>
		</_accumulator>
		<_mark>
			<c path="Int"/>
			<haxe_doc>* Helper variable to help calculate elapsed time.</haxe_doc>
		</_mark>
		<_total>
			<c path="Int"/>
			<haxe_doc>* Total number of milliseconds elapsed since game start.</haxe_doc>
		</_total>
		<_iState>
			<c path="Class"><c path="org.flixel.FlxState"/></c>
			<haxe_doc>* Class type of the initial/first game state for the game, usually MenuState or something like that.</haxe_doc>
		</_iState>
		<_mouse public="1">
			<t path="nme.display.Sprite"/>
			<haxe_doc>* Mouse cursor.</haxe_doc>
		</_mouse>
		<_state public="1">
			<c path="org.flixel.FlxState"/>
			<haxe_doc>* Current game state.</haxe_doc>
		</_state>
		<forceDebugger public="1">
			<e path="Bool"/>
			<haxe_doc>* Initialize and allow the flixel debugger overlay even in release mode.
	 * Also useful if you don't use FlxPreloader!
	 * @default false</haxe_doc>
		</forceDebugger>
		<useSystemCursor public="1">
			<e path="Bool"/>
			<haxe_doc>* Tells flixel to use the default system mouse cursor instead of custom Flixel mouse cursors.
	 * @default false</haxe_doc>
		</useSystemCursor>
		<useSoundHotKeys public="1">
			<e path="Bool"/>
			<haxe_doc>* Sets 0, -, and + to control the global volume sound volume.
	 * @default true</haxe_doc>
		</useSoundHotKeys>
		<junk><c path="String"/></junk>
		<new public="1" set="method" line="207">
			<f a="GameSizeX:GameSizeY:InitialState:?Zoom:?GameFramerate:?FlashFramerate:?UseSystemCursor">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Class"><c path="org.flixel.FlxState"/></c>
				<c path="Float"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Instantiate a new game object.
	 * @param	GameSizeX		The width of your game in game pixels, not necessarily final display pixels (see Zoom).
	 * @param	GameSizeY		The height of your game in game pixels, not necessarily final display pixels (see Zoom).
	 * @param	InitialState	The class name of the state you want to create and switch to first (e.g. MenuState).
	 * @param	Zoom			The default level of zoom for the game's cameras (e.g. 2 = all pixels are now drawn at 2x).  Default = 1.
	 * @param	GameFramerate	How frequently the game should update (default is 60 times per second).
	 * @param	FlashFramerate	Sets the actual display framerate for Flash player (default is 30 times per second).
	 * @param	UseSystemCursor	Whether to use the default OS mouse pointer, or to use custom flixel ones.</haxe_doc>
		</new>
		<haxe_doc>* FlxGame is the heart of all flixel games, and contains a bunch of basic game loops and things.
 * It is a long and sloppy file that you shouldn't have to worry about too much!
 * It is basically only used to create your game object in the first place,
 * after that FlxG and FlxState have all the useful stuff you actually need.</haxe_doc>
	</class>
	<class path="ProjectClass" params="" file="source/ProjectClass.hx">
		<extends path="org.flixel.FlxGame"/>
		<new public="1" set="method" line="8"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="Reflect" params="" file="/usr/lib/haxe/std/flash/_std/Reflect.hx">
		<hasField public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if an object has a field set. This doesn't take into account the object prototype (class methods).</haxe_doc>
		</hasField>
		<field public="1" set="method" line="32" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the field of an object, or null if [o] is not an object or doesn't have this field.</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="37" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set an object field value.</haxe_doc>
		</setField>
		<getProperty public="1" set="method" line="41" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Similar to field but also supports property (might be slower).</haxe_doc>
		</getProperty>
		<setProperty public="1" set="method" line="51" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Similar to setField but also supports property (might be slower).</haxe_doc>
		</setProperty>
		<callMethod public="1" get="inline" set="null" line="59" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Call a method with the given object and arguments.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="63" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of fields of an object, excluding its prototype (class methods).</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="86" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value is a function or not.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="90" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Generic comparison function, does not work for methods, see [compareMethods]</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" line="96" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Compare two methods closures. Returns true if it's the same method of the same instance.</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="100" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value is an object or not.</haxe_doc>
		</isObject>
		<deleteField public="1" set="method" line="115" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Delete an object field.</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" line="121" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>Make a copy of the fields of an object.</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="128" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="Std" params="" file="/usr/lib/haxe/std/flash/_std/Std.hx">
		<is public="1" set="method" line="29" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value v is of the type t.</haxe_doc>
		</is>
		<string public="1" set="method" line="33" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Convert any value to a String</haxe_doc>
		</string>
		<int public="1" get="inline" set="null" line="37" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Convert a Float to an Int, rounded down.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="41" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="48" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Convert a String to a Float, parsing different possible reprensations.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="52" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Return a random integer between 0 included and x excluded.</haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<enum path="Void" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes"><haxe_doc>The standard Void type. Only [null] values can be of the type [Void].</haxe_doc></enum>
	<class path="Float" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>The standard Float type, this is a double-precision IEEE 64bit float.</haxe_doc></class>
	<class path="Int" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>The standard Int type. Its precision depends on the platform.</haxe_doc>
	</class>
	<typedef path="UInt" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Int"/>
		<haxe_doc>The unsigned Int type is only defined for Flash9. It's currently
	handled the same as a normal Int.</haxe_doc>
	</typedef>
	<typedef path="Null" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<enum path="Bool" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>The standard Boolean type is represented as an enum with two choices.</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.</haxe_doc></class>
	<typedef path="Iterator" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method"><f a=""><c path="Iterator.T"/></f></next>
			<hasNext set="method"><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.</haxe_doc></class>
	<class path="String" params="" file="/usr/lib/haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Returns a part of the String, taking from [startIndex] to [endIndex] - 1.
		If [endIndex] is not specified, length is used.
		If [startIndex] or [endIndex] is smaller than 0, than 0 is used.
		If [startIndex] > [endIndex] then they are swaped.]]></haxe_doc>
		</substring>
		<substr public="1" set="method">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.</haxe_doc>
		</substr>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Split the string using the specified delimiter.</haxe_doc>
		</split>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Similar to [indexOf] but returns the latest index.</haxe_doc>
		</lastIndexOf>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.</haxe_doc>
		</indexOf>
		<charCodeAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at the given position.
		Returns [null] if outside of String bounds.</haxe_doc>
		</charCodeAt>
		<charAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at the given position.
		Returns the empty String if outside of String bounds.</haxe_doc>
		</charAt>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an String where all characters have been lowercased.</haxe_doc>
		</toLowerCase>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an String where all characters have been uppercased.</haxe_doc>
		</toUpperCase>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The number of characters in the String.</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.</haxe_doc>
	</class>
	<class path="StringBuf" params="" file="/usr/lib/haxe/std/StringBuf.hx">
		<toString public="1" get="inline" set="null" line="64">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the content of the string buffer.
		The buffer is not emptied by this operation.</haxe_doc>
		</toString>
		<addSub public="1" get="inline" set="null" line="56">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds a character to the string buffer.</haxe_doc>
		</addSub>
		<addChar public="1" get="inline" set="null" line="49">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds a part of a string to the string buffer.</haxe_doc>
		</addChar>
		<add public="1" get="inline" set="null" line="42">
			<f a="x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds the representation of any value to the string buffer.</haxe_doc>
		</add>
		<b><c path="String"/></b>
		<new public="1" set="method" line="37">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new string buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by
	appending small elements together.</haxe_doc>
	</class>
	<class path="StringTools" params="" file="/usr/lib/haxe/std/StringTools.hx">
		<urlEncode public="1" set="method" line="41" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode an URL by using the standard format.</haxe_doc>
		</urlEncode>
		<urlDecode public="1" set="method" line="68" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Decode an URL using the standard format.</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="95" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Escape HTML special characters of the string.</haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" set="method" line="102" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Unescape HTML special characters of the string.</haxe_doc>
		</htmlUnescape>
		<startsWith public="1" set="method" line="113" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the string [s] starts with the string [start].</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="126" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the string [s] ends with the string [end].</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="141" static="1">
			<f a="s:pos">
				<c path="String"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string [s] at position [pos] is a space.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="149" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the left of the String [s].</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="170" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the right of the String [s].</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="192" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the beginning and the end of the String [s].</haxe_doc>
		</trim>
		<rpad public="1" set="method" line="207" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Pad the string [s] by appending [c] at its right until it reach [l] characters.</haxe_doc>
		</rpad>
		<lpad public="1" set="method" line="229" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Pad the string [s] by appending [c] at its left until it reach [l] characters.</haxe_doc>
		</lpad>
		<replace public="1" set="method" line="254" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurences of the string [sub] in the string [s] by the string [by].</haxe_doc>
		</replace>
		<hex public="1" set="method" line="269" static="1">
			<f a="n:?digits">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode a number into a hexadecimal representation, with an optional number of zeros for left padding.</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="292" static="1">
			<f a="s:index">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Provides a fast native string charCodeAt access. Since the EOF value might vary depending on the platforms, always test with StringTools.isEOF.
		Only guaranteed to work if index in [0,s.length] range. Might not work with strings containing \0 char.</haxe_doc>
		</fastCodeAt>
		<isEOF public="1" get="inline" set="null" line="322" static="1"><f a="c">
	<c path="Int"/>
	<e path="Bool"/>
</f></isEOF>
		<haxe_doc>The StringTools class contains some extra functionalities for [String]
	manipulation. It's stored in a different class in order to prevent
	the standard [String] of being bloated and thus increasing the size of
	each application using it.</haxe_doc>
	</class>
	<enum path="ValueType" params="" file="/usr/lib/haxe/std/flash/_std/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><c path="Enum"><d/></c></TEnum>
		<TClass a="c"><c path="Class"><d/></c></TClass>
		<TBool/>
	</enum>
	<class path="Type" params="" file="/usr/lib/haxe/std/flash/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="40" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<c path="Class"><c path="getClass.T"/></c>
			</f>
			<haxe_doc>Returns the class of a value or [null] if this value is not a Class instance.</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="52" static="1">
			<f a="o">
				<c path="EnumValue"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>Returns the enum of a value or [null] if this value is not an Enum instance.</haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" line="66" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>Returns the super-class of a class, or null if no super class.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="73" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the complete name of a class.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="89" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the complete name of an enum.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="93" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>Evaluates a class from a name. The class must have been compiled
		to be accessible.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="117" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>Evaluates an enum from a name. The enum must have been compiled
		to be accessible.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="134" static="1">
			<f a="cl:args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of the given class with the list of constructor arguments.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="155" static="1">
			<f a="cl">
				<c path="Class"><c path="createEmptyInstance.T"/></c>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Similar to [Reflect.createInstance] excepts that the constructor is not called.
		This enables you to create an instance without any side-effect.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="168" static="1">
			<f a="e:constr:?params">
				<c path="Enum"><c path="createEnum.T"/></c>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>Create an instance of an enum by using a constructor name and parameters.</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="180" static="1">
			<f a="e:index:?params">
				<c path="Enum"><c path="createEnumIndex.T"/></c>
				<c path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>Create an instance of an enum by using a constructor index and parameters.</haxe_doc>
		</createEnumIndex>
		<describe set="method" line="186" static="1"><f a="t:fact">
	<d/>
	<e path="Bool"/>
	<c path="Array"><c path="String"/></c>
</f></describe>
		<getInstanceFields public="1" set="method" line="203" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of instance fields.</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="207" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of a class static fields.</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="214" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns all the available constructor names for an enum.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="219" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>Returns the runtime type of a value.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="251" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Recursively compare two enums constructors and parameters.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="268" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor of an enum</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="272" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns the parameters of an enum</haxe_doc>
		</enumParameters>
		<enumIndex public="1" get="inline" set="null" line="276" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of the constructor of an enum</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" line="280" static="1">
			<f a="e">
				<c path="Enum"><c path="allEnums.T"/></c>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>Returns the list of all enum values that don't take any parameter.</haxe_doc>
		</allEnums>
		<haxe_doc>The haXe Reflection API enables you to retreive informations about any value,
	Classes and Enums at runtime.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<enum path="XmlType" params="" file="/usr/lib/haxe/std/flash/_std/Xml.hx" module="Xml"/>
	<class path="Xml" params="" file="/usr/lib/haxe/std/flash/_std/Xml.hx">
		<Element public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Element>
		<PCData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</PCData>
		<CData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</CData>
		<Comment public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Comment>
		<DocType public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</DocType>
		<Prolog public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Prolog>
		<Document public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Document>
		<parse public="1" set="method" line="49" static="1">
			<f a="str">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Parse a String into an Xml object.</haxe_doc>
		</parse>
		<compare set="method" line="71" static="1">
			<f a="a:b">
				<c path="Xml"/>
				<c path="Xml"/>
				<e path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
		</compare>
		<createElement public="1" set="method" line="77" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createElement>
		<createPCData public="1" set="method" line="81" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createPCData>
		<createCData public="1" set="method" line="86" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createCData>
		<createComment public="1" set="method" line="90" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createComment>
		<createDocType public="1" set="method" line="95" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocType>
		<createProlog public="1" set="method" line="99" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createProlog>
		<createDocument public="1" set="method" line="104" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocument>
		<getNodeType set="method" line="108" static="1"><f a="node">
	<c path="flash.xml.XML"/>
	<e path="XmlType"/>
</f></getNodeType>
		<wrap set="method" line="184" static="1"><f a="node:?type">
	<c path="flash.xml.XML"/>
	<e path="XmlType"/>
	<c path="Xml"/>
</f></wrap>
		<toString public="1" set="method" line="389">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String representation of the Xml node.</haxe_doc>
		</toString>
		<insertChild public="1" set="method" line="379">
			<f a="x:pos">
				<c path="Xml"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Inserts a child at the given position among the other childs.</haxe_doc>
		</insertChild>
		<removeChild public="1" set="method" line="368">
			<f a="x">
				<c path="Xml"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.</haxe_doc>
		</removeChild>
		<addChild public="1" set="method" line="361">
			<f a="x">
				<c path="Xml"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds a child node to the Document or Element.
		One node can only be inside one given node which is indicated by the [parent] property.</haxe_doc>
		</addChild>
		<firstElement public="1" set="method" line="352">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns the first child node which is an Element.</haxe_doc>
		</firstElement>
		<firstChild public="1" set="method" line="343">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns the first child node.</haxe_doc>
		</firstChild>
		<elementsNamed public="1" set="method" line="318">
			<f a="name">
				<c path="String"/>
				<t path="Iterator"><c path="Xml"/></t>
			</f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements with the given nodeName.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elementsNamed>
		<elements public="1" set="method" line="302">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elements>
		<iterator public="1" set="method" line="286">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</iterator>
		<attributes public="1" set="method" line="270">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an [Iterator] on all the attribute names.</haxe_doc>
		</attributes>
		<exists public="1" set="method" line="259">
			<f a="att">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the Element node has a given attribute.
		Attributes are case-sensitive.</haxe_doc>
		</exists>
		<remove public="1" set="method" line="249">
			<f a="att">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Removes an attribute for an Element node.
		Attributes are case-sensitive.</haxe_doc>
		</remove>
		<set public="1" set="method" line="228">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set the given attribute value for an Element node.
		Attributes are case-sensitive.</haxe_doc>
		</set>
		<get public="1" set="method" line="211">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Get the given attribute of an Element node. Returns [null] if not found.
		Attributes are case-sensitive.</haxe_doc>
		</get>
		<getAttribNS set="method" line="198"><f a="cur:ns">
	<c path="flash.xml.XML"/>
	<c path="Array"><c path="String"/></c>
	<c path="flash.xml.XMLList"/>
</f></getAttribNS>
		<wraps set="method" line="191"><f a="xList">
	<c path="flash.xml.XMLList"/>
	<c path="Array"><c path="Xml"/></c>
</f></wraps>
		<getParent set="method" line="179"><f a=""><c path="Xml"/></f></getParent>
		<setNodeValue set="method" line="153"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></setNodeValue>
		<getNodeValue set="method" line="144"><f a=""><c path="String"/></f></getNodeValue>
		<setNodeName set="method" line="131"><f a="n">
	<c path="String"/>
	<c path="String"/>
</f></setNodeName>
		<getNodeName set="method" line="124"><f a=""><c path="String"/></f></getNodeName>
		<_node><c path="flash.xml.XML"/></_node>
		<parent public="1" get="getParent" set="null">
			<c path="Xml"/>
			<haxe_doc>Returns the parent object in the Xml hierarchy.
		The parent can be [null], an Element or a Document.</haxe_doc>
		</parent>
		<nodeValue public="1" get="getNodeValue" set="setNodeValue">
			<c path="String"/>
			<haxe_doc>Returns the node value. Only works if the Xml node is not an Element or a Document.</haxe_doc>
		</nodeValue>
		<nodeName public="1" get="getNodeName" set="setNodeName">
			<c path="String"/>
			<haxe_doc>Returns the node name of an Element.</haxe_doc>
		</nodeName>
		<nodeType public="1" set="null">
			<e path="XmlType"/>
			<haxe_doc>Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.</haxe_doc>
		</nodeType>
		<new set="method" line="75"><f a=""><e path="Void"/></f></new>
		<haxe_doc>The standard Xml class and parsing.
	More API to manipulate XML are available in the [haxe.xml] package.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="flash.display.MovieClip" params="" file="/usr/lib/haxe/std/flash/display/MovieClip.hx" extern="1">
		<extends path="flash.display.Sprite"/>
		<stop public="1" set="method"><f a=""><e path="Void"/></f></stop>
		<prevScene public="1" set="method"><f a=""><e path="Void"/></f></prevScene>
		<prevFrame public="1" set="method"><f a=""><e path="Void"/></f></prevFrame>
		<play public="1" set="method"><f a=""><e path="Void"/></f></play>
		<nextScene public="1" set="method"><f a=""><e path="Void"/></f></nextScene>
		<nextFrame public="1" set="method"><f a=""><e path="Void"/></f></nextFrame>
		<gotoAndStop public="1" set="method"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndStop>
		<gotoAndPlay public="1" set="method"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndPlay>
		<addFrameScript public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></addFrameScript>
		<trackAsMenu public="1"><e path="Bool"/></trackAsMenu>
		<totalFrames public="1" set="null"><c path="Int"/></totalFrames>
		<scenes public="1" set="null"><c path="Array"><c path="flash.display.Scene"/></c></scenes>
		<isPlaying public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</isPlaying>
		<framesLoaded public="1" set="null"><c path="Int"/></framesLoaded>
		<enabled public="1"><e path="Bool"/></enabled>
		<currentScene public="1" set="null"><c path="flash.display.Scene"/></currentScene>
		<currentLabels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></currentLabels>
		<currentLabel public="1" set="null"><c path="String"/></currentLabel>
		<currentFrameLabel public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</currentFrameLabel>
		<currentFrame public="1" set="null"><c path="Int"/></currentFrame>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.Boot" params="" file="/usr/lib/haxe/std/flash/Boot.hx">
		<extends path="flash.display.MovieClip"/>
		<tf static="1"><c path="flash.text.TextField"/></tf>
		<lines static="1"><c path="Array"><c path="String"/></c></lines>
		<lastError static="1"><c path="flash.errors.Error"/></lastError>
		<skip_constructor public="1" line="54" static="1"><e path="Bool"/></skip_constructor>
		<enum_to_string public="1" set="method" line="86" static="1"><f a="e">
	<a>
		<tag><c path="String"/></tag>
		<params><c path="Array"><d/></c></params>
	</a>
	<c path="String"/>
</f></enum_to_string>
		<__instanceof public="1" set="method" line="95" static="1"><f a="v:t">
	<d/>
	<d/>
	<e path="Bool"/>
</f></__instanceof>
		<__clear_trace public="1" set="method" line="105" static="1"><f a=""><e path="Void"/></f></__clear_trace>
		<__set_trace_color public="1" set="method" line="113" static="1"><f a="rgb">
	<t path="UInt"/>
	<e path="Void"/>
</f></__set_trace_color>
		<getTrace public="1" set="method" line="119" static="1"><f a=""><c path="flash.text.TextField"/></f></getTrace>
		<__trace public="1" set="method" line="147" static="1"><f a="v:pos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></__trace>
		<__string_rec public="1" set="method" line="162" static="1"><f a="v:str">
	<d/>
	<c path="String"/>
	<c path="String"/>
</f></__string_rec>
		<__unprotect__ set="method" line="206" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></__unprotect__>
		<init set="method" line="82"><f a=""><e path="Void"/></f></init>
		<doInitDelay set="method" line="77"><f a="_">
	<unknown/>
	<e path="Void"/>
</f></doInitDelay>
		<start set="method" line="56"><f a=""><e path="Void"/></f></start>
		<new public="1" set="method" line="48"><f a=""><e path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="flash._Boot.RealBoot" params="" file="/usr/lib/haxe/std/flash/Boot.hx" private="1" module="flash.Boot">
		<extends path="flash.Boot"/>
		<new set="method" line="38"><f a=""><e path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.Lib" params="" file="/usr/lib/haxe/std/flash/Lib.hx">
		<current public="1" static="1"><c path="flash.display.MovieClip"/></current>
		<getTimer public="1" get="inline" set="null" line="31" static="1"><f a=""><c path="Int"/></f></getTimer>
		<eval public="1" set="method" line="35" static="1"><f a="path">
	<c path="String"/>
	<d/>
</f></eval>
		<getURL public="1" set="method" line="55" static="1"><f a="url:?target">
	<c path="flash.net.URLRequest"/>
	<c path="String"/>
	<e path="Void"/>
</f></getURL>
		<fscommand public="1" set="method" line="63" static="1"><f a="cmd:?param">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></fscommand>
		<trace public="1" set="method" line="67" static="1"><f a="arg">
	<d/>
	<e path="Void"/>
</f></trace>
		<attach public="1" set="method" line="71" static="1"><f a="name">
	<c path="String"/>
	<c path="flash.display.MovieClip"/>
</f></attach>
		<as public="1" params="T" get="inline" set="null" line="76" static="1"><f a="v:c">
	<d/>
	<c path="Class"><c path="as.T"/></c>
	<t path="Null"><c path="as.T"/></t>
</f></as>
	</class>
	<class path="flash.Vector" params="T" file="/usr/lib/haxe/std/flash/Vector.hx" extern="1">
		<ofArray public="1" params="T" get="inline" set="null" line="26" static="1"><f a="v">
	<c path="Array"><c path="ofArray.T"/></c>
	<c path="flash.Vector"><c path="ofArray.T"/></c>
</f></ofArray>
		<convert public="1" params="T:U" get="inline" set="null" line="30" static="1"><f a="v">
	<c path="flash.Vector"><c path="convert.T"/></c>
	<c path="flash.Vector"><c path="convert.U"/></c>
</f></convert>
		<lastIndexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
	<c path="Int"/>
</f></lastIndexOf>
		<indexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
	<c path="Int"/>
</f></indexOf>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<splice public="1" set="method"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></splice>
		<sort public="1" set="method"><f a="f">
	<f a=":">
		<c path="flash.Vector.T"/>
		<c path="flash.Vector.T"/>
		<c path="Int"/>
	</f>
	<e path="Void"/>
</f></sort>
		<slice public="1" set="method"><f a="pos:?end">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></slice>
		<unshift public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<e path="Void"/>
</f></unshift>
		<shift public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></shift>
		<reverse public="1" set="method"><f a=""><e path="Void"/></f></reverse>
		<push public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
</f></push>
		<pop public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></pop>
		<join public="1" set="method"><f a="sep">
	<c path="String"/>
	<c path="String"/>
</f></join>
		<concat public="1" set="method"><f a="?a">
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></concat>
		<fixed public="1"><e path="Bool"/></fixed>
		<length public="1"><t path="UInt"/></length>
		<new public="1" set="method"><f a="?length:?fixed">
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>The Vector class is very similar to Array but is only supported by the Flash Player 10+</haxe_doc>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.accessibility.AccessibilityImplementation" params="" file="/usr/lib/haxe/std/flash/accessibility/AccessibilityImplementation.hx" extern="1">
		<isLabeledBy public="1" set="method"><f a="labelBounds">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></isLabeledBy>
		<get_selectionAnchorIndex public="1" set="method"><f a=""><d/></f></get_selectionAnchorIndex>
		<get_selectionActiveIndex public="1" set="method"><f a=""><d/></f></get_selectionActiveIndex>
		<get_accValue public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accValue>
		<get_accState public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<t path="UInt"/>
</f></get_accState>
		<get_accSelection public="1" set="method"><f a=""><c path="Array"><d/></c></f></get_accSelection>
		<get_accRole public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<t path="UInt"/>
</f></get_accRole>
		<get_accName public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accName>
		<get_accFocus public="1" set="method"><f a=""><t path="UInt"/></f></get_accFocus>
		<get_accDefaultAction public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accDefaultAction>
		<getChildIDArray public="1" set="method"><f a=""><c path="Array"><d/></c></f></getChildIDArray>
		<accSelect public="1" set="method"><f a="operation:childID">
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></accSelect>
		<accLocation public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<d/>
</f></accLocation>
		<accDoDefaultAction public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<e path="Void"/>
</f></accDoDefaultAction>
		<stub public="1"><e path="Bool"/></stub>
		<errno public="1"><t path="UInt"/></errno>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.accessibility.AccessibilityProperties" params="" file="/usr/lib/haxe/std/flash/accessibility/AccessibilityProperties.hx" extern="1">
		<silent public="1"><e path="Bool"/></silent>
		<shortcut public="1"><c path="String"/></shortcut>
		<noAutoLabeling public="1"><e path="Bool"/></noAutoLabeling>
		<name public="1"><c path="String"/></name>
		<forceSimple public="1"><e path="Bool"/></forceSimple>
		<description public="1"><c path="String"/></description>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.display.ActionScriptVersion" params="" file="/usr/lib/haxe/std/flash/display/ActionScriptVersion.hx">
		<ACTIONSCRIPT3/>
		<ACTIONSCRIPT2/>
		<meta><m n=":fakeEnum"><e>UInt</e></m></meta>
	</enum>
	<class path="flash.display.Bitmap" params="" file="/usr/lib/haxe/std/flash/display/Bitmap.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<smoothing public="1"><e path="Bool"/></smoothing>
		<pixelSnapping public="1"><e path="flash.display.PixelSnapping"/></pixelSnapping>
		<bitmapData public="1"><c path="flash.display.BitmapData"/></bitmapData>
		<new public="1" set="method"><f a="?bitmapData:?pixelSnapping:?smoothing">
	<c path="flash.display.BitmapData"/>
	<e path="flash.display.PixelSnapping"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.BlendMode" params="" file="/usr/lib/haxe/std/flash/display/BlendMode.hx">
		<SUBTRACT/>
		<SHADER/>
		<SCREEN/>
		<OVERLAY/>
		<NORMAL/>
		<MULTIPLY/>
		<LIGHTEN/>
		<LAYER/>
		<INVERT/>
		<HARDLIGHT/>
		<ERASE/>
		<DIFFERENCE/>
		<DARKEN/>
		<ALPHA/>
		<ADD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.CapsStyle" params="" file="/usr/lib/haxe/std/flash/display/CapsStyle.hx">
		<SQUARE/>
		<ROUND/>
		<NONE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.ColorCorrection" params="" file="/usr/lib/haxe/std/flash/display/ColorCorrection.hx">
		<ON/>
		<OFF/>
		<DEFAULT/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</enum>
	<enum path="flash.display.ColorCorrectionSupport" params="" file="/usr/lib/haxe/std/flash/display/ColorCorrectionSupport.hx">
		<UNSUPPORTED/>
		<DEFAULT_ON/>
		<DEFAULT_OFF/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</enum>
	<class path="flash.display.FrameLabel" params="" file="/usr/lib/haxe/std/flash/display/FrameLabel.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<name public="1" set="null"><c path="String"/></name>
		<frame public="1" set="null"><c path="Int"/></frame>
		<new public="1" set="method"><f a="name:frame">
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display.GradientType" params="" file="/usr/lib/haxe/std/flash/display/GradientType.hx">
		<RADIAL/>
		<LINEAR/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Graphics" params="" file="/usr/lib/haxe/lib/nme/3,4,4/flash/display/Graphics.hx" extern="1">
		<drawTiles public="1" get="inline" set="null" line="30"><f a="sheet:tileData:?smooth:?flags">
	<c path="nme.display.Tilesheet"/>
	<c path="Array"><c path="Float"/></c>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></drawTiles>
		<moveTo public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></moveTo>
		<lineTo public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineTo>
		<lineStyle public="1" set="method"><f a="?thickness:?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit">
	<c path="Float"/>
	<t path="UInt"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="flash.display.LineScaleMode"/>
	<e path="flash.display.CapsStyle"/>
	<e path="flash.display.JointStyle"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineStyle>
		<lineShaderStyle public="1" set="method">
			<f a="shader:?matrix">
				<c path="flash.display.Shader"/>
				<c path="flash.geom.Matrix"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</lineShaderStyle>
		<lineGradientStyle public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><t path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineGradientStyle>
		<lineBitmapStyle public="1" set="method">
			<f a="bitmap:?matrix:?repeat:?smooth">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Matrix"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</lineBitmapStyle>
		<endFill public="1" set="method"><f a=""><e path="Void"/></f></endFill>
		<drawTriangles public="1" set="method">
			<f a="vertices:?indices:?uvtData:?culling">
				<c path="flash.Vector"><c path="Float"/></c>
				<c path="flash.Vector"><c path="Int"/></c>
				<c path="flash.Vector"><c path="Float"/></c>
				<e path="flash.display.TriangleCulling"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawTriangles>
		<drawRoundRectComplex public="1" set="method"><f a="x:y:width:height:topLeftRadius:topRightRadius:bottomLeftRadius:bottomRightRadius">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRectComplex>
		<drawRoundRect public="1" set="method"><f a="x:y:width:height:ellipseWidth:?ellipseHeight">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRect>
		<drawRect public="1" set="method"><f a="x:y:width:height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRect>
		<drawPath public="1" set="method">
			<f a="commands:data:?winding">
				<c path="flash.Vector"><c path="Int"/></c>
				<c path="flash.Vector"><c path="Float"/></c>
				<e path="flash.display.GraphicsPathWinding"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawPath>
		<drawGraphicsData public="1" set="method">
			<f a="graphicsData">
				<c path="flash.Vector"><c path="flash.display.IGraphicsData"/></c>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawGraphicsData>
		<drawEllipse public="1" set="method"><f a="x:y:width:height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawEllipse>
		<drawCircle public="1" set="method"><f a="x:y:radius">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawCircle>
		<curveTo public="1" set="method"><f a="controlX:controlY:anchorX:anchorY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></curveTo>
		<cubicCurveTo public="1">
			<f a="controlX1:controlY1:controlX2:controlY2:anchorX:anchorY">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</cubicCurveTo>
		<copyFrom public="1" set="method">
			<f a="sourceGraphics">
				<c path="flash.display.Graphics"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</copyFrom>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<beginShaderFill public="1" set="method">
			<f a="shader:?matrix">
				<c path="flash.display.Shader"/>
				<c path="flash.geom.Matrix"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</beginShaderFill>
		<beginGradientFill public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><t path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginGradientFill>
		<beginFill public="1" set="method"><f a="color:?alpha">
	<t path="UInt"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginFill>
		<beginBitmapFill public="1" set="method"><f a="bitmap:?matrix:?repeat:?smooth">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Matrix"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></beginBitmapFill>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display.GraphicsPathWinding" params="" file="/usr/lib/haxe/std/flash/display/GraphicsPathWinding.hx">
		<NON_ZERO/>
		<EVEN_ODD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.IGraphicsData" params="" file="/usr/lib/haxe/std/flash/display/IGraphicsData.hx" extern="1" interface="1"/>
	<enum path="flash.display.InterpolationMethod" params="" file="/usr/lib/haxe/std/flash/display/InterpolationMethod.hx">
		<RGB/>
		<LINEAR_RGB/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.JointStyle" params="" file="/usr/lib/haxe/std/flash/display/JointStyle.hx">
		<ROUND/>
		<MITER/>
		<BEVEL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.LineScaleMode" params="" file="/usr/lib/haxe/std/flash/display/LineScaleMode.hx">
		<VERTICAL/>
		<NORMAL/>
		<NONE/>
		<HORIZONTAL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Loader" params="" file="/usr/lib/haxe/std/flash/display/Loader.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<unloadAndStop public="1" set="method">
			<f a="?gc">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</unloadAndStop>
		<unload public="1" set="method"><f a=""><e path="Void"/></f></unload>
		<loadBytes public="1" set="method"><f a="bytes:?context">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.system.LoaderContext"/>
	<e path="Void"/>
</f></loadBytes>
		<load public="1" set="method"><f a="request:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.system.LoaderContext"/>
	<e path="Void"/>
</f></load>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<uncaughtErrorEvents public="1" set="null">
			<c path="flash.events.UncaughtErrorEvents"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</uncaughtErrorEvents>
		<contentLoaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></contentLoaderInfo>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.LoaderInfo" params="" file="/usr/lib/haxe/std/flash/display/LoaderInfo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<getLoaderInfoByDefinition public="1" set="method" static="1"><f a="object">
	<d/>
	<c path="flash.display.LoaderInfo"/>
</f></getLoaderInfoByDefinition>
		<width public="1" set="null"><c path="Int"/></width>
		<url public="1" set="null"><c path="String"/></url>
		<uncaughtErrorEvents public="1" set="null">
			<c path="flash.events.UncaughtErrorEvents"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</uncaughtErrorEvents>
		<swfVersion public="1" set="null"><t path="UInt"/></swfVersion>
		<sharedEvents public="1" set="null"><c path="flash.events.EventDispatcher"/></sharedEvents>
		<sameDomain public="1" set="null"><e path="Bool"/></sameDomain>
		<parentAllowsChild public="1" set="null"><e path="Bool"/></parentAllowsChild>
		<parameters public="1" set="null"><d><c path="String"/></d></parameters>
		<loaderURL public="1" set="null"><c path="String"/></loaderURL>
		<loader public="1" set="null"><c path="flash.display.Loader"/></loader>
		<isURLInaccessible public="1" set="null">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isURLInaccessible>
		<height public="1" set="null"><c path="Int"/></height>
		<frameRate public="1" set="null"><c path="Float"/></frameRate>
		<contentType public="1" set="null"><c path="String"/></contentType>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<childAllowsParent public="1" set="null"><e path="Bool"/></childAllowsParent>
		<bytesTotal public="1" set="null"><t path="UInt"/></bytesTotal>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<bytes public="1" set="null"><c path="flash.utils.ByteArray"/></bytes>
		<applicationDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<actionScriptVersion public="1" set="null"><e path="flash.display.ActionScriptVersion"/></actionScriptVersion>
	</class>
	<class path="flash.display.NativeMenu" params="" file="/usr/lib/haxe/std/flash/display/NativeMenu.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<enum path="flash.display.PixelSnapping" params="" file="/usr/lib/haxe/std/flash/display/PixelSnapping.hx">
		<NEVER/>
		<AUTO/>
		<ALWAYS/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Scene" params="" file="/usr/lib/haxe/std/flash/display/Scene.hx" extern="1">
		<numFrames public="1" set="null"><c path="Int"/></numFrames>
		<name public="1" set="null"><c path="String"/></name>
		<labels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></labels>
		<new public="1" set="method"><f a="name:labels:numFrames">
	<c path="String"/>
	<c path="Array"><c path="flash.display.FrameLabel"/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display.Shader" params="" file="/usr/lib/haxe/std/flash/display/Shader.hx" extern="1">
		<precisionHint public="1"><e path="flash.display.ShaderPrecision"/></precisionHint>
		<data public="1"><c path="flash.display.ShaderData"/></data>
		<byteCode public="1" get="null"><c path="flash.utils.ByteArray"/></byteCode>
		<new public="1" set="method"><f a="?code">
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.display.ShaderData" params="" file="/usr/lib/haxe/std/flash/display/ShaderData.hx" extern="1">
		<new public="1" set="method"><f a="byteCode">
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.display.ShaderPrecision" params="" file="/usr/lib/haxe/std/flash/display/ShaderPrecision.hx">
		<FULL/>
		<FAST/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.SpreadMethod" params="" file="/usr/lib/haxe/std/flash/display/SpreadMethod.hx">
		<REPEAT/>
		<REFLECT/>
		<PAD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Stage" params="" file="/usr/lib/haxe/std/flash/display/Stage.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<isFocusInaccessible public="1" set="method"><f a=""><e path="Bool"/></f></isFocusInaccessible>
		<invalidate public="1" set="method"><f a=""><e path="Void"/></f></invalidate>
		<wmodeGPU public="1" set="null">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</wmodeGPU>
		<stageWidth public="1"><c path="Int"/></stageWidth>
		<stageVideos public="1">
			<c path="flash.Vector"><c path="flash.media.StageVideo"/></c>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</stageVideos>
		<stageHeight public="1"><c path="Int"/></stageHeight>
		<stageFocusRect public="1"><e path="Bool"/></stageFocusRect>
		<stage3Ds public="1">
			<c path="flash.Vector"><c path="flash.display.Stage3D"/></c>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</stage3Ds>
		<softKeyboardRect public="1">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</softKeyboardRect>
		<showDefaultContextMenu public="1"><e path="Bool"/></showDefaultContextMenu>
		<scaleMode public="1"><e path="flash.display.StageScaleMode"/></scaleMode>
		<quality public="1"><e path="flash.display.StageQuality"/></quality>
		<mouseLock public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</mouseLock>
		<fullScreenWidth public="1" set="null"><t path="UInt"/></fullScreenWidth>
		<fullScreenSourceRect public="1"><c path="flash.geom.Rectangle"/></fullScreenSourceRect>
		<fullScreenHeight public="1" set="null"><t path="UInt"/></fullScreenHeight>
		<frameRate public="1"><c path="Float"/></frameRate>
		<focus public="1"><c path="flash.display.InteractiveObject"/></focus>
		<displayState public="1"><e path="flash.display.StageDisplayState"/></displayState>
		<displayContextInfo public="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</displayContextInfo>
		<colorCorrectionSupport public="1" set="null">
			<e path="flash.display.ColorCorrectionSupport"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</colorCorrectionSupport>
		<colorCorrection public="1">
			<e path="flash.display.ColorCorrection"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</colorCorrection>
		<color public="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</color>
		<allowsFullScreenInteractive public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</allowsFullScreenInteractive>
		<allowsFullScreen public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</allowsFullScreen>
		<align public="1"><e path="flash.display.StageAlign"/></align>
	</class>
	<class path="flash.display.Stage3D" params="" file="/usr/lib/haxe/std/flash/display/Stage3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<requestContext3D public="1" set="method"><f a="?context3DRenderMode">
	<c path="String"/>
	<e path="Void"/>
</f></requestContext3D>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<visible public="1"><e path="Bool"/></visible>
		<context3D public="1" set="null"><c path="flash.display3D.Context3D"/></context3D>
		<meta><m n=":require"><e>flash11</e></m></meta>
	</class>
	<enum path="flash.display.StageAlign" params="" file="/usr/lib/haxe/std/flash/display/StageAlign.hx">
		<TOP_RIGHT/>
		<TOP_LEFT/>
		<TOP/>
		<RIGHT/>
		<LEFT/>
		<BOTTOM_RIGHT/>
		<BOTTOM_LEFT/>
		<BOTTOM/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageDisplayState" params="" file="/usr/lib/haxe/std/flash/display/StageDisplayState.hx">
		<NORMAL/>
		<FULL_SCREEN_INTERACTIVE/>
		<FULL_SCREEN/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageQuality" params="" file="/usr/lib/haxe/std/flash/display/StageQuality.hx">
		<MEDIUM/>
		<LOW/>
		<HIGH_8X8_LINEAR/>
		<HIGH_8X8/>
		<HIGH_16X16_LINEAR/>
		<HIGH_16X16/>
		<HIGH/>
		<BEST/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageScaleMode" params="" file="/usr/lib/haxe/std/flash/display/StageScaleMode.hx">
		<SHOW_ALL/>
		<NO_SCALE/>
		<NO_BORDER/>
		<EXACT_FIT/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.TriangleCulling" params="" file="/usr/lib/haxe/std/flash/display/TriangleCulling.hx">
		<POSITIVE/>
		<NONE/>
		<NEGATIVE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display3D.Context3D" params="" file="/usr/lib/haxe/std/flash/display3D/Context3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<setVertexBufferAt public="1" set="method"><f a="index:buffer:?bufferOffset:?format">
	<c path="Int"/>
	<c path="flash.display3D.VertexBuffer3D"/>
	<c path="Int"/>
	<e path="flash.display3D.Context3DVertexBufferFormat"/>
	<e path="Void"/>
</f></setVertexBufferAt>
		<setTextureAt public="1" set="method"><f a="sampler:texture">
	<c path="Int"/>
	<c path="flash.display3D.textures.TextureBase"/>
	<e path="Void"/>
</f></setTextureAt>
		<setStencilReferenceValue public="1" set="method"><f a="referenceValue:?readMask:?writeMask">
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setStencilReferenceValue>
		<setStencilActions public="1" set="method"><f a="?triangleFace:?compareMode:?actionOnBothPass:?actionOnDepthFail:?actionOnDepthPassStencilFail">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="Void"/>
</f></setStencilActions>
		<setScissorRectangle public="1" set="method"><f a="rectangle">
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></setScissorRectangle>
		<setRenderToTexture public="1" set="method"><f a="texture:?enableDepthAndStencil:?antiAlias:?surfaceSelector">
	<c path="flash.display3D.textures.TextureBase"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setRenderToTexture>
		<setRenderToBackBuffer public="1" set="method"><f a=""><e path="Void"/></f></setRenderToBackBuffer>
		<setProgramConstantsFromVector public="1" set="method"><f a="programType:firstRegister:data:?numRegisters">
	<e path="flash.display3D.Context3DProgramType"/>
	<c path="Int"/>
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></setProgramConstantsFromVector>
		<setProgramConstantsFromMatrix public="1" set="method"><f a="programType:firstRegister:matrix:?transposedMatrix">
	<e path="flash.display3D.Context3DProgramType"/>
	<c path="Int"/>
	<c path="flash.geom.Matrix3D"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setProgramConstantsFromMatrix>
		<setProgramConstantsFromByteArray public="1">
			<f a="programType:firstRegister:numRegisters:data:byteArrayOffset">
				<e path="flash.display3D.Context3DProgramType"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="flash.utils.ByteArray"/>
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</setProgramConstantsFromByteArray>
		<setProgram public="1" set="method"><f a="program">
	<c path="flash.display3D.Program3D"/>
	<e path="Void"/>
</f></setProgram>
		<setDepthTest public="1" set="method"><f a="depthMask:passCompareMode">
	<e path="Bool"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<e path="Void"/>
</f></setDepthTest>
		<setCulling public="1" set="method"><f a="triangleFaceToCull">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<e path="Void"/>
</f></setCulling>
		<setColorMask public="1" set="method"><f a="red:green:blue:alpha">
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setColorMask>
		<setBlendFactors public="1" set="method"><f a="sourceFactor:destinationFactor">
	<e path="flash.display3D.Context3DBlendFactor"/>
	<e path="flash.display3D.Context3DBlendFactor"/>
	<e path="Void"/>
</f></setBlendFactors>
		<present public="1" set="method"><f a=""><e path="Void"/></f></present>
		<drawTriangles public="1" set="method"><f a="indexBuffer:?firstIndex:?numTriangles">
	<c path="flash.display3D.IndexBuffer3D"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></drawTriangles>
		<drawToBitmapData public="1" set="method"><f a="destination">
	<c path="flash.display.BitmapData"/>
	<e path="Void"/>
</f></drawToBitmapData>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<createVertexBuffer public="1" set="method"><f a="numVertices:data32PerVertex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.display3D.VertexBuffer3D"/>
</f></createVertexBuffer>
		<createTexture public="1" set="method"><f a="width:height:format:optimizeForRenderToTexture:?streamingLevels">
	<c path="Int"/>
	<c path="Int"/>
	<e path="flash.display3D.Context3DTextureFormat"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="flash.display3D.textures.Texture"/>
</f></createTexture>
		<createProgram public="1" set="method"><f a=""><c path="flash.display3D.Program3D"/></f></createProgram>
		<createIndexBuffer public="1" set="method"><f a="numIndices">
	<c path="Int"/>
	<c path="flash.display3D.IndexBuffer3D"/>
</f></createIndexBuffer>
		<createCubeTexture public="1" set="method"><f a="size:format:optimizeForRenderToTexture:?streamingLevels">
	<c path="Int"/>
	<e path="flash.display3D.Context3DTextureFormat"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="flash.display3D.textures.CubeTexture"/>
</f></createCubeTexture>
		<configureBackBuffer public="1" set="method"><f a="width:height:antiAlias:?enableDepthAndStencil">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></configureBackBuffer>
		<clear public="1" set="method"><f a="?red:?green:?blue:?alpha:?depth:?stencil:?mask">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></clear>
		<enableErrorChecking public="1"><e path="Bool"/></enableErrorChecking>
		<driverInfo public="1" set="null"><c path="String"/></driverInfo>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display3D.Context3DBlendFactor" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DBlendFactor.hx">
		<ZERO/>
		<SOURCE_COLOR/>
		<SOURCE_ALPHA/>
		<ONE_MINUS_SOURCE_COLOR/>
		<ONE_MINUS_SOURCE_ALPHA/>
		<ONE_MINUS_DESTINATION_COLOR/>
		<ONE_MINUS_DESTINATION_ALPHA/>
		<ONE/>
		<DESTINATION_COLOR/>
		<DESTINATION_ALPHA/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DCompareMode" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DCompareMode.hx">
		<NOT_EQUAL/>
		<NEVER/>
		<LESS_EQUAL/>
		<LESS/>
		<GREATER_EQUAL/>
		<GREATER/>
		<EQUAL/>
		<ALWAYS/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DProgramType" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DProgramType.hx">
		<VERTEX/>
		<FRAGMENT/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DStencilAction" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DStencilAction.hx">
		<ZERO/>
		<SET/>
		<KEEP/>
		<INVERT/>
		<INCREMENT_WRAP/>
		<INCREMENT_SATURATE/>
		<DECREMENT_WRAP/>
		<DECREMENT_SATURATE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DTextureFormat" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DTextureFormat.hx">
		<COMPRESSED/>
		<BGRA/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DTriangleFace" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DTriangleFace.hx">
		<NONE/>
		<FRONT_AND_BACK/>
		<FRONT/>
		<BACK/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DVertexBufferFormat" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DVertexBufferFormat.hx">
		<FLOAT_4/>
		<FLOAT_3/>
		<FLOAT_2/>
		<FLOAT_1/>
		<BYTES_4/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display3D.IndexBuffer3D" params="" file="/usr/lib/haxe/std/flash/display3D/IndexBuffer3D.hx" extern="1">
		<uploadFromVector public="1" set="method"><f a="data:startOffset:count">
	<c path="flash.Vector"><t path="UInt"/></c>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromVector>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startOffset:count">
	<c path="flash.utils.ByteArray"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.Program3D" params="" file="/usr/lib/haxe/std/flash/display3D/Program3D.hx" extern="1">
		<upload public="1" set="method"><f a="vertexProgram:fragmentProgram">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></upload>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.VertexBuffer3D" params="" file="/usr/lib/haxe/std/flash/display3D/VertexBuffer3D.hx" extern="1">
		<uploadFromVector public="1" set="method"><f a="data:startVertex:numVertices">
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromVector>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startVertex:numVertices">
	<c path="flash.utils.ByteArray"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
	</class>
	<class path="flash.display3D.textures.TextureBase" params="" file="/usr/lib/haxe/std/flash/display3D/textures/TextureBase.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
	</class>
	<class path="flash.display3D.textures.CubeTexture" params="" file="/usr/lib/haxe/std/flash/display3D/textures/CubeTexture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:side:?miplevel">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<uploadFromBitmapData public="1" set="method"><f a="source:side:?miplevel">
	<c path="flash.display.BitmapData"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromBitmapData>
		<uploadCompressedTextureFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?async">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></uploadCompressedTextureFromByteArray>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.textures.Texture" params="" file="/usr/lib/haxe/std/flash/display3D/textures/Texture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?miplevel">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<uploadFromBitmapData public="1" set="method"><f a="source:?miplevel">
	<c path="flash.display.BitmapData"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromBitmapData>
		<uploadCompressedTextureFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?async">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></uploadCompressedTextureFromByteArray>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.errors.Error" params="" file="/usr/lib/haxe/std/flash/errors/Error.hx" extern="1">
		<length public="1" static="1"><c path="Int"/></length>
		<getErrorMessage public="1" set="method" static="1"><f a="index">
	<c path="Int"/>
	<c path="String"/>
</f></getErrorMessage>
		<throwError public="1" set="method" static="1"><f a="type:index:?p1:?p2:?p3:?p4:?p5">
	<c path="Class"><d/></c>
	<t path="UInt"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></throwError>
		<getStackTrace public="1" set="method"><f a=""><c path="String"/></f></getStackTrace>
		<name public="1"><d/></name>
		<message public="1"><d/></message>
		<errorID public="1" set="null"><c path="Int"/></errorID>
		<new public="1" set="method"><f a="?message:?id">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.errors.TypeError" params="" file="/usr/lib/haxe/std/flash/errors/TypeError.hx" extern="1">
		<extends path="flash.errors.Error"/>
		<meta><m n=":native"><e>TypeError</e></m></meta>
	</class>
	<class path="flash.events.Event" params="" file="/usr/lib/haxe/std/flash/events/Event.hx" extern="1">
		<ACTIVATE public="1" static="1"><c path="String"/></ACTIVATE>
		<ADDED public="1" static="1"><c path="String"/></ADDED>
		<ADDED_TO_STAGE public="1" static="1"><c path="String"/></ADDED_TO_STAGE>
		<CANCEL public="1" static="1"><c path="String"/></CANCEL>
		<CHANGE public="1" static="1"><c path="String"/></CHANGE>
		<CLEAR public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CLEAR>
		<CLOSE public="1" static="1"><c path="String"/></CLOSE>
		<COMPLETE public="1" static="1"><c path="String"/></COMPLETE>
		<CONNECT public="1" static="1"><c path="String"/></CONNECT>
		<CONTEXT3D_CREATE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</CONTEXT3D_CREATE>
		<COPY public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</COPY>
		<CUT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CUT>
		<DEACTIVATE public="1" static="1"><c path="String"/></DEACTIVATE>
		<ENTER_FRAME public="1" static="1"><c path="String"/></ENTER_FRAME>
		<EXIT_FRAME public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</EXIT_FRAME>
		<FRAME_CONSTRUCTED public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</FRAME_CONSTRUCTED>
		<FRAME_LABEL public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</FRAME_LABEL>
		<FULLSCREEN public="1" static="1"><c path="String"/></FULLSCREEN>
		<ID3 public="1" static="1"><c path="String"/></ID3>
		<INIT public="1" static="1"><c path="String"/></INIT>
		<MOUSE_LEAVE public="1" static="1"><c path="String"/></MOUSE_LEAVE>
		<OPEN public="1" static="1"><c path="String"/></OPEN>
		<PASTE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</PASTE>
		<REMOVED public="1" static="1"><c path="String"/></REMOVED>
		<REMOVED_FROM_STAGE public="1" static="1"><c path="String"/></REMOVED_FROM_STAGE>
		<RENDER public="1" static="1"><c path="String"/></RENDER>
		<RESIZE public="1" static="1"><c path="String"/></RESIZE>
		<SCROLL public="1" static="1"><c path="String"/></SCROLL>
		<SELECT public="1" static="1"><c path="String"/></SELECT>
		<SELECT_ALL public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</SELECT_ALL>
		<SOUND_COMPLETE public="1" static="1"><c path="String"/></SOUND_COMPLETE>
		<SUSPEND public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</SUSPEND>
		<TAB_CHILDREN_CHANGE public="1" static="1"><c path="String"/></TAB_CHILDREN_CHANGE>
		<TAB_ENABLED_CHANGE public="1" static="1"><c path="String"/></TAB_ENABLED_CHANGE>
		<TAB_INDEX_CHANGE public="1" static="1"><c path="String"/></TAB_INDEX_CHANGE>
		<TEXTURE_READY public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</TEXTURE_READY>
		<TEXT_INTERACTION_MODE_CHANGE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</TEXT_INTERACTION_MODE_CHANGE>
		<UNLOAD public="1" static="1"><c path="String"/></UNLOAD>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<stopPropagation public="1" set="method"><f a=""><e path="Void"/></f></stopPropagation>
		<stopImmediatePropagation public="1" set="method"><f a=""><e path="Void"/></f></stopImmediatePropagation>
		<preventDefault public="1" set="method"><f a=""><e path="Void"/></f></preventDefault>
		<isDefaultPrevented public="1" set="method"><f a=""><e path="Bool"/></f></isDefaultPrevented>
		<formatToString public="1" set="method"><f a="className:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="String"/>
</f></formatToString>
		<clone public="1" set="method"><f a=""><c path="flash.events.Event"/></f></clone>
		<type public="1" set="null"><c path="String"/></type>
		<target public="1" set="null"><d/></target>
		<eventPhase public="1" set="null"><e path="flash.events.EventPhase"/></eventPhase>
		<currentTarget public="1" set="null"><d/></currentTarget>
		<cancelable public="1" set="null"><e path="Bool"/></cancelable>
		<bubbles public="1" set="null"><e path="Bool"/></bubbles>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.TextEvent" params="" file="/usr/lib/haxe/std/flash/events/TextEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<LINK public="1" static="1"><c path="String"/></LINK>
		<TEXT_INPUT public="1" static="1"><c path="String"/></TEXT_INPUT>
		<text public="1"><c path="String"/></text>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?text">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.ErrorEvent" params="" file="/usr/lib/haxe/std/flash/events/ErrorEvent.hx" extern="1">
		<extends path="flash.events.TextEvent"/>
		<ERROR public="1" static="1"><c path="String"/></ERROR>
		<errorID public="1" set="null">
			<c path="Int"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</errorID>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?text:?id">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.events.EventPhase" params="" file="/usr/lib/haxe/std/flash/events/EventPhase.hx">
		<CAPTURING_PHASE/>
		<BUBBLING_PHASE/>
		<AT_TARGET/>
		<meta><m n=":fakeEnum"><e>UInt</e></m></meta>
	</enum>
	<class path="flash.events.IOErrorEvent" params="" file="/usr/lib/haxe/std/flash/events/IOErrorEvent.hx" extern="1">
		<extends path="flash.events.ErrorEvent"/>
		<DISK_ERROR public="1" static="1"><c path="String"/></DISK_ERROR>
		<IO_ERROR public="1" static="1"><c path="String"/></IO_ERROR>
		<NETWORK_ERROR public="1" static="1"><c path="String"/></NETWORK_ERROR>
		<VERIFY_ERROR public="1" static="1"><c path="String"/></VERIFY_ERROR>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?text:?id">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.KeyboardEvent" params="" file="/usr/lib/haxe/std/flash/events/KeyboardEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<KEY_DOWN public="1" static="1"><c path="String"/></KEY_DOWN>
		<KEY_UP public="1" static="1"><c path="String"/></KEY_UP>
		<updateAfterEvent public="1" set="method"><f a=""><e path="Void"/></f></updateAfterEvent>
		<shiftKey public="1"><e path="Bool"/></shiftKey>
		<keyLocation public="1"><e path="flash.ui.KeyLocation"/></keyLocation>
		<keyCode public="1"><t path="UInt"/></keyCode>
		<ctrlKey public="1"><e path="Bool"/></ctrlKey>
		<charCode public="1"><t path="UInt"/></charCode>
		<altKey public="1"><e path="Bool"/></altKey>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?charCodeValue:?keyCodeValue:?keyLocationValue:?ctrlKeyValue:?altKeyValue:?shiftKeyValue">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="flash.ui.KeyLocation"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.MouseEvent" params="" file="/usr/lib/haxe/std/flash/events/MouseEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<CLICK public="1" static="1"><c path="String"/></CLICK>
		<CONTEXT_MENU public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</CONTEXT_MENU>
		<DOUBLE_CLICK public="1" static="1"><c path="String"/></DOUBLE_CLICK>
		<MIDDLE_CLICK public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</MIDDLE_CLICK>
		<MIDDLE_MOUSE_DOWN public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</MIDDLE_MOUSE_DOWN>
		<MIDDLE_MOUSE_UP public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</MIDDLE_MOUSE_UP>
		<MOUSE_DOWN public="1" static="1"><c path="String"/></MOUSE_DOWN>
		<MOUSE_MOVE public="1" static="1"><c path="String"/></MOUSE_MOVE>
		<MOUSE_OUT public="1" static="1"><c path="String"/></MOUSE_OUT>
		<MOUSE_OVER public="1" static="1"><c path="String"/></MOUSE_OVER>
		<MOUSE_UP public="1" static="1"><c path="String"/></MOUSE_UP>
		<MOUSE_WHEEL public="1" static="1"><c path="String"/></MOUSE_WHEEL>
		<RELEASE_OUTSIDE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</RELEASE_OUTSIDE>
		<RIGHT_CLICK public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</RIGHT_CLICK>
		<RIGHT_MOUSE_DOWN public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</RIGHT_MOUSE_DOWN>
		<RIGHT_MOUSE_UP public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</RIGHT_MOUSE_UP>
		<ROLL_OUT public="1" static="1"><c path="String"/></ROLL_OUT>
		<ROLL_OVER public="1" static="1"><c path="String"/></ROLL_OVER>
		<updateAfterEvent public="1" set="method"><f a=""><e path="Void"/></f></updateAfterEvent>
		<stageY public="1" set="null"><c path="Float"/></stageY>
		<stageX public="1" set="null"><c path="Float"/></stageX>
		<shiftKey public="1"><e path="Bool"/></shiftKey>
		<relatedObject public="1"><c path="flash.display.InteractiveObject"/></relatedObject>
		<movementY public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</movementY>
		<movementX public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</movementX>
		<localY public="1"><c path="Float"/></localY>
		<localX public="1"><c path="Float"/></localX>
		<isRelatedObjectInaccessible public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</isRelatedObjectInaccessible>
		<delta public="1"><c path="Int"/></delta>
		<ctrlKey public="1"><e path="Bool"/></ctrlKey>
		<buttonDown public="1"><e path="Bool"/></buttonDown>
		<altKey public="1"><e path="Bool"/></altKey>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?localX:?localY:?relatedObject:?ctrlKey:?altKey:?shiftKey:?buttonDown:?delta">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="flash.display.InteractiveObject"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.NetStatusEvent" params="" file="/usr/lib/haxe/std/flash/events/NetStatusEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<NET_STATUS public="1" static="1"><c path="String"/></NET_STATUS>
		<info public="1"><d/></info>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?info">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.TouchEvent" params="" file="/usr/lib/haxe/std/flash/events/TouchEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<PROXIMITY_BEGIN public="1" static="1"><c path="String"/></PROXIMITY_BEGIN>
		<PROXIMITY_END public="1" static="1"><c path="String"/></PROXIMITY_END>
		<PROXIMITY_MOVE public="1" static="1"><c path="String"/></PROXIMITY_MOVE>
		<PROXIMITY_OUT public="1" static="1"><c path="String"/></PROXIMITY_OUT>
		<PROXIMITY_OVER public="1" static="1"><c path="String"/></PROXIMITY_OVER>
		<PROXIMITY_ROLL_OUT public="1" static="1"><c path="String"/></PROXIMITY_ROLL_OUT>
		<PROXIMITY_ROLL_OVER public="1" static="1"><c path="String"/></PROXIMITY_ROLL_OVER>
		<TOUCH_BEGIN public="1" static="1"><c path="String"/></TOUCH_BEGIN>
		<TOUCH_END public="1" static="1"><c path="String"/></TOUCH_END>
		<TOUCH_MOVE public="1" static="1"><c path="String"/></TOUCH_MOVE>
		<TOUCH_OUT public="1" static="1"><c path="String"/></TOUCH_OUT>
		<TOUCH_OVER public="1" static="1"><c path="String"/></TOUCH_OVER>
		<TOUCH_ROLL_OUT public="1" static="1"><c path="String"/></TOUCH_ROLL_OUT>
		<TOUCH_ROLL_OVER public="1" static="1"><c path="String"/></TOUCH_ROLL_OVER>
		<TOUCH_TAP public="1" static="1"><c path="String"/></TOUCH_TAP>
		<updateAfterEvent public="1" set="method"><f a=""><e path="Void"/></f></updateAfterEvent>
		<touchPointID public="1"><c path="Int"/></touchPointID>
		<stageY public="1" set="null"><c path="Float"/></stageY>
		<stageX public="1" set="null"><c path="Float"/></stageX>
		<sizeY public="1"><c path="Float"/></sizeY>
		<sizeX public="1"><c path="Float"/></sizeX>
		<shiftKey public="1"><e path="Bool"/></shiftKey>
		<relatedObject public="1"><c path="flash.display.InteractiveObject"/></relatedObject>
		<pressure public="1"><c path="Float"/></pressure>
		<localY public="1"><c path="Float"/></localY>
		<localX public="1"><c path="Float"/></localX>
		<isRelatedObjectInaccessible public="1"><e path="Bool"/></isRelatedObjectInaccessible>
		<isPrimaryTouchPoint public="1"><e path="Bool"/></isPrimaryTouchPoint>
		<ctrlKey public="1"><e path="Bool"/></ctrlKey>
		<altKey public="1"><e path="Bool"/></altKey>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?touchPointID:?isPrimaryTouchPoint:?localX:?localY:?sizeX:?sizeY:?pressure:?relatedObject:?ctrlKey:?altKey:?shiftKey">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="flash.display.InteractiveObject"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<class path="flash.events.UncaughtErrorEvents" params="" file="/usr/lib/haxe/std/flash/events/UncaughtErrorEvents.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<class path="flash.external.ExternalInterface" params="" file="/usr/lib/haxe/std/flash/external/ExternalInterface.hx" extern="1">
		<available public="1" set="null" static="1"><e path="Bool"/></available>
		<marshallExceptions public="1" static="1"><e path="Bool"/></marshallExceptions>
		<objectID public="1" set="null" static="1"><c path="String"/></objectID>
		<addCallback public="1" set="method" static="1"><f a="functionName:closure">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></addCallback>
		<call public="1" set="method" static="1"><f a="functionName:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></call>
	</class>
	<class path="flash.filters.BitmapFilter" params="" file="/usr/lib/haxe/std/flash/filters/BitmapFilter.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.filters.BitmapFilter"/></f></clone>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.geom.ColorTransform" params="" file="/usr/lib/haxe/std/flash/geom/ColorTransform.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<concat public="1" set="method"><f a="second">
	<c path="flash.geom.ColorTransform"/>
	<e path="Void"/>
</f></concat>
		<redOffset public="1"><c path="Float"/></redOffset>
		<redMultiplier public="1"><c path="Float"/></redMultiplier>
		<greenOffset public="1"><c path="Float"/></greenOffset>
		<greenMultiplier public="1"><c path="Float"/></greenMultiplier>
		<color public="1"><t path="UInt"/></color>
		<blueOffset public="1"><c path="Float"/></blueOffset>
		<blueMultiplier public="1"><c path="Float"/></blueMultiplier>
		<alphaOffset public="1"><c path="Float"/></alphaOffset>
		<alphaMultiplier public="1"><c path="Float"/></alphaMultiplier>
		<new public="1" set="method"><f a="?redMultiplier:?greenMultiplier:?blueMultiplier:?alphaMultiplier:?redOffset:?greenOffset:?blueOffset:?alphaOffset">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Matrix" params="" file="/usr/lib/haxe/std/flash/geom/Matrix.hx" extern="1">
		<translate public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></translate>
		<transformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></transformPoint>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<setTo public="1">
			<f a="aa:ba:ca:da:txa:tya">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<scale public="1" set="method"><f a="sx:sy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></scale>
		<rotate public="1" set="method"><f a="angle">
	<c path="Float"/>
	<e path="Void"/>
</f></rotate>
		<invert public="1" set="method"><f a=""><e path="Void"/></f></invert>
		<identity public="1" set="method"><f a=""><e path="Void"/></f></identity>
		<deltaTransformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></deltaTransformPoint>
		<createGradientBox public="1" set="method"><f a="width:height:?rotation:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createGradientBox>
		<createBox public="1" set="method"><f a="scaleX:scaleY:?rotation:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createBox>
		<copyRowTo public="1">
			<f a="row:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowTo>
		<copyRowFrom public="1">
			<f a="row:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowFrom>
		<copyFrom public="1">
			<f a="sourceMatrix">
				<c path="flash.geom.Matrix"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<copyColumnTo public="1">
			<f a="column:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnTo>
		<copyColumnFrom public="1">
			<f a="column:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnFrom>
		<concat public="1" set="method"><f a="m">
	<c path="flash.geom.Matrix"/>
	<e path="Void"/>
</f></concat>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix"/></f></clone>
		<ty public="1"><c path="Float"/></ty>
		<tx public="1"><c path="Float"/></tx>
		<d public="1"><c path="Float"/></d>
		<c public="1"><c path="Float"/></c>
		<b public="1"><c path="Float"/></b>
		<a public="1"><c path="Float"/></a>
		<new public="1" set="method"><f a="?a:?b:?c:?d:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Matrix3D" params="" file="/usr/lib/haxe/std/flash/geom/Matrix3D.hx" extern="1">
		<interpolate public="1" set="method" static="1"><f a="thisMat:toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<c path="flash.geom.Matrix3D"/>
	<c path="Float"/>
	<c path="flash.geom.Matrix3D"/>
</f></interpolate>
		<transpose public="1" set="method"><f a=""><e path="Void"/></f></transpose>
		<transformVectors public="1" set="method"><f a="vin:vout">
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="flash.Vector"><c path="Float"/></c>
	<e path="Void"/>
</f></transformVectors>
		<transformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></transformVector>
		<recompose public="1" set="method"><f a="components:?orientationStyle">
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
	<e path="flash.geom.Orientation3D"/>
	<e path="Bool"/>
</f></recompose>
		<prependTranslation public="1" set="method"><f a="x:y:z">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></prependTranslation>
		<prependScale public="1" set="method"><f a="xScale:yScale:zScale">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></prependScale>
		<prependRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<c path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></prependRotation>
		<prepend public="1" set="method"><f a="rhs">
	<c path="flash.geom.Matrix3D"/>
	<e path="Void"/>
</f></prepend>
		<pointAt public="1" set="method"><f a="pos:?at:?up">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></pointAt>
		<invert public="1" set="method"><f a=""><e path="Bool"/></f></invert>
		<interpolateTo public="1" set="method"><f a="toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<c path="Float"/>
	<e path="Void"/>
</f></interpolateTo>
		<identity public="1" set="method"><f a=""><e path="Void"/></f></identity>
		<deltaTransformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></deltaTransformVector>
		<decompose public="1" set="method"><f a="?orientationStyle">
	<e path="flash.geom.Orientation3D"/>
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
</f></decompose>
		<copyToMatrix3D public="1">
			<f a="dest">
				<c path="flash.geom.Matrix3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyToMatrix3D>
		<copyRowTo public="1">
			<f a="row:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowTo>
		<copyRowFrom public="1">
			<f a="row:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowFrom>
		<copyRawDataTo public="1">
			<f a="vector:?index:?transpose">
				<c path="flash.Vector"><c path="Float"/></c>
				<t path="UInt"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRawDataTo>
		<copyRawDataFrom public="1">
			<f a="vector:?index:?transpose">
				<c path="flash.Vector"><c path="Float"/></c>
				<t path="UInt"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRawDataFrom>
		<copyFrom public="1">
			<f a="sourceMatrix3D">
				<c path="flash.geom.Matrix3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<copyColumnTo public="1">
			<f a="column:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnTo>
		<copyColumnFrom public="1">
			<f a="column:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnFrom>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></clone>
		<appendTranslation public="1" set="method"><f a="x:y:z">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></appendTranslation>
		<appendScale public="1" set="method"><f a="xScale:yScale:zScale">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></appendScale>
		<appendRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<c path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></appendRotation>
		<append public="1" set="method"><f a="lhs">
	<c path="flash.geom.Matrix3D"/>
	<e path="Void"/>
</f></append>
		<rawData public="1"><c path="flash.Vector"><c path="Float"/></c></rawData>
		<position public="1"><c path="flash.geom.Vector3D"/></position>
		<determinant public="1" set="null"><c path="Float"/></determinant>
		<new public="1" set="method"><f a="?v">
	<c path="flash.Vector"><c path="Float"/></c>
	<e path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<enum path="flash.geom.Orientation3D" params="" file="/usr/lib/haxe/std/flash/geom/Orientation3D.hx">
		<QUATERNION/>
		<EULER_ANGLES/>
		<AXIS_ANGLE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.geom.PerspectiveProjection" params="" file="/usr/lib/haxe/std/flash/geom/PerspectiveProjection.hx" extern="1">
		<toMatrix3D public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></toMatrix3D>
		<projectionCenter public="1"><c path="flash.geom.Point"/></projectionCenter>
		<focalLength public="1"><c path="Float"/></focalLength>
		<fieldOfView public="1"><c path="Float"/></fieldOfView>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.geom.Point" params="" file="/usr/lib/haxe/std/flash/geom/Point.hx" extern="1">
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="Float"/>
</f></distance>
		<interpolate public="1" set="method" static="1"><f a="pt1:pt2:f">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="Float"/>
	<c path="flash.geom.Point"/>
</f></interpolate>
		<polar public="1" set="method" static="1"><f a="len:angle">
	<c path="Float"/>
	<c path="Float"/>
	<c path="flash.geom.Point"/>
</f></polar>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<subtract public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></subtract>
		<setTo public="1">
			<f a="xa:ya">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<offset public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></offset>
		<normalize public="1" set="method"><f a="thickness">
	<c path="Float"/>
	<e path="Void"/>
</f></normalize>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></equals>
		<copyFrom public="1">
			<f a="sourcePoint">
				<c path="flash.geom.Point"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Point"/></f></clone>
		<add public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></add>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<length public="1" set="null"><c path="Float"/></length>
		<new public="1" set="method"><f a="?x:?y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Rectangle" params="" file="/usr/lib/haxe/std/flash/geom/Rectangle.hx" extern="1">
		<union public="1" set="method"><f a="toUnion">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></union>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<setTo public="1">
			<f a="xa:ya:widtha:heighta">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<setEmpty public="1" set="method"><f a=""><e path="Void"/></f></setEmpty>
		<offsetPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></offsetPoint>
		<offset public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></offset>
		<isEmpty public="1" set="method"><f a=""><e path="Bool"/></f></isEmpty>
		<intersects public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></intersects>
		<intersection public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></intersection>
		<inflatePoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></inflatePoint>
		<inflate public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></inflate>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></equals>
		<copyFrom public="1">
			<f a="sourceRect">
				<c path="flash.geom.Rectangle"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<containsRect public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></containsRect>
		<containsPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></containsPoint>
		<contains public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
</f></contains>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Rectangle"/></f></clone>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<width public="1"><c path="Float"/></width>
		<topLeft public="1"><c path="flash.geom.Point"/></topLeft>
		<top public="1"><c path="Float"/></top>
		<size public="1"><c path="flash.geom.Point"/></size>
		<right public="1"><c path="Float"/></right>
		<left public="1"><c path="Float"/></left>
		<height public="1"><c path="Float"/></height>
		<bottomRight public="1"><c path="flash.geom.Point"/></bottomRight>
		<bottom public="1"><c path="Float"/></bottom>
		<new public="1" set="method"><f a="?x:?y:?width:?height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Transform" params="" file="/usr/lib/haxe/std/flash/geom/Transform.hx" extern="1">
		<getRelativeMatrix3D public="1" set="method">
			<f a="relativeTo">
				<c path="flash.display.DisplayObject"/>
				<c path="flash.geom.Matrix3D"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</getRelativeMatrix3D>
		<pixelBounds public="1" set="null"><c path="flash.geom.Rectangle"/></pixelBounds>
		<perspectiveProjection public="1">
			<c path="flash.geom.PerspectiveProjection"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</perspectiveProjection>
		<matrix3D public="1">
			<c path="flash.geom.Matrix3D"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</matrix3D>
		<matrix public="1"><c path="flash.geom.Matrix"/></matrix>
		<concatenatedMatrix public="1" set="null"><c path="flash.geom.Matrix"/></concatenatedMatrix>
		<concatenatedColorTransform public="1" set="null"><c path="flash.geom.ColorTransform"/></concatenatedColorTransform>
		<colorTransform public="1"><c path="flash.geom.ColorTransform"/></colorTransform>
		<new public="1" set="method"><f a="displayObject">
	<c path="flash.display.DisplayObject"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Vector3D" params="" file="/usr/lib/haxe/std/flash/geom/Vector3D.hx" extern="1">
		<X_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></X_AXIS>
		<Y_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></Y_AXIS>
		<Z_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></Z_AXIS>
		<angleBetween public="1" set="method" static="1"><f a="a:b">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></angleBetween>
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></distance>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<subtract public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></subtract>
		<setTo public="1">
			<f a="xa:ya:za">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<scaleBy public="1" set="method"><f a="s">
	<c path="Float"/>
	<e path="Void"/>
</f></scaleBy>
		<project public="1" set="method"><f a=""><e path="Void"/></f></project>
		<normalize public="1" set="method"><f a=""><c path="Float"/></f></normalize>
		<negate public="1" set="method"><f a=""><e path="Void"/></f></negate>
		<nearEquals public="1" set="method"><f a="toCompare:tolerance:?allFour">
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></nearEquals>
		<incrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></incrementBy>
		<equals public="1" set="method"><f a="toCompare:?allFour">
	<c path="flash.geom.Vector3D"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></equals>
		<dotProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></dotProduct>
		<decrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></decrementBy>
		<crossProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></crossProduct>
		<copyFrom public="1">
			<f a="sourceVector3D">
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Vector3D"/></f></clone>
		<add public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></add>
		<z public="1"><c path="Float"/></z>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<w public="1"><c path="Float"/></w>
		<lengthSquared public="1" set="null"><c path="Float"/></lengthSquared>
		<length public="1" set="null"><c path="Float"/></length>
		<new public="1" set="method"><f a="?x:?y:?z:?w">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.media.Camera" params="" file="/usr/lib/haxe/std/flash/media/Camera.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" set="null" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<_scanHardware public="1" set="method" static="1">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</_scanHardware>
		<getCamera public="1" set="method" static="1"><f a="?name">
	<c path="String"/>
	<c path="flash.media.Camera"/>
</f></getCamera>
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setQuality>
		<setMotionLevel public="1" set="method"><f a="motionLevel:?timeout">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setMotionLevel>
		<setMode public="1" set="method"><f a="width:height:fps:?favorArea">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setMode>
		<setLoopback public="1" set="method"><f a="?compress">
	<e path="Bool"/>
	<e path="Void"/>
</f></setLoopback>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<c path="Int"/>
	<e path="Void"/>
</f></setKeyFrameInterval>
		<setCursor public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setCursor>
		<width public="1" set="null"><c path="Int"/></width>
		<quality public="1" set="null"><c path="Int"/></quality>
		<position public="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</position>
		<name public="1" set="null"><c path="String"/></name>
		<muted public="1" set="null"><e path="Bool"/></muted>
		<motionTimeout public="1" set="null"><c path="Int"/></motionTimeout>
		<motionLevel public="1" set="null"><c path="Int"/></motionLevel>
		<loopback public="1" set="null"><e path="Bool"/></loopback>
		<keyFrameInterval public="1" set="null"><c path="Int"/></keyFrameInterval>
		<index public="1" set="null"><c path="Int"/></index>
		<height public="1" set="null"><c path="Int"/></height>
		<fps public="1" set="null"><c path="Float"/></fps>
		<currentFPS public="1" set="null"><c path="Float"/></currentFPS>
		<bandwidth public="1" set="null"><c path="Int"/></bandwidth>
		<activityLevel public="1" set="null"><c path="Float"/></activityLevel>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.media.ID3Info" params="" file="/usr/lib/haxe/std/flash/media/ID3Info.hx" extern="1">
		<year public="1"><c path="String"/></year>
		<track public="1"><c path="String"/></track>
		<songName public="1"><c path="String"/></songName>
		<genre public="1"><c path="String"/></genre>
		<comment public="1"><c path="String"/></comment>
		<artist public="1"><c path="String"/></artist>
		<album public="1"><c path="String"/></album>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.media.Microphone" params="" file="/usr/lib/haxe/std/flash/media/Microphone.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" set="null" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<getEnhancedMicrophone public="1" static="1">
			<f a="?index">
				<c path="Int"/>
				<c path="flash.media.Microphone"/>
			</f>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</getEnhancedMicrophone>
		<getMicrophone public="1" set="method" static="1"><f a="?index">
	<c path="Int"/>
	<c path="flash.media.Microphone"/>
</f></getMicrophone>
		<setUseEchoSuppression public="1" set="method"><f a="useEchoSuppression">
	<e path="Bool"/>
	<e path="Void"/>
</f></setUseEchoSuppression>
		<setSilenceLevel public="1" set="method"><f a="silenceLevel:?timeout">
	<c path="Float"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setSilenceLevel>
		<setLoopBack public="1" set="method"><f a="?state">
	<e path="Bool"/>
	<e path="Void"/>
</f></setLoopBack>
		<useEchoSuppression public="1" set="null"><e path="Bool"/></useEchoSuppression>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<silenceTimeout public="1" set="null"><c path="Int"/></silenceTimeout>
		<silenceLevel public="1" set="null"><c path="Float"/></silenceLevel>
		<rate public="1"><c path="Int"/></rate>
		<noiseSuppressionLevel public="1">
			<c path="Int"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</noiseSuppressionLevel>
		<name public="1" set="null"><c path="String"/></name>
		<muted public="1" set="null"><e path="Bool"/></muted>
		<index public="1" set="null"><c path="Int"/></index>
		<gain public="1"><c path="Float"/></gain>
		<framesPerPacket public="1">
			<c path="Int"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</framesPerPacket>
		<enhancedOptions public="1">
			<c path="flash.media.MicrophoneEnhancedOptions"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</enhancedOptions>
		<encodeQuality public="1">
			<c path="Int"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</encodeQuality>
		<enableVAD public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</enableVAD>
		<codec public="1">
			<e path="flash.media.SoundCodec"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</codec>
		<activityLevel public="1" set="null"><c path="Float"/></activityLevel>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.media.MicrophoneEnhancedMode" params="" file="/usr/lib/haxe/std/flash/media/MicrophoneEnhancedMode.hx">
		<SPEAKER_MUTE/>
		<OFF/>
		<HEADSET/>
		<HALF_DUPLEX/>
		<FULL_DUPLEX/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</enum>
	<class path="flash.media.MicrophoneEnhancedOptions" params="" file="/usr/lib/haxe/std/flash/media/MicrophoneEnhancedOptions.hx" extern="1">
		<nonLinearProcessing public="1"><e path="Bool"/></nonLinearProcessing>
		<mode public="1"><e path="flash.media.MicrophoneEnhancedMode"/></mode>
		<isVoiceDetected public="1"><c path="Int"/></isVoiceDetected>
		<echoPath public="1"><c path="Int"/></echoPath>
		<autoGain public="1"><e path="Bool"/></autoGain>
		<new public="1"><f a=""><e path="Void"/></f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</class>
	<class path="flash.media.SoundChannel" params="" file="/usr/lib/haxe/std/flash/media/SoundChannel.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<stop public="1" set="method"><f a=""><e path="Void"/></f></stop>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<rightPeak public="1" set="null"><c path="Float"/></rightPeak>
		<position public="1" set="null"><c path="Float"/></position>
		<leftPeak public="1" set="null"><c path="Float"/></leftPeak>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.media.SoundCodec" params="" file="/usr/lib/haxe/std/flash/media/SoundCodec.hx">
		<SPEEX/>
		<PCMU/>
		<PCMA/>
		<NELLYMOSER/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.media.SoundLoaderContext" params="" file="/usr/lib/haxe/std/flash/media/SoundLoaderContext.hx" extern="1">
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<bufferTime public="1"><c path="Float"/></bufferTime>
		<new public="1" set="method"><f a="?bufferTime:?checkPolicyFile">
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.media.SoundTransform" params="" file="/usr/lib/haxe/std/flash/media/SoundTransform.hx" extern="1">
		<volume public="1"><c path="Float"/></volume>
		<rightToRight public="1"><c path="Float"/></rightToRight>
		<rightToLeft public="1"><c path="Float"/></rightToLeft>
		<pan public="1"><c path="Float"/></pan>
		<leftToRight public="1"><c path="Float"/></leftToRight>
		<leftToLeft public="1"><c path="Float"/></leftToLeft>
		<new public="1" set="method"><f a="?vol:?panning">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.media.StageVideo" params="" file="/usr/lib/haxe/std/flash/media/StageVideo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<attachNetStream public="1" set="method"><f a="netStream">
	<c path="flash.net.NetStream"/>
	<e path="Void"/>
</f></attachNetStream>
		<zoom public="1"><c path="flash.geom.Point"/></zoom>
		<viewPort public="1"><c path="flash.geom.Rectangle"/></viewPort>
		<videoWidth public="1" set="null"><c path="Int"/></videoWidth>
		<videoHeight public="1" set="null"><c path="Int"/></videoHeight>
		<pan public="1"><c path="flash.geom.Point"/></pan>
		<depth public="1"><c path="Int"/></depth>
		<colorSpaces public="1" set="null"><c path="flash.Vector"><c path="String"/></c></colorSpaces>
		<new public="1"><f a=""><e path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_2</e></m></meta>
	</class>
	<class path="flash.media.VideoStreamSettings" params="" file="/usr/lib/haxe/std/flash/media/VideoStreamSettings.hx" extern="1">
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setQuality>
		<setMode public="1" set="method"><f a="width:height:fps">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setMode>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<c path="Int"/>
	<e path="Void"/>
</f></setKeyFrameInterval>
		<width public="1" set="null"><c path="Int"/></width>
		<quality public="1" set="null"><c path="Int"/></quality>
		<keyFrameInterval public="1" set="null"><c path="Int"/></keyFrameInterval>
		<height public="1" set="null"><c path="Int"/></height>
		<fps public="1" set="null"><c path="Float"/></fps>
		<codec public="1" set="null"><c path="String"/></codec>
		<bandwidth public="1" set="null"><c path="Int"/></bandwidth>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.net.FileFilter" params="" file="/usr/lib/haxe/std/flash/net/FileFilter.hx" extern="1">
		<macType public="1"><c path="String"/></macType>
		<extension public="1"><c path="String"/></extension>
		<description public="1"><c path="String"/></description>
		<new public="1" set="method"><f a="description:extension:?macType">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.FileReference" params="" file="/usr/lib/haxe/std/flash/net/FileReference.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<upload public="1" set="method"><f a="request:?uploadDataFieldName:?testUpload">
	<c path="flash.net.URLRequest"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></upload>
		<save public="1" set="method">
			<f a="data:?defaultFileName">
				<d/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</save>
		<load public="1" set="method">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</load>
		<download public="1" set="method"><f a="request:?defaultFileName">
	<c path="flash.net.URLRequest"/>
	<c path="String"/>
	<e path="Void"/>
</f></download>
		<cancel public="1" set="method"><f a=""><e path="Void"/></f></cancel>
		<browse public="1" set="method"><f a="?typeFilter">
	<c path="Array"><c path="flash.net.FileFilter"/></c>
	<e path="Bool"/>
</f></browse>
		<type public="1" set="null"><c path="String"/></type>
		<size public="1" set="null"><c path="Float"/></size>
		<name public="1" set="null"><c path="String"/></name>
		<modificationDate public="1" set="null"><c path="Date"/></modificationDate>
		<data public="1" set="null">
			<c path="flash.utils.ByteArray"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</data>
		<creator public="1" set="null"><c path="String"/></creator>
		<creationDate public="1" set="null"><c path="Date"/></creationDate>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.net.NetConnection" params="" file="/usr/lib/haxe/std/flash/net/NetConnection.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<defaultObjectEncoding public="1" static="1"><t path="UInt"/></defaultObjectEncoding>
		<connect public="1" set="method"><f a="command:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></connect>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<call public="1" set="method"><f a="command:responder:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<c path="flash.net.Responder"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></call>
		<addHeader public="1" set="method"><f a="operation:?mustUnderstand:?param">
	<c path="String"/>
	<e path="Bool"/>
	<d/>
	<e path="Void"/>
</f></addHeader>
		<usingTLS public="1" set="null"><e path="Bool"/></usingTLS>
		<uri public="1" set="null"><c path="String"/></uri>
		<unconnectedPeerStreams public="1" set="null">
			<c path="Array"><d/></c>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</unconnectedPeerStreams>
		<proxyType public="1"><c path="String"/></proxyType>
		<protocol public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</protocol>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<nearNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearNonce>
		<nearID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearID>
		<maxPeerConnections public="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</maxPeerConnections>
		<farNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farNonce>
		<farID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farID>
		<connectedProxyType public="1" set="null"><c path="String"/></connectedProxyType>
		<connected public="1" set="null"><e path="Bool"/></connected>
		<client public="1"><d/></client>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.net.NetStream" params="" file="/usr/lib/haxe/std/flash/net/NetStream.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<CONNECT_TO_FMS public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CONNECT_TO_FMS>
		<DIRECT_CONNECTIONS public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</DIRECT_CONNECTIONS>
		<togglePause public="1" set="method"><f a=""><e path="Void"/></f></togglePause>
		<step public="1" set="method">
			<f a="frames">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</step>
		<send public="1" set="method"><f a="handlerName:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></send>
		<seek public="1" set="method"><f a="offset">
	<c path="Float"/>
	<e path="Void"/>
</f></seek>
		<resume public="1" set="method"><f a=""><e path="Void"/></f></resume>
		<receiveVideoFPS public="1" set="method"><f a="FPS">
	<c path="Float"/>
	<e path="Void"/>
</f></receiveVideoFPS>
		<receiveVideo public="1" set="method"><f a="flag">
	<e path="Bool"/>
	<e path="Void"/>
</f></receiveVideo>
		<receiveAudio public="1" set="method"><f a="flag">
	<e path="Bool"/>
	<e path="Void"/>
</f></receiveAudio>
		<publish public="1" set="method"><f a="?name:?type">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></publish>
		<play2 public="1" set="method">
			<f a="param">
				<c path="flash.net.NetStreamPlayOptions"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</play2>
		<play public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></play>
		<pause public="1" set="method"><f a=""><e path="Void"/></f></pause>
		<onPeerConnect public="1" set="method">
			<f a="subscriber">
				<c path="flash.net.NetStream"/>
				<e path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</onPeerConnect>
		<dispose public="1">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</dispose>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<attachCamera public="1" set="method"><f a="theCamera:?snapshotMilliseconds">
	<c path="flash.media.Camera"/>
	<c path="Int"/>
	<e path="Void"/>
</f></attachCamera>
		<attachAudio public="1" set="method"><f a="microphone">
	<c path="flash.media.Microphone"/>
	<e path="Void"/>
</f></attachAudio>
		<attach public="1" set="method">
			<f a="connection">
				<c path="flash.net.NetConnection"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</attach>
		<appendBytesAction public="1" set="method">
			<f a="netStreamAppendBytesAction">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</appendBytesAction>
		<appendBytes public="1" set="method">
			<f a="bytes">
				<c path="flash.utils.ByteArray"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</appendBytes>
		<videoStreamSettings public="1">
			<c path="flash.media.VideoStreamSettings"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</videoStreamSettings>
		<videoSampleAccess public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoSampleAccess>
		<videoReliable public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoReliable>
		<videoCodec public="1" set="null"><t path="UInt"/></videoCodec>
		<useJitterBuffer public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</useJitterBuffer>
		<useHardwareDecoder public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</useHardwareDecoder>
		<time public="1" set="null"><c path="Float"/></time>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<peerStreams public="1" set="null">
			<c path="Array"><d/></c>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</peerStreams>
		<objectEncoding public="1" set="null"><t path="UInt"/></objectEncoding>
		<nearNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearNonce>
		<multicastWindowDuration public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastWindowDuration>
		<multicastRelayMarginDuration public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastRelayMarginDuration>
		<multicastPushNeighborLimit public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastPushNeighborLimit>
		<multicastInfo public="1" set="null">
			<c path="flash.net.NetStreamMulticastInfo"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastInfo>
		<multicastFetchPeriod public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastFetchPeriod>
		<multicastAvailabilityUpdatePeriod public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastAvailabilityUpdatePeriod>
		<multicastAvailabilitySendToAll public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastAvailabilitySendToAll>
		<maxPauseBufferTime public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</maxPauseBufferTime>
		<liveDelay public="1" set="null"><c path="Float"/></liveDelay>
		<info public="1" set="null">
			<c path="flash.net.NetStreamInfo"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</info>
		<inBufferSeek public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</inBufferSeek>
		<farNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farNonce>
		<farID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farID>
		<decodedFrames public="1" set="null"><t path="UInt"/></decodedFrames>
		<dataReliable public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</dataReliable>
		<currentFPS public="1" set="null"><c path="Float"/></currentFPS>
		<client public="1"><d/></client>
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<bytesTotal public="1" set="null"><t path="UInt"/></bytesTotal>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<bufferTimeMax public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</bufferTimeMax>
		<bufferTime public="1"><c path="Float"/></bufferTime>
		<bufferLength public="1" set="null"><c path="Float"/></bufferLength>
		<backBufferTime public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</backBufferTime>
		<backBufferLength public="1" set="null">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</backBufferLength>
		<audioSampleAccess public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</audioSampleAccess>
		<audioReliable public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</audioReliable>
		<audioCodec public="1" set="null"><t path="UInt"/></audioCodec>
		<new public="1" set="method"><f a="connection:?peerID">
	<c path="flash.net.NetConnection"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.net.NetStreamInfo" params="" file="/usr/lib/haxe/std/flash/net/NetStreamInfo.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<xmpData public="1" set="null"><d/></xmpData>
		<videoLossRate public="1" set="null">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoLossRate>
		<videoBytesPerSecond public="1" set="null"><c path="Float"/></videoBytesPerSecond>
		<videoByteCount public="1" set="null"><c path="Float"/></videoByteCount>
		<videoBufferLength public="1" set="null"><c path="Float"/></videoBufferLength>
		<videoBufferByteLength public="1" set="null"><c path="Float"/></videoBufferByteLength>
		<uri public="1" set="null"><c path="String"/></uri>
		<resourceName public="1" set="null"><c path="String"/></resourceName>
		<playbackBytesPerSecond public="1" set="null"><c path="Float"/></playbackBytesPerSecond>
		<metaData public="1" set="null"><d/></metaData>
		<maxBytesPerSecond public="1" set="null"><c path="Float"/></maxBytesPerSecond>
		<isLive public="1" set="null"><e path="Bool"/></isLive>
		<droppedFrames public="1" set="null"><c path="Float"/></droppedFrames>
		<dataBytesPerSecond public="1" set="null"><c path="Float"/></dataBytesPerSecond>
		<dataByteCount public="1" set="null"><c path="Float"/></dataByteCount>
		<dataBufferLength public="1" set="null"><c path="Float"/></dataBufferLength>
		<dataBufferByteLength public="1" set="null"><c path="Float"/></dataBufferByteLength>
		<currentBytesPerSecond public="1" set="null"><c path="Float"/></currentBytesPerSecond>
		<byteCount public="1" set="null"><c path="Float"/></byteCount>
		<audioLossRate public="1" set="null"><c path="Float"/></audioLossRate>
		<audioBytesPerSecond public="1" set="null"><c path="Float"/></audioBytesPerSecond>
		<audioByteCount public="1" set="null"><c path="Float"/></audioByteCount>
		<audioBufferLength public="1" set="null"><c path="Float"/></audioBufferLength>
		<audioBufferByteLength public="1" set="null"><c path="Float"/></audioBufferByteLength>
		<SRTT public="1" set="null"><c path="Float"/></SRTT>
		<new public="1" set="method"><f a="curBPS:byteCount:maxBPS:audioBPS:audioByteCount:videoBPS:videoByteCount:dataBPS:dataByteCount:playbackBPS:droppedFrames:audioBufferByteLength:videoBufferByteLength:dataBufferByteLength:audioBufferLength:videoBufferLength:dataBufferLength:srtt:audioLossRate:videoLossRate:?metaData:?xmpData:?uri:?resourceName:?isLive">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<d/>
	<d/>
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.NetStreamMulticastInfo" params="" file="/usr/lib/haxe/std/flash/net/NetStreamMulticastInfo.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<sendDataBytesPerSecond public="1" set="null"><c path="Float"/></sendDataBytesPerSecond>
		<sendControlBytesPerSecondToServer public="1" set="null"><c path="Float"/></sendControlBytesPerSecondToServer>
		<sendControlBytesPerSecond public="1" set="null"><c path="Float"/></sendControlBytesPerSecond>
		<receiveDataBytesPerSecondFromServer public="1" set="null"><c path="Float"/></receiveDataBytesPerSecondFromServer>
		<receiveDataBytesPerSecondFromIPMulticast public="1" set="null"><c path="Float"/></receiveDataBytesPerSecondFromIPMulticast>
		<receiveDataBytesPerSecond public="1" set="null"><c path="Float"/></receiveDataBytesPerSecond>
		<receiveControlBytesPerSecond public="1" set="null"><c path="Float"/></receiveControlBytesPerSecond>
		<fragmentsRequestedFromPeers public="1" set="null"><c path="Float"/></fragmentsRequestedFromPeers>
		<fragmentsRequestedByPeers public="1" set="null"><c path="Float"/></fragmentsRequestedByPeers>
		<fragmentsReceivedFromServer public="1" set="null"><c path="Float"/></fragmentsReceivedFromServer>
		<fragmentsReceivedFromIPMulticast public="1" set="null"><c path="Float"/></fragmentsReceivedFromIPMulticast>
		<fragmentsPushedToPeers public="1" set="null"><c path="Float"/></fragmentsPushedToPeers>
		<fragmentsPushedFromPeers public="1" set="null"><c path="Float"/></fragmentsPushedFromPeers>
		<bytesRequestedFromPeers public="1" set="null"><c path="Float"/></bytesRequestedFromPeers>
		<bytesRequestedByPeers public="1" set="null"><c path="Float"/></bytesRequestedByPeers>
		<bytesReceivedFromServer public="1" set="null"><c path="Float"/></bytesReceivedFromServer>
		<bytesReceivedFromIPMulticast public="1" set="null"><c path="Float"/></bytesReceivedFromIPMulticast>
		<bytesPushedToPeers public="1" set="null"><c path="Float"/></bytesPushedToPeers>
		<bytesPushedFromPeers public="1" set="null"><c path="Float"/></bytesPushedFromPeers>
		<new public="1" set="method"><f a="sendDataBytesPerSecond:sendControlBytesPerSecond:receiveDataBytesPerSecond:receiveControlBytesPerSecond:bytesPushedToPeers:fragmentsPushedToPeers:bytesRequestedByPeers:fragmentsRequestedByPeers:bytesPushedFromPeers:fragmentsPushedFromPeers:bytesRequestedFromPeers:fragmentsRequestedFromPeers:sendControlBytesPerSecondToServer:receiveDataBytesPerSecondFromServer:bytesReceivedFromServer:fragmentsReceivedFromServer:receiveDataBytesPerSecondFromIPMulticast:bytesReceivedFromIPMulticast:fragmentsReceivedFromIPMulticast">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</class>
	<class path="flash.net.NetStreamPlayOptions" params="" file="/usr/lib/haxe/std/flash/net/NetStreamPlayOptions.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<transition public="1"><c path="String"/></transition>
		<streamName public="1"><c path="String"/></streamName>
		<start public="1"><c path="Float"/></start>
		<oldStreamName public="1"><c path="String"/></oldStreamName>
		<offset public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</offset>
		<len public="1"><c path="Float"/></len>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.net.Responder" params="" file="/usr/lib/haxe/std/flash/net/Responder.hx" extern="1"><new public="1" set="method"><f a="result:?status">
	<d/>
	<d/>
	<e path="Void"/>
</f></new></class>
	<class path="flash.net.SharedObject" params="" file="/usr/lib/haxe/std/flash/net/SharedObject.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<defaultObjectEncoding public="1" static="1"><t path="UInt"/></defaultObjectEncoding>
		<deleteAll public="1" set="method" static="1"><f a="url">
	<c path="String"/>
	<c path="Int"/>
</f></deleteAll>
		<getDiskUsage public="1" set="method" static="1"><f a="url">
	<c path="String"/>
	<c path="Int"/>
</f></getDiskUsage>
		<getLocal public="1" set="method" static="1"><f a="name:?localPath:?secure">
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
	<c path="flash.net.SharedObject"/>
</f></getLocal>
		<getRemote public="1" set="method" static="1"><f a="name:?remotePath:?persistence:?secure">
	<c path="String"/>
	<c path="String"/>
	<d/>
	<e path="Bool"/>
	<c path="flash.net.SharedObject"/>
</f></getRemote>
		<setProperty public="1" set="method"><f a="propertyName:?value">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></setProperty>
		<setDirty public="1" set="method"><f a="propertyName">
	<c path="String"/>
	<e path="Void"/>
</f></setDirty>
		<send public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></send>
		<flush public="1" set="method"><f a="?minDiskSpace">
	<c path="Int"/>
	<c path="String"/>
</f></flush>
		<connect public="1" set="method"><f a="myConnection:?params">
	<c path="flash.net.NetConnection"/>
	<c path="String"/>
	<e path="Void"/>
</f></connect>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<size public="1" set="null"><t path="UInt"/></size>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<fps public="1" get="null"><c path="Float"/></fps>
		<data public="1" set="null"><d/></data>
		<client public="1"><d/></client>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.net.SharedObjectFlushStatus" params="" file="/usr/lib/haxe/std/flash/net/SharedObjectFlushStatus.hx" extern="1">
		<FLUSHED public="1" static="1"><c path="String"/></FLUSHED>
		<PENDING public="1" static="1"><c path="String"/></PENDING>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.net.URLRequest" params="" file="/usr/lib/haxe/std/flash/net/URLRequest.hx" extern="1">
		<url public="1"><c path="String"/></url>
		<requestHeaders public="1"><c path="Array"><c path="flash.net.URLRequestHeader"/></c></requestHeaders>
		<method public="1"><c path="String"/></method>
		<digest public="1"><c path="String"/></digest>
		<data public="1"><d/></data>
		<contentType public="1"><c path="String"/></contentType>
		<new public="1" set="method"><f a="?url">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.URLRequestHeader" params="" file="/usr/lib/haxe/std/flash/net/URLRequestHeader.hx" extern="1">
		<value public="1"><c path="String"/></value>
		<name public="1"><c path="String"/></name>
		<new public="1" set="method"><f a="?name:?value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.system.ApplicationDomain" params="" file="/usr/lib/haxe/std/flash/system/ApplicationDomain.hx" extern="1">
		<MIN_DOMAIN_MEMORY_LENGTH public="1" set="null" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</MIN_DOMAIN_MEMORY_LENGTH>
		<currentDomain public="1" set="null" static="1"><c path="flash.system.ApplicationDomain"/></currentDomain>
		<hasDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></hasDefinition>
		<getQualifiedDefinitionNames public="1">
			<f a=""><c path="flash.Vector"><c path="String"/></c></f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</getQualifiedDefinitionNames>
		<getDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<d/>
</f></getDefinition>
		<parentDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></parentDomain>
		<domainMemory public="1">
			<c path="flash.utils.ByteArray"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</domainMemory>
		<new public="1" set="method"><f a="?parentDomain">
	<c path="flash.system.ApplicationDomain"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.system.IME" params="" file="/usr/lib/haxe/std/flash/system/IME.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<conversionMode public="1" static="1"><e path="flash.system.IMEConversionMode"/></conversionMode>
		<enabled public="1" static="1"><e path="Bool"/></enabled>
		<isSupported public="1" set="null" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<compositionAbandoned public="1" set="method" static="1">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</compositionAbandoned>
		<compositionSelectionChanged public="1" set="method" static="1">
			<f a="start:end">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</compositionSelectionChanged>
		<doConversion public="1" set="method" static="1"><f a=""><e path="Void"/></f></doConversion>
		<setCompositionString public="1" set="method" static="1"><f a="composition">
	<c path="String"/>
	<e path="Void"/>
</f></setCompositionString>
	</class>
	<enum path="flash.system.IMEConversionMode" params="" file="/usr/lib/haxe/std/flash/system/IMEConversionMode.hx">
		<UNKNOWN/>
		<KOREAN/>
		<JAPANESE_KATAKANA_HALF/>
		<JAPANESE_KATAKANA_FULL/>
		<JAPANESE_HIRAGANA/>
		<CHINESE/>
		<ALPHANUMERIC_HALF/>
		<ALPHANUMERIC_FULL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.system.ImageDecodingPolicy" params="" file="/usr/lib/haxe/std/flash/system/ImageDecodingPolicy.hx">
		<ON_LOAD/>
		<ON_DEMAND/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.system.LoaderContext" params="" file="/usr/lib/haxe/std/flash/system/LoaderContext.hx" extern="1">
		<securityDomain public="1"><c path="flash.system.SecurityDomain"/></securityDomain>
		<requestedContentParent public="1">
			<c path="flash.display.DisplayObjectContainer"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</requestedContentParent>
		<parameters public="1">
			<d/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</parameters>
		<imageDecodingPolicy public="1">
			<e path="flash.system.ImageDecodingPolicy"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</imageDecodingPolicy>
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<applicationDomain public="1"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<allowLoadBytesCodeExecution public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</allowLoadBytesCodeExecution>
		<allowCodeImport public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</allowCodeImport>
		<new public="1" set="method"><f a="?checkPolicyFile:?applicationDomain:?securityDomain">
	<e path="Bool"/>
	<c path="flash.system.ApplicationDomain"/>
	<c path="flash.system.SecurityDomain"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.system.SecurityDomain" params="" file="/usr/lib/haxe/std/flash/system/SecurityDomain.hx" extern="1">
		<currentDomain public="1" set="null" static="1"><c path="flash.system.SecurityDomain"/></currentDomain>
		<domainID public="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</domainID>
	</class>
	<class path="flash.system.System" params="" file="/usr/lib/haxe/std/flash/system/System.hx" extern="1">
		<freeMemory public="1" set="null" static="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</freeMemory>
		<ime public="1" set="null" static="1"><c path="flash.system.IME"/></ime>
		<privateMemory public="1" set="null" static="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</privateMemory>
		<processCPUUsage public="1" static="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</processCPUUsage>
		<totalMemory public="1" set="null" static="1"><t path="UInt"/></totalMemory>
		<totalMemoryNumber public="1" set="null" static="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</totalMemoryNumber>
		<useCodePage public="1" static="1"><e path="Bool"/></useCodePage>
		<vmVersion public="1" set="null" static="1"><c path="String"/></vmVersion>
		<disposeXML public="1" set="method" static="1">
			<f a="node">
				<c path="flash.xml.XML"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</disposeXML>
		<exit public="1" set="method" static="1"><f a="code">
	<t path="UInt"/>
	<e path="Void"/>
</f></exit>
		<gc public="1" set="method" static="1"><f a=""><e path="Void"/></f></gc>
		<pause public="1" set="method" static="1"><f a=""><e path="Void"/></f></pause>
		<pauseForGCIfCollectionImminent public="1" static="1">
			<f a="?imminence">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</pauseForGCIfCollectionImminent>
		<resume public="1" set="method" static="1"><f a=""><e path="Void"/></f></resume>
		<setClipboard public="1" set="method" static="1"><f a="string">
	<c path="String"/>
	<e path="Void"/>
</f></setClipboard>
	</class>
	<enum path="flash.text.AntiAliasType" params="" file="/usr/lib/haxe/std/flash/text/AntiAliasType.hx">
		<NORMAL/>
		<ADVANCED/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.FontStyle" params="" file="/usr/lib/haxe/std/flash/text/FontStyle.hx">
		<REGULAR/>
		<ITALIC/>
		<BOLD_ITALIC/>
		<BOLD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.FontType" params="" file="/usr/lib/haxe/std/flash/text/FontType.hx">
		<EMBEDDED_CFF/>
		<EMBEDDED/>
		<DEVICE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.GridFitType" params="" file="/usr/lib/haxe/std/flash/text/GridFitType.hx">
		<SUBPIXEL/>
		<PIXEL/>
		<NONE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.StyleSheet" params="" file="/usr/lib/haxe/std/flash/text/StyleSheet.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<transform public="1" set="method"><f a="formatObject">
	<d/>
	<c path="flash.text.TextFormat"/>
</f></transform>
		<setStyle public="1" set="method"><f a="styleName:styleObject">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></setStyle>
		<parseCSS public="1" set="method"><f a="CSSText">
	<c path="String"/>
	<e path="Void"/>
</f></parseCSS>
		<getStyle public="1" set="method"><f a="styleName">
	<c path="String"/>
	<d/>
</f></getStyle>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<styleNames public="1" set="null"><c path="Array"><d/></c></styleNames>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.text.TextField" params="" file="/usr/lib/haxe/std/flash/text/TextField.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<isFontCompatible public="1" set="method" static="1">
			<f a="fontName:fontStyle">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</isFontCompatible>
		<setTextFormat public="1" set="method"><f a="format:?beginIndex:?endIndex">
	<c path="flash.text.TextFormat"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setTextFormat>
		<setSelection public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setSelection>
		<replaceText public="1" set="method"><f a="beginIndex:endIndex:newText">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
	<e path="Void"/>
</f></replaceText>
		<replaceSelectedText public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></replaceSelectedText>
		<pasteRichText public="1" set="method"><f a="richText">
	<c path="String"/>
	<e path="Bool"/>
</f></pasteRichText>
		<insertXMLText public="1" set="method"><f a="beginIndex:endIndex:richText:?pasting">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></insertXMLText>
		<getXMLText public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></getXMLText>
		<getTextRuns public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRuns>
		<getTextFormat public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.text.TextFormat"/>
</f></getTextFormat>
		<getRawText public="1" set="method"><f a=""><c path="String"/></f></getRawText>
		<getParagraphLength public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getParagraphLength>
		<getLineText public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="String"/>
</f></getLineText>
		<getLineOffset public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineOffset>
		<getLineMetrics public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="flash.text.TextLineMetrics"/>
</f></getLineMetrics>
		<getLineLength public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineLength>
		<getLineIndexOfChar public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineIndexOfChar>
		<getLineIndexAtPoint public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></getLineIndexAtPoint>
		<getImageReference public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getImageReference>
		<getFirstCharInParagraph public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getFirstCharInParagraph>
		<getCharIndexAtPoint public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></getCharIndexAtPoint>
		<getCharBoundaries public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="flash.geom.Rectangle"/>
</f></getCharBoundaries>
		<copyRichText public="1" set="method"><f a=""><c path="String"/></f></copyRichText>
		<appendText public="1" set="method"><f a="newText">
	<c path="String"/>
	<e path="Void"/>
</f></appendText>
		<wordWrap public="1"><e path="Bool"/></wordWrap>
		<useRichTextClipboard public="1"><e path="Bool"/></useRichTextClipboard>
		<type public="1"><e path="flash.text.TextFieldType"/></type>
		<thickness public="1"><c path="Float"/></thickness>
		<textWidth public="1" set="null"><c path="Float"/></textWidth>
		<textInteractionMode public="1">
			<e path="flash.text.TextInteractionMode"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</textInteractionMode>
		<textHeight public="1" set="null"><c path="Float"/></textHeight>
		<textColor public="1"><t path="UInt"/></textColor>
		<text public="1"><c path="String"/></text>
		<styleSheet public="1"><c path="flash.text.StyleSheet"/></styleSheet>
		<sharpness public="1"><c path="Float"/></sharpness>
		<selectionEndIndex public="1" set="null"><c path="Int"/></selectionEndIndex>
		<selectionBeginIndex public="1" set="null"><c path="Int"/></selectionBeginIndex>
		<selectedText public="1" set="null"><c path="String"/></selectedText>
		<selectable public="1"><e path="Bool"/></selectable>
		<scrollV public="1"><c path="Int"/></scrollV>
		<scrollH public="1"><c path="Int"/></scrollH>
		<restrict public="1"><c path="String"/></restrict>
		<numLines public="1" set="null"><c path="Int"/></numLines>
		<multiline public="1"><e path="Bool"/></multiline>
		<mouseWheelEnabled public="1"><e path="Bool"/></mouseWheelEnabled>
		<maxScrollV public="1" set="null"><c path="Int"/></maxScrollV>
		<maxScrollH public="1" set="null"><c path="Int"/></maxScrollH>
		<maxChars public="1"><c path="Int"/></maxChars>
		<length public="1" set="null"><c path="Int"/></length>
		<htmlText public="1"><c path="String"/></htmlText>
		<gridFitType public="1"><e path="flash.text.GridFitType"/></gridFitType>
		<embedFonts public="1"><e path="Bool"/></embedFonts>
		<displayAsPassword public="1"><e path="Bool"/></displayAsPassword>
		<defaultTextFormat public="1"><c path="flash.text.TextFormat"/></defaultTextFormat>
		<condenseWhite public="1"><e path="Bool"/></condenseWhite>
		<caretIndex public="1" set="null"><c path="Int"/></caretIndex>
		<bottomScrollV public="1" set="null"><c path="Int"/></bottomScrollV>
		<borderColor public="1"><t path="UInt"/></borderColor>
		<border public="1"><e path="Bool"/></border>
		<backgroundColor public="1"><t path="UInt"/></backgroundColor>
		<background public="1"><e path="Bool"/></background>
		<autoSize public="1"><e path="flash.text.TextFieldAutoSize"/></autoSize>
		<antiAliasType public="1"><e path="flash.text.AntiAliasType"/></antiAliasType>
		<alwaysShowSelection public="1"><e path="Bool"/></alwaysShowSelection>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.text.TextFieldAutoSize" params="" file="/usr/lib/haxe/std/flash/text/TextFieldAutoSize.hx">
		<RIGHT/>
		<NONE/>
		<LEFT/>
		<CENTER/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextFieldType" params="" file="/usr/lib/haxe/std/flash/text/TextFieldType.hx">
		<INPUT/>
		<DYNAMIC/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.TextFormat" params="" file="/usr/lib/haxe/std/flash/text/TextFormat.hx" extern="1">
		<url public="1"><c path="String"/></url>
		<underline public="1"><t path="Null"><e path="Bool"/></t></underline>
		<target public="1"><c path="String"/></target>
		<tabStops public="1"><c path="Array"><t path="UInt"/></c></tabStops>
		<size public="1"><t path="Null"><c path="Float"/></t></size>
		<rightMargin public="1"><t path="Null"><c path="Float"/></t></rightMargin>
		<letterSpacing public="1"><t path="Null"><c path="Float"/></t></letterSpacing>
		<leftMargin public="1"><t path="Null"><c path="Float"/></t></leftMargin>
		<leading public="1"><t path="Null"><c path="Float"/></t></leading>
		<kerning public="1"><t path="Null"><e path="Bool"/></t></kerning>
		<italic public="1"><t path="Null"><e path="Bool"/></t></italic>
		<indent public="1"><t path="Null"><c path="Float"/></t></indent>
		<font public="1"><c path="String"/></font>
		<display public="1"><e path="flash.text.TextFormatDisplay"/></display>
		<color public="1"><t path="Null"><t path="UInt"/></t></color>
		<bullet public="1"><t path="Null"><e path="Bool"/></t></bullet>
		<bold public="1"><t path="Null"><e path="Bool"/></t></bold>
		<blockIndent public="1"><t path="Null"><c path="Float"/></t></blockIndent>
		<align public="1"><e path="flash.text.TextFormatAlign"/></align>
		<new public="1" set="method"><f a="?font:?size:?color:?bold:?italic:?underline:?url:?target:?align:?leftMargin:?rightMargin:?indent:?leading">
	<c path="String"/>
	<c path="Float"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<c path="String"/>
	<e path="flash.text.TextFormatAlign"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.text.TextFormatAlign" params="" file="/usr/lib/haxe/std/flash/text/TextFormatAlign.hx">
		<START/>
		<RIGHT/>
		<LEFT/>
		<JUSTIFY/>
		<END/>
		<CENTER/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextFormatDisplay" params="" file="/usr/lib/haxe/std/flash/text/TextFormatDisplay.hx">
		<INLINE/>
		<BLOCK/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextInteractionMode" params="" file="/usr/lib/haxe/std/flash/text/TextInteractionMode.hx">
		<SELECTION/>
		<NORMAL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.TextLineMetrics" params="" file="/usr/lib/haxe/std/flash/text/TextLineMetrics.hx" extern="1">
		<x public="1"><c path="Float"/></x>
		<width public="1"><c path="Float"/></width>
		<leading public="1"><c path="Float"/></leading>
		<height public="1"><c path="Float"/></height>
		<descent public="1"><c path="Float"/></descent>
		<ascent public="1"><c path="Float"/></ascent>
		<new public="1" set="method"><f a="x:width:height:ascent:descent:leading">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.text.TextSnapshot" params="" file="/usr/lib/haxe/std/flash/text/TextSnapshot.hx" extern="1">
		<setSelected public="1" set="method"><f a="beginIndex:endIndex:select">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setSelected>
		<setSelectColor public="1" set="method"><f a="?hexColor">
	<t path="UInt"/>
	<e path="Void"/>
</f></setSelectColor>
		<hitTestTextNearPos public="1" set="method"><f a="x:y:?maxDistance">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></hitTestTextNearPos>
		<getTextRunInfo public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRunInfo>
		<getText public="1" set="method"><f a="beginIndex:endIndex:?includeLineEndings">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<c path="String"/>
</f></getText>
		<getSelectedText public="1" set="method"><f a="?includeLineEndings">
	<e path="Bool"/>
	<c path="String"/>
</f></getSelectedText>
		<getSelected public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></getSelected>
		<findText public="1" set="method"><f a="beginIndex:textToFind:caseSensitive">
	<c path="Int"/>
	<c path="String"/>
	<e path="Bool"/>
	<c path="Int"/>
</f></findText>
		<charCount public="1" set="null"><c path="Int"/></charCount>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.ui.ContextMenu" params="" file="/usr/lib/haxe/std/flash/ui/ContextMenu.hx" extern="1">
		<extends path="flash.display.NativeMenu"/>
		<isSupported public="1" set="null" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<hideBuiltInItems public="1" set="method"><f a=""><e path="Void"/></f></hideBuiltInItems>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenu"/></f></clone>
		<link public="1">
			<c path="flash.net.URLRequest"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</link>
		<customItems public="1"><c path="Array"><d/></c></customItems>
		<clipboardMenu public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clipboardMenu>
		<clipboardItems public="1">
			<c path="flash.ui.ContextMenuClipboardItems"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clipboardItems>
		<builtInItems public="1"><c path="flash.ui.ContextMenuBuiltInItems"/></builtInItems>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.ui.ContextMenuBuiltInItems" params="" file="/usr/lib/haxe/std/flash/ui/ContextMenuBuiltInItems.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuBuiltInItems"/></f></clone>
		<zoom public="1"><e path="Bool"/></zoom>
		<save public="1"><e path="Bool"/></save>
		<rewind public="1"><e path="Bool"/></rewind>
		<quality public="1"><e path="Bool"/></quality>
		<print public="1"><e path="Bool"/></print>
		<play public="1"><e path="Bool"/></play>
		<loop public="1"><e path="Bool"/></loop>
		<forwardAndBack public="1"><e path="Bool"/></forwardAndBack>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.ui.ContextMenuClipboardItems" params="" file="/usr/lib/haxe/std/flash/ui/ContextMenuClipboardItems.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuClipboardItems"/></f></clone>
		<selectAll public="1"><e path="Bool"/></selectAll>
		<paste public="1"><e path="Bool"/></paste>
		<cut public="1"><e path="Bool"/></cut>
		<copy public="1"><e path="Bool"/></copy>
		<clear public="1"><e path="Bool"/></clear>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.ui.KeyLocation" params="" file="/usr/lib/haxe/std/flash/ui/KeyLocation.hx">
		<STANDARD/>
		<RIGHT/>
		<NUM_PAD/>
		<LEFT/>
		<D_PAD/>
		<meta><m n=":fakeEnum"><e>UInt</e></m></meta>
	</enum>
	<class path="flash.ui.Keyboard" params="" file="/usr/lib/haxe/std/flash/ui/Keyboard.hx" extern="1">
		<A public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</A>
		<ALTERNATE public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</ALTERNATE>
		<AUDIO public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</AUDIO>
		<B public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</B>
		<BACK public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</BACK>
		<BACKQUOTE public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</BACKQUOTE>
		<BACKSLASH public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</BACKSLASH>
		<BACKSPACE public="1" static="1"><t path="UInt"/></BACKSPACE>
		<BLUE public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</BLUE>
		<C public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</C>
		<CAPS_LOCK public="1" static="1"><t path="UInt"/></CAPS_LOCK>
		<CHANNEL_DOWN public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</CHANNEL_DOWN>
		<CHANNEL_UP public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</CHANNEL_UP>
		<COMMA public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</COMMA>
		<COMMAND public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</COMMAND>
		<CONTROL public="1" static="1"><t path="UInt"/></CONTROL>
		<CharCodeStrings public="1" static="1">
			<c path="Array"><d/></c>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</CharCodeStrings>
		<D public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</D>
		<DELETE public="1" static="1"><t path="UInt"/></DELETE>
		<DOWN public="1" static="1"><t path="UInt"/></DOWN>
		<DVR public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</DVR>
		<E public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</E>
		<END public="1" static="1"><t path="UInt"/></END>
		<ENTER public="1" static="1"><t path="UInt"/></ENTER>
		<EQUAL public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</EQUAL>
		<ESCAPE public="1" static="1"><t path="UInt"/></ESCAPE>
		<EXIT public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</EXIT>
		<F public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</F>
		<F1 public="1" static="1"><t path="UInt"/></F1>
		<F10 public="1" static="1"><t path="UInt"/></F10>
		<F11 public="1" static="1"><t path="UInt"/></F11>
		<F12 public="1" static="1"><t path="UInt"/></F12>
		<F13 public="1" static="1"><t path="UInt"/></F13>
		<F14 public="1" static="1"><t path="UInt"/></F14>
		<F15 public="1" static="1"><t path="UInt"/></F15>
		<F2 public="1" static="1"><t path="UInt"/></F2>
		<F3 public="1" static="1"><t path="UInt"/></F3>
		<F4 public="1" static="1"><t path="UInt"/></F4>
		<F5 public="1" static="1"><t path="UInt"/></F5>
		<F6 public="1" static="1"><t path="UInt"/></F6>
		<F7 public="1" static="1"><t path="UInt"/></F7>
		<F8 public="1" static="1"><t path="UInt"/></F8>
		<F9 public="1" static="1"><t path="UInt"/></F9>
		<FAST_FORWARD public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</FAST_FORWARD>
		<G public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</G>
		<GREEN public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</GREEN>
		<GUIDE public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</GUIDE>
		<H public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</H>
		<HELP public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</HELP>
		<HOME public="1" static="1"><t path="UInt"/></HOME>
		<I public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</I>
		<INFO public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</INFO>
		<INPUT public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</INPUT>
		<INSERT public="1" static="1"><t path="UInt"/></INSERT>
		<J public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</J>
		<K public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</K>
		<KEYNAME_BEGIN public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_BEGIN>
		<KEYNAME_BREAK public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_BREAK>
		<KEYNAME_CLEARDISPLAY public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_CLEARDISPLAY>
		<KEYNAME_CLEARLINE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_CLEARLINE>
		<KEYNAME_DELETE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_DELETE>
		<KEYNAME_DELETECHAR public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_DELETECHAR>
		<KEYNAME_DELETELINE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_DELETELINE>
		<KEYNAME_DOWNARROW public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_DOWNARROW>
		<KEYNAME_END public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_END>
		<KEYNAME_EXECUTE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_EXECUTE>
		<KEYNAME_F1 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F1>
		<KEYNAME_F10 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F10>
		<KEYNAME_F11 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F11>
		<KEYNAME_F12 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F12>
		<KEYNAME_F13 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F13>
		<KEYNAME_F14 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F14>
		<KEYNAME_F15 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F15>
		<KEYNAME_F16 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F16>
		<KEYNAME_F17 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F17>
		<KEYNAME_F18 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F18>
		<KEYNAME_F19 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F19>
		<KEYNAME_F2 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F2>
		<KEYNAME_F20 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F20>
		<KEYNAME_F21 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F21>
		<KEYNAME_F22 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F22>
		<KEYNAME_F23 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F23>
		<KEYNAME_F24 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F24>
		<KEYNAME_F25 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F25>
		<KEYNAME_F26 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F26>
		<KEYNAME_F27 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F27>
		<KEYNAME_F28 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F28>
		<KEYNAME_F29 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F29>
		<KEYNAME_F3 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F3>
		<KEYNAME_F30 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F30>
		<KEYNAME_F31 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F31>
		<KEYNAME_F32 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F32>
		<KEYNAME_F33 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F33>
		<KEYNAME_F34 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F34>
		<KEYNAME_F35 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F35>
		<KEYNAME_F4 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F4>
		<KEYNAME_F5 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F5>
		<KEYNAME_F6 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F6>
		<KEYNAME_F7 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F7>
		<KEYNAME_F8 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F8>
		<KEYNAME_F9 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F9>
		<KEYNAME_FIND public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_FIND>
		<KEYNAME_HELP public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_HELP>
		<KEYNAME_HOME public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_HOME>
		<KEYNAME_INSERT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_INSERT>
		<KEYNAME_INSERTCHAR public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_INSERTCHAR>
		<KEYNAME_INSERTLINE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_INSERTLINE>
		<KEYNAME_LEFTARROW public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_LEFTARROW>
		<KEYNAME_MENU public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_MENU>
		<KEYNAME_MODESWITCH public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_MODESWITCH>
		<KEYNAME_NEXT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_NEXT>
		<KEYNAME_PAGEDOWN public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_PAGEDOWN>
		<KEYNAME_PAGEUP public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_PAGEUP>
		<KEYNAME_PAUSE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_PAUSE>
		<KEYNAME_PREV public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_PREV>
		<KEYNAME_PRINT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_PRINT>
		<KEYNAME_PRINTSCREEN public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_PRINTSCREEN>
		<KEYNAME_REDO public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_REDO>
		<KEYNAME_RESET public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_RESET>
		<KEYNAME_RIGHTARROW public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_RIGHTARROW>
		<KEYNAME_SCROLLLOCK public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_SCROLLLOCK>
		<KEYNAME_SELECT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_SELECT>
		<KEYNAME_STOP public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_STOP>
		<KEYNAME_SYSREQ public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_SYSREQ>
		<KEYNAME_SYSTEM public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_SYSTEM>
		<KEYNAME_UNDO public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_UNDO>
		<KEYNAME_UPARROW public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_UPARROW>
		<KEYNAME_USER public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_USER>
		<L public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</L>
		<LAST public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</LAST>
		<LEFT public="1" static="1"><t path="UInt"/></LEFT>
		<LEFTBRACKET public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</LEFTBRACKET>
		<LIVE public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</LIVE>
		<M public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</M>
		<MASTER_SHELL public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</MASTER_SHELL>
		<MENU public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</MENU>
		<MINUS public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</MINUS>
		<N public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</N>
		<NEXT public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</NEXT>
		<NUMBER_0 public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</NUMBER_0>
		<NUMBER_1 public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</NUMBER_1>
		<NUMBER_2 public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</NUMBER_2>
		<NUMBER_3 public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</NUMBER_3>
		<NUMBER_4 public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</NUMBER_4>
		<NUMBER_5 public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</NUMBER_5>
		<NUMBER_6 public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</NUMBER_6>
		<NUMBER_7 public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</NUMBER_7>
		<NUMBER_8 public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</NUMBER_8>
		<NUMBER_9 public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</NUMBER_9>
		<NUMPAD public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</NUMPAD>
		<NUMPAD_0 public="1" static="1"><t path="UInt"/></NUMPAD_0>
		<NUMPAD_1 public="1" static="1"><t path="UInt"/></NUMPAD_1>
		<NUMPAD_2 public="1" static="1"><t path="UInt"/></NUMPAD_2>
		<NUMPAD_3 public="1" static="1"><t path="UInt"/></NUMPAD_3>
		<NUMPAD_4 public="1" static="1"><t path="UInt"/></NUMPAD_4>
		<NUMPAD_5 public="1" static="1"><t path="UInt"/></NUMPAD_5>
		<NUMPAD_6 public="1" static="1"><t path="UInt"/></NUMPAD_6>
		<NUMPAD_7 public="1" static="1"><t path="UInt"/></NUMPAD_7>
		<NUMPAD_8 public="1" static="1"><t path="UInt"/></NUMPAD_8>
		<NUMPAD_9 public="1" static="1"><t path="UInt"/></NUMPAD_9>
		<NUMPAD_ADD public="1" static="1"><t path="UInt"/></NUMPAD_ADD>
		<NUMPAD_DECIMAL public="1" static="1"><t path="UInt"/></NUMPAD_DECIMAL>
		<NUMPAD_DIVIDE public="1" static="1"><t path="UInt"/></NUMPAD_DIVIDE>
		<NUMPAD_ENTER public="1" static="1"><t path="UInt"/></NUMPAD_ENTER>
		<NUMPAD_MULTIPLY public="1" static="1"><t path="UInt"/></NUMPAD_MULTIPLY>
		<NUMPAD_SUBTRACT public="1" static="1"><t path="UInt"/></NUMPAD_SUBTRACT>
		<O public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</O>
		<P public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</P>
		<PAGE_DOWN public="1" static="1"><t path="UInt"/></PAGE_DOWN>
		<PAGE_UP public="1" static="1"><t path="UInt"/></PAGE_UP>
		<PAUSE public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</PAUSE>
		<PERIOD public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</PERIOD>
		<PLAY public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</PLAY>
		<PREVIOUS public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</PREVIOUS>
		<Q public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</Q>
		<QUOTE public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</QUOTE>
		<R public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</R>
		<RECORD public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</RECORD>
		<RED public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</RED>
		<REWIND public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</REWIND>
		<RIGHT public="1" static="1"><t path="UInt"/></RIGHT>
		<RIGHTBRACKET public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</RIGHTBRACKET>
		<S public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</S>
		<SEARCH public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</SEARCH>
		<SEMICOLON public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</SEMICOLON>
		<SETUP public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</SETUP>
		<SHIFT public="1" static="1"><t path="UInt"/></SHIFT>
		<SKIP_BACKWARD public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</SKIP_BACKWARD>
		<SKIP_FORWARD public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</SKIP_FORWARD>
		<SLASH public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</SLASH>
		<SPACE public="1" static="1"><t path="UInt"/></SPACE>
		<STOP public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</STOP>
		<STRING_BEGIN public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_BEGIN>
		<STRING_BREAK public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_BREAK>
		<STRING_CLEARDISPLAY public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_CLEARDISPLAY>
		<STRING_CLEARLINE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_CLEARLINE>
		<STRING_DELETE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_DELETE>
		<STRING_DELETECHAR public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_DELETECHAR>
		<STRING_DELETELINE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_DELETELINE>
		<STRING_DOWNARROW public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_DOWNARROW>
		<STRING_END public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_END>
		<STRING_EXECUTE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_EXECUTE>
		<STRING_F1 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F1>
		<STRING_F10 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F10>
		<STRING_F11 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F11>
		<STRING_F12 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F12>
		<STRING_F13 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F13>
		<STRING_F14 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F14>
		<STRING_F15 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F15>
		<STRING_F16 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F16>
		<STRING_F17 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F17>
		<STRING_F18 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F18>
		<STRING_F19 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F19>
		<STRING_F2 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F2>
		<STRING_F20 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F20>
		<STRING_F21 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F21>
		<STRING_F22 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F22>
		<STRING_F23 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F23>
		<STRING_F24 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F24>
		<STRING_F25 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F25>
		<STRING_F26 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F26>
		<STRING_F27 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F27>
		<STRING_F28 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F28>
		<STRING_F29 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F29>
		<STRING_F3 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F3>
		<STRING_F30 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F30>
		<STRING_F31 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F31>
		<STRING_F32 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F32>
		<STRING_F33 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F33>
		<STRING_F34 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F34>
		<STRING_F35 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F35>
		<STRING_F4 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F4>
		<STRING_F5 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F5>
		<STRING_F6 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F6>
		<STRING_F7 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F7>
		<STRING_F8 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F8>
		<STRING_F9 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F9>
		<STRING_FIND public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_FIND>
		<STRING_HELP public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_HELP>
		<STRING_HOME public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_HOME>
		<STRING_INSERT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_INSERT>
		<STRING_INSERTCHAR public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_INSERTCHAR>
		<STRING_INSERTLINE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_INSERTLINE>
		<STRING_LEFTARROW public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_LEFTARROW>
		<STRING_MENU public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_MENU>
		<STRING_MODESWITCH public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_MODESWITCH>
		<STRING_NEXT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_NEXT>
		<STRING_PAGEDOWN public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_PAGEDOWN>
		<STRING_PAGEUP public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_PAGEUP>
		<STRING_PAUSE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_PAUSE>
		<STRING_PREV public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_PREV>
		<STRING_PRINT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_PRINT>
		<STRING_PRINTSCREEN public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_PRINTSCREEN>
		<STRING_REDO public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_REDO>
		<STRING_RESET public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_RESET>
		<STRING_RIGHTARROW public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_RIGHTARROW>
		<STRING_SCROLLLOCK public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_SCROLLLOCK>
		<STRING_SELECT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_SELECT>
		<STRING_STOP public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_STOP>
		<STRING_SYSREQ public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_SYSREQ>
		<STRING_SYSTEM public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_SYSTEM>
		<STRING_UNDO public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_UNDO>
		<STRING_UPARROW public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_UPARROW>
		<STRING_USER public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_USER>
		<SUBTITLE public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</SUBTITLE>
		<T public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</T>
		<TAB public="1" static="1"><t path="UInt"/></TAB>
		<U public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</U>
		<UP public="1" static="1"><t path="UInt"/></UP>
		<V public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</V>
		<VOD public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</VOD>
		<W public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</W>
		<X public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</X>
		<Y public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</Y>
		<YELLOW public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</YELLOW>
		<Z public="1" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</Z>
		<capsLock public="1" set="null" static="1"><e path="Bool"/></capsLock>
		<hasVirtualKeyboard public="1" set="null" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</hasVirtualKeyboard>
		<numLock public="1" set="null" static="1"><e path="Bool"/></numLock>
		<physicalKeyboardType public="1" set="null" static="1">
			<e path="flash.ui.KeyboardType"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</physicalKeyboardType>
		<isAccessible public="1" set="method" static="1"><f a=""><e path="Bool"/></f></isAccessible>
	</class>
	<enum path="flash.ui.KeyboardType" params="" file="/usr/lib/haxe/std/flash/ui/KeyboardType.hx">
		<NONE/>
		<KEYPAD/>
		<ALPHANUMERIC/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.ui.Mouse" params="" file="/usr/lib/haxe/std/flash/ui/Mouse.hx" extern="1">
		<cursor public="1" static="1">
			<d/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</cursor>
		<supportsCursor public="1" set="null" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</supportsCursor>
		<supportsNativeCursor public="1" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</supportsNativeCursor>
		<hide public="1" set="method" static="1"><f a=""><e path="Void"/></f></hide>
		<registerCursor public="1" static="1">
			<f a="name:cursor">
				<c path="String"/>
				<c path="flash.ui.MouseCursorData"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</registerCursor>
		<show public="1" set="method" static="1"><f a=""><e path="Void"/></f></show>
		<unregisterCursor public="1" static="1">
			<f a="name">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</unregisterCursor>
	</class>
	<class path="flash.ui.MouseCursorData" params="" file="/usr/lib/haxe/std/flash/ui/MouseCursorData.hx" extern="1">
		<hotSpot public="1"><c path="flash.geom.Point"/></hotSpot>
		<frameRate public="1"><c path="Float"/></frameRate>
		<data public="1"><c path="flash.Vector"><c path="flash.display.BitmapData"/></c></data>
		<new public="1"><f a=""><e path="Void"/></f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</class>
	<class path="flash.ui.Multitouch" params="" file="/usr/lib/haxe/std/flash/ui/Multitouch.hx" extern="1">
		<inputMode public="1" static="1"><e path="flash.ui.MultitouchInputMode"/></inputMode>
		<mapTouchToMouse public="1" static="1"><e path="Bool"/></mapTouchToMouse>
		<maxTouchPoints public="1" set="null" static="1"><c path="Int"/></maxTouchPoints>
		<supportedGestures public="1" set="null" static="1"><c path="flash.Vector"><c path="String"/></c></supportedGestures>
		<supportsGestureEvents public="1" set="null" static="1"><e path="Bool"/></supportsGestureEvents>
		<supportsTouchEvents public="1" set="null" static="1"><e path="Bool"/></supportsTouchEvents>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<enum path="flash.ui.MultitouchInputMode" params="" file="/usr/lib/haxe/std/flash/ui/MultitouchInputMode.hx">
		<TOUCH_POINT/>
		<NONE/>
		<GESTURE/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</enum>
	<class path="flash.utils.Dictionary" params="" file="/usr/lib/haxe/std/flash/utils/Dictionary.hx" extern="1">
		<new public="1" set="method"><f a="?weakKeys">
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.utils.Endian" params="" file="/usr/lib/haxe/std/flash/utils/Endian.hx">
		<LITTLE_ENDIAN/>
		<BIG_ENDIAN/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.utils.Namespace" params="" file="/usr/lib/haxe/std/flash/utils/Namespace.hx" extern="1">
		<uri public="1" set="null"><c path="String"/></uri>
		<prefix public="1" set="null"><d/></prefix>
		<new public="1" set="method"><f a="?prefix:?uri">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.utils.QName" params="" file="/usr/lib/haxe/std/flash/utils/QName.hx" extern="1">
		<uri public="1" set="null"><d/></uri>
		<localName public="1" set="null"><c path="String"/></localName>
		<new public="1" set="method"><f a="?namespace:?name">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.utils.RegExp" params="" file="/usr/lib/haxe/std/flash/utils/RegExp.hx" extern="1">
		<test public="1" set="method">
			<f a="?s">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<meta><m n=":ns"><e>http://adobe.com/AS3/2006/builtin</e></m></meta>
		</test>
		<exec public="1" set="method">
			<f a="?s">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":ns"><e>http://adobe.com/AS3/2006/builtin</e></m></meta>
		</exec>
		<source public="1" set="null"><c path="String"/></source>
		<multiline public="1" set="null"><e path="Bool"/></multiline>
		<lastIndex public="1"><c path="Int"/></lastIndex>
		<ignoreCase public="1" set="null"><e path="Bool"/></ignoreCase>
		<global public="1" set="null"><e path="Bool"/></global>
		<extended public="1" set="null"><e path="Bool"/></extended>
		<dotall public="1" set="null"><e path="Bool"/></dotall>
		<new public="1" set="method"><f a="?pattern:?options">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<meta><m n=":native"><e>RegExp</e></m></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.xml.XML" params="" file="/usr/lib/haxe/std/flash/xml/XML.hx" extern="1">
		<ignoreComments public="1" static="1"><e path="Bool"/></ignoreComments>
		<ignoreProcessingInstructions public="1" static="1"><e path="Bool"/></ignoreProcessingInstructions>
		<ignoreWhitespace public="1" static="1"><e path="Bool"/></ignoreWhitespace>
		<prettyIndent public="1" static="1"><c path="Int"/></prettyIndent>
		<prettyPrinting public="1" static="1"><e path="Bool"/></prettyPrinting>
		<defaultSettings public="1" set="method" static="1"><f a=""><d/></f></defaultSettings>
		<setSettings public="1" set="method" static="1"><f a="?o">
	<d/>
	<e path="Void"/>
</f></setSettings>
		<settings public="1" set="method" static="1"><f a=""><d/></f></settings>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></valueOf>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toJSON public="1">
			<f a="k">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</toJSON>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<setNotification public="1" set="method"><f a="f">
	<d/>
	<d/>
</f></setNotification>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<e path="Void"/>
</f></setNamespace>
		<setName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setName>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setLocalName>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<notification public="1" set="method"><f a=""><d/></f></notification>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></normalize>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<name public="1" set="method"><f a=""><d/></f></name>
		<localName public="1" set="method"><f a=""><d/></f></localName>
		<length public="1" set="method"><f a=""><c path="Int"/></f></length>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<hasSimpleContent public="1" set="method"><f a=""><e path="Bool"/></f></hasSimpleContent>
		<hasComplexContent public="1" set="method"><f a=""><e path="Bool"/></f></hasComplexContent>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></copy>
		<contains public="1" set="method"><f a="value">
	<d/>
	<e path="Bool"/>
</f></contains>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<childIndex public="1" set="method"><f a=""><c path="Int"/></f></childIndex>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<new public="1" set="method"><f a="?value">
	<d/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
		<haxe_dynamic><c path="flash.xml.XMLList"/></haxe_dynamic>
	</class>
	<class path="flash.xml.XMLList" params="" file="/usr/lib/haxe/std/flash/xml/XMLList.hx" extern="1">
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></valueOf>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toJSON public="1">
			<f a="k">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</toJSON>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<e path="Void"/>
</f></setNamespace>
		<setName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setName>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setLocalName>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></normalize>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<name public="1" set="method"><f a=""><d/></f></name>
		<localName public="1" set="method"><f a=""><d/></f></localName>
		<length public="1" set="method"><f a=""><c path="Int"/></f></length>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<hasSimpleContent public="1" set="method"><f a=""><e path="Bool"/></f></hasSimpleContent>
		<hasComplexContent public="1" set="method"><f a=""><e path="Bool"/></f></hasComplexContent>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></copy>
		<contains public="1" set="method"><f a="value">
	<d/>
	<e path="Bool"/>
</f></contains>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<childIndex public="1" set="method"><f a=""><c path="Int"/></f></childIndex>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<new public="1" set="method"><f a="?value">
	<d/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="haxe.FastCell" params="T" file="/usr/lib/haxe/std/haxe/FastList.hx" module="haxe.FastList">
		<next public="1"><c path="haxe.FastCell"><c path="haxe.FastCell.T"/></c></next>
		<elt public="1"><c path="haxe.FastCell.T"/></elt>
		<new public="1" set="method" line="33"><f a="elt:next">
	<c path="haxe.FastCell.T"/>
	<c path="haxe.FastCell"><c path="haxe.FastCell.T"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.FastList" params="T" file="/usr/lib/haxe/std/haxe/FastList.hx">
		<toString public="1" set="method" line="156">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a displayable representation of the String.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="138">
			<f a=""><t path="Iterator"><c path="haxe.FastList.T"/></t></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<remove public="1" set="method" line="107">
			<f a="v">
				<c path="haxe.FastList.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.</haxe_doc>
		</remove>
		<isEmpty public="1" get="inline" set="null" line="99">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Tells if a list is empty.</haxe_doc>
		</isEmpty>
		<pop public="1" get="inline" set="null" line="86">
			<f a=""><t path="Null"><c path="haxe.FastList.T"/></t></f>
			<haxe_doc>Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.</haxe_doc>
		</pop>
		<first public="1" get="inline" set="null" line="77">
			<f a=""><t path="Null"><c path="haxe.FastList.T"/></t></f>
			<haxe_doc>Returns the first element of the list, or null
		if the list is empty.</haxe_doc>
		</first>
		<add public="1" get="inline" set="null" line="69">
			<f a="item">
				<c path="haxe.FastList.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Add an element at the head of the list.</haxe_doc>
		</add>
		<head public="1"><c path="haxe.FastCell"><c path="haxe.FastList.T"/></c></head>
		<new public="1" set="method" line="63">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. A different class is created for each container used in platforms where it matters</haxe_doc>
	</class>
	<class path="haxe.Log" params="" file="/usr/lib/haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="29" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<clear public="1" set="dynamic" line="54" static="1"><f a=""><e path="Void"/></f></clear>
		<setColor public="1" set="dynamic" line="63" static="1"><f a="rgb">
	<c path="Int"/>
	<e path="Void"/>
</f></setColor>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/lib/haxe/std/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams>
		<c path="Array"><d/></c>
		<meta><m n=":optional"/></meta>
	</customParams>
	<className><c path="String"/></className>
</a></typedef>
	<class path="nme.Assets" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/Assets.hx">
		<cachedBitmapData public="1" line="32" static="1"><c path="Hash"><t path="nme.display.BitmapData"/></c></cachedBitmapData>
		<getBitmapData public="1" set="method" line="42" static="1">
			<f a="id:?useCache">
				<c path="String"/>
				<e path="Bool"/>
				<t path="nme.display.BitmapData"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded bitmap
	 * @usage		var bitmap = new Bitmap (Assets.getBitmapData ("image.jpg"));
	 * @param	id		The ID or asset path for the bitmap
	 * @param	useCache		(Optional) Whether to use BitmapData from the cache (Default: true)
	 * @return		A new BItmapData object</haxe_doc>
		</getBitmapData>
		<getBytes public="1" set="method" line="54" static="1">
			<f a="id">
				<c path="String"/>
				<t path="nme.utils.ByteArray"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded binary asset
	 * @usage		var bytes = Assets.getBytes ("file.zip");
	 * @param	id		The ID or asset path for the file
	 * @return		A new ByteArray object</haxe_doc>
		</getBytes>
		<getFont public="1" set="method" line="66" static="1">
			<f a="id">
				<c path="String"/>
				<t path="nme.text.Font"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded font
	 * @usage		var fontName = Assets.getFont ("font.ttf").fontName;
	 * @param	id		The ID or asset path for the font
	 * @return		A new Font object</haxe_doc>
		</getFont>
		<getSound public="1" set="method" line="78" static="1">
			<f a="id">
				<c path="String"/>
				<t path="nme.media.Sound"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded sound
	 * @usage		var sound = Assets.getSound ("sound.wav");
	 * @param	id		The ID or asset path for the sound
	 * @return		A new Sound object</haxe_doc>
		</getSound>
		<getText public="1" set="method" line="90" static="1">
			<f a="id">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded text asset
	 * @usage		var text = Assets.getText ("text.txt");
	 * @param	id		The ID or asset path for the file
	 * @return		A new String object</haxe_doc>
		</getText>
		<haxe_doc><![CDATA[* <p>The Assets class provides a cross-platform interface to access 
 * embedded images, fonts, sounds and other resource files.</p>
 * 
 * <p>The contents are populated automatically when an application
 * is compiled using the NME command-line tools, based on the
 * contents of the *.nmml project file.</p>
 * 
 * <p>For most platforms, the assets are included in the same directory
 * or package as the application, and the paths are handled
 * automatically. For web content, the assets are preloaded before
 * the start of the rest of the application. You can customize the 
 * preloader by extending the <code>NMEPreloader</code> class,
 * and specifying a custom preloader using <window preloader="" />
 * in the project file.</p>
 * 
 * @author Joshua Granick]]></haxe_doc>
	</class>
	<class path="nme.Lib" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/Lib.hx">
		<FULLSCREEN public="1" line="13" static="1"><c path="Int"/></FULLSCREEN>
		<BORDERLESS public="1" line="14" static="1"><c path="Int"/></BORDERLESS>
		<RESIZABLE public="1" line="15" static="1"><c path="Int"/></RESIZABLE>
		<HARDWARE public="1" line="16" static="1"><c path="Int"/></HARDWARE>
		<VSYNC public="1" line="17" static="1"><c path="Int"/></VSYNC>
		<HW_AA public="1" line="18" static="1"><c path="Int"/></HW_AA>
		<HW_AA_HIRES public="1" line="19" static="1"><c path="Int"/></HW_AA_HIRES>
		<ALLOW_SHADERS public="1" line="20" static="1"><c path="Int"/></ALLOW_SHADERS>
		<company public="1" get="nmeGetCompany" set="null" static="1"><c path="String"/></company>
		<current public="1" get="nmeGetCurrent" set="null" static="1"><t path="nme.display.MovieClip"/></current>
		<file public="1" get="nmeGetFile" set="null" static="1"><c path="String"/></file>
		<initHeight public="1" get="nmeGetInitHeight" set="null" static="1"><c path="Int"/></initHeight>
		<initWidth public="1" get="nmeGetInitWidth" set="null" static="1"><c path="Int"/></initWidth>
		<packageName public="1" get="nmeGetPackageName" set="null" static="1"><c path="String"/></packageName>
		<stage public="1" get="nmeGetStage" set="null" static="1"><t path="nme.display.Stage"/></stage>
		<version public="1" get="nmeGetVersion" set="null" static="1"><c path="String"/></version>
		<close public="1" set="method" line="36" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Closes the application.
	 * This is method is ignored in the Flash and HTML5 targets.</haxe_doc>
		</close>
		<create public="1" set="method" line="59" static="1">
			<f a="onLoaded:width:height:?frameRate:?color:?flags:?title:?icon">
				<f a=""><e path="Void"/></f>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
				<t path="nme.display.BitmapData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Creates a new application window. If you are using the NME
	 * command-line tools, this method will be called automatically
	 * as a part of the default platform templates.
	 * This is method is ignored in the Flash and HTML5 targets.
	 * @param	onLoaded		A method callback that is called once the window is created.
	 * @param	width		The requested width of the window. Use a width and height of 0 to request the full screen size.
	 * @param	height		The requested height of the window. Use a width and height of 0 to request the full screen size.
	 * @param	frameRate		The requested frame rate for the application.
	 * @param	color		An RGB color to use for the application background.
	 * @param	flags		A series of bit flags which can specify windowing options, like FULLSCREEN or HARDWARE
	 * @param	title		The title to use when creating the application window.
	 * @param	icon		An icon to use for the created application window.</haxe_doc>
		</create>
		<createManagedStage public="1" set="method" line="75" static="1">
			<f a="width:height">
				<c path="Int"/>
				<c path="Int"/>
				<unknown/>
			</f>
			<haxe_doc>* Creates a managed stage, for greater control customization and control
	 * of application events.
	 * This method is ignored in the Flash and HTML5 targets.
	 * @param	width		The requested width of the managed stage.
	 * @param	height		The requested width of the managed stage.</haxe_doc>
		</createManagedStage>
		<exit public="1" set="method" line="91" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Similar to the <code>close()</code> method, but the current 
	 * <code>Stage</code> object is given an opportunity to handle 
	 * the quit event before the application process is ended.
	 * This method is ignored in the Flash and HTML5 targets.]]></haxe_doc>
		</exit>
		<forceClose public="1" set="method" line="105" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Terminates the application process immediately without
	 * performing a clean shutdown.
	 * This method is ignored in the Flash and HTML5 targets.</haxe_doc>
		</forceClose>
		<getTimer public="1" get="inline" set="null" line="123" static="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc><![CDATA[* Returns the time in milliseconds, relative to the start of
	 * the application. This is a high performance call in order to 
	 * help regulate time-based operations. Depending upon the
	 * target platform, this value may or may not be an absolute
	 * timestamp. If you need an exact time, you should use the
	 * <code>Date</code> object.
	 * @return		A relative time value in milliseconds.]]></haxe_doc>
		</getTimer>
		<getURL public="1" set="method" line="142" static="1">
			<f a="url:?target">
				<t path="nme.net.URLRequest"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Opens a browser window with the specified URL. 
	 * @param	url		The URL to open.
	 * @param	target		An optional window target value.</haxe_doc>
		</getURL>
		<pause public="1" set="method" line="161" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* For supported platforms, the NME application will be
	 * paused. This can help improve response times if fullscreen
	 * native UI element is being used temporarily.
	 * This method is ignored in the Flash and HTML5 targets.</haxe_doc>
		</pause>
		<postUICallback public="1" set="method" line="179" static="1">
			<f a="handler">
				<f a=""><e path="Void"/></f>
				<e path="Void"/>
			</f>
			<haxe_doc>* For some target platforms, NME operates on a separate thread
	 * than the native application UI. In these cases, you can use this
	 * method to make thread-safe calls to the native UI.
	 * 
	 * If the platform does not require thread-safe callbacks, the 
	 * handler method will be called immediately.
	 * @param	handler		The method handler you wish to call when the UI is available.</haxe_doc>
		</postUICallback>
		<resume public="1" set="method" line="196" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Resumes the NME application. For certain platforms,
	 * pausing the application can improve response times when
	 * a fullscreen native UI element is being displayed.
	 * This method is ignored in the Flash and HTML5 targets.</haxe_doc>
		</resume>
		<setPackage public="1" set="method" line="215" static="1">
			<f a="company:file:packageName:version">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Specifies meta-data for the running application. If you are using 
	 * the NME command-line tools, this method will be called automatically
	 * as a part of the default platform templates.
	 * This method is ignored in the Flash and HTML5 targets.
	 * @param	company		The company name for the application.
	 * @param	file		The file name for the application.
	 * @param	packageName		The package name of the application.
	 * @param	version		The version string of the application.</haxe_doc>
		</setPackage>
		<trace public="1" set="method" line="228" static="1">
			<f a="arg">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Sends a <code>trace</code> call for the current platform.
	 * @param	arg]]></haxe_doc>
		</trace>
		<nmeGetCompany set="method" line="247" static="1"><f a=""><c path="String"/></f></nmeGetCompany>
		<nmeGetCurrent set="method" line="257" static="1"><f a=""><t path="nme.display.MovieClip"/></f></nmeGetCurrent>
		<nmeGetFile set="method" line="271" static="1"><f a=""><c path="String"/></f></nmeGetFile>
		<nmeGetInitHeight set="method" line="281" static="1"><f a=""><c path="Int"/></f></nmeGetInitHeight>
		<nmeGetInitWidth set="method" line="291" static="1"><f a=""><c path="Int"/></f></nmeGetInitWidth>
		<nmeGetPackageName set="method" line="301" static="1"><f a=""><c path="String"/></f></nmeGetPackageName>
		<nmeGetStage set="method" line="311" static="1"><f a=""><t path="nme.display.Stage"/></f></nmeGetStage>
		<nmeGetVersion set="method" line="323" static="1"><f a=""><c path="String"/></f></nmeGetVersion>
	</class>
	<typedef path="nme.Vector" params="T" file="/usr/lib/haxe/lib/nme/3,4,4/nme/Vector.hx"><c path="flash.Vector"><c path="nme.Vector.T"/></c></typedef>
	<typedef path="nme.display.Bitmap" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/display/Bitmap.hx"><c path="flash.display.Bitmap"/></typedef>
	<typedef path="nme.display.BitmapData" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/display/BitmapData.hx"><c path="flash.display.BitmapData"/></typedef>
	<typedef path="nme.display.BitmapInt32" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/display/BitmapInt32.hx"><c path="Int"/></typedef>
	<typedef path="nme.display.BlendMode" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/display/BlendMode.hx"><e path="flash.display.BlendMode"/></typedef>
	<typedef path="nme.display.DisplayObject" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/display/DisplayObject.hx"><c path="flash.display.DisplayObject"/></typedef>
	<typedef path="nme.display.Graphics" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/display/Graphics.hx"><c path="flash.display.Graphics"/></typedef>
	<typedef path="nme.display.MovieClip" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/display/MovieClip.hx"><c path="flash.display.MovieClip"/></typedef>
	<typedef path="nme.display.Sprite" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/display/Sprite.hx"><c path="flash.display.Sprite"/></typedef>
	<typedef path="nme.display.Stage" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/display/Stage.hx"><c path="flash.display.Stage"/></typedef>
	<typedef path="nme.display.StageAlign" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/display/StageAlign.hx"><e path="flash.display.StageAlign"/></typedef>
	<typedef path="nme.display.StageDisplayState" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/display/StageDisplayState.hx"><e path="flash.display.StageDisplayState"/></typedef>
	<typedef path="nme.display.StageScaleMode" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/display/StageScaleMode.hx"><e path="flash.display.StageScaleMode"/></typedef>
	<class path="nme.display.Tilesheet" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/display/Tilesheet.hx">
		<TILE_SCALE public="1" get="inline" set="null" line="59" static="1"><c path="Int"/></TILE_SCALE>
		<TILE_ROTATION public="1" get="inline" set="null" line="60" static="1"><c path="Int"/></TILE_ROTATION>
		<TILE_RGB public="1" get="inline" set="null" line="61" static="1"><c path="Int"/></TILE_RGB>
		<TILE_ALPHA public="1" get="inline" set="null" line="62" static="1"><c path="Int"/></TILE_ALPHA>
		<TILE_TRANS_2x2 public="1" get="inline" set="null" line="66" static="1"><c path="Int"/></TILE_TRANS_2x2>
		<TILE_BLEND_NORMAL public="1" get="inline" set="null" line="69" static="1"><c path="Int"/></TILE_BLEND_NORMAL>
		<TILE_BLEND_ADD public="1" get="inline" set="null" line="70" static="1"><c path="Int"/></TILE_BLEND_ADD>
		<defaultRatio line="77" static="1"><t path="nme.geom.Point"/></defaultRatio>
		<drawTiles public="1" set="method" line="193">
			<f a="graphics:tileData:?smooth:?flags">
				<t path="nme.display.Graphics"/>
				<c path="Array"><c path="Float"/></c>
				<e path="Bool"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Fast method to draw a batch of tiles using a Tilesheet
	 * 
	 * The input array accepts the x, y and tile ID for each tile you wish to draw.
	 * For example, an array of [ 0, 0, 0, 10, 10, 1 ] would draw tile 0 to (0, 0) and
	 * tile 1 to (10, 10)
	 * 
	 * You can also set flags for TILE_SCALE, TILE_ROTATION, TILE_RGB and
	 * TILE_ALPHA.
	 * 
	 * Depending on which flags are active, this is the full order of the array:
	 * 
	 * [ x, y, tile ID, scale, rotation, red, green, blue, alpha, x, y ... ]
	 * 
	 * @param	graphics		The neash.display.Graphics object to use for drawing
	 * @param	tileData		An array of all position, ID and optional values for use in drawing
	 * @param	smooth		(Optional) Whether drawn tiles should be smoothed (Default: false)
	 * @param	flags		(Optional) Flags to enable scale, rotation, RGB and/or alpha when drawing (Default: 0)</haxe_doc>
		</drawTiles>
		<adjustLen set="method" line="162"><f a="vec:len">
	<t path="nme.Vector"><c path="Float"/></t>
	<t path="UInt"/>
	<t path="nme.Vector"><c path="Float"/></t>
</f></adjustLen>
		<adjustIndices set="method" line="131"><f a="vec:len">
	<t path="nme.Vector"><c path="Int"/></t>
	<t path="UInt"/>
	<t path="nme.Vector"><c path="Int"/></t>
</f></adjustIndices>
		<adjustIDs set="method" line="116"><f a="vec:len">
	<t path="nme.Vector"><c path="Int"/></t>
	<t path="UInt"/>
	<t path="nme.Vector"><c path="Int"/></t>
</f></adjustIDs>
		<addTileRect public="1" set="method" line="107"><f a="rectangle:?centerPoint">
	<t path="nme.geom.Rectangle"/>
	<t path="nme.geom.Point"/>
	<e path="Void"/>
</f></addTileRect>
		<_uvs><t path="nme.Vector"><c path="Float"/></t></_uvs>
		<_indices><t path="nme.Vector"><c path="Int"/></t></_indices>
		<_vertices><t path="nme.Vector"><c path="Float"/></t></_vertices>
		<_ids><t path="nme.Vector"><c path="Int"/></t></_ids>
		<tileUVs><c path="Array"><t path="nme.geom.Rectangle"/></c></tileUVs>
		<tiles><c path="Array"><t path="nme.geom.Rectangle"/></c></tiles>
		<tilePoints><c path="Array"><t path="nme.geom.Point"/></c></tilePoints>
		<bitmapWidth><c path="Int"/></bitmapWidth>
		<bitmapHeight><c path="Int"/></bitmapHeight>
		<nmeBitmap public="1">
			<t path="nme.display.BitmapData"/>
			<haxe_doc>* @private</haxe_doc>
		</nmeBitmap>
		<new public="1" set="method" line="89"><f a="inImage">
	<t path="nme.display.BitmapData"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="nme.errors.Error" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/errors/Error.hx"><c path="flash.errors.Error"/></typedef>
	<typedef path="nme.events.Event" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/events/Event.hx"><c path="flash.events.Event"/></typedef>
	<typedef path="nme.events.IOErrorEvent" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/events/IOErrorEvent.hx"><c path="flash.events.IOErrorEvent"/></typedef>
	<typedef path="nme.events.KeyboardEvent" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/events/KeyboardEvent.hx"><c path="flash.events.KeyboardEvent"/></typedef>
	<typedef path="nme.events.MouseEvent" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/events/MouseEvent.hx"><c path="flash.events.MouseEvent"/></typedef>
	<typedef path="nme.events.TouchEvent" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/events/TouchEvent.hx"><c path="flash.events.TouchEvent"/></typedef>
	<typedef path="nme.geom.ColorTransform" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/geom/ColorTransform.hx"><c path="flash.geom.ColorTransform"/></typedef>
	<typedef path="nme.geom.Matrix" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/geom/Matrix.hx"><c path="flash.geom.Matrix"/></typedef>
	<typedef path="nme.geom.Point" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/geom/Point.hx"><c path="flash.geom.Point"/></typedef>
	<typedef path="nme.geom.Rectangle" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/geom/Rectangle.hx"><c path="flash.geom.Rectangle"/></typedef>
	<class path="nme.installer.Assets" params="" file="export/flash/haxe/nme/installer/Assets.hx">
		<cachedBitmapData public="1" line="20" static="1"><c path="Hash"><t path="nme.display.BitmapData"/></c></cachedBitmapData>
		<initialized line="22" static="1"><e path="Bool"/></initialized>
		<resourceClasses line="23" static="1"><c path="Hash"><d/></c></resourceClasses>
		<resourceTypes line="24" static="1"><c path="Hash"><c path="String"/></c></resourceTypes>
		<initialize set="method" line="27" static="1"><f a=""><e path="Void"/></f></initialize>
		<getBitmapData public="1" set="method" line="195" static="1"><f a="id:?useCache">
	<c path="String"/>
	<e path="Bool"/>
	<t path="nme.display.BitmapData"/>
</f></getBitmapData>
		<getBytes public="1" set="method" line="230" static="1"><f a="id">
	<c path="String"/>
	<t path="nme.utils.ByteArray"/>
</f></getBytes>
		<getFont public="1" set="method" line="249" static="1"><f a="id">
	<c path="String"/>
	<t path="nme.text.Font"/>
</f></getFont>
		<getSound public="1" set="method" line="268" static="1"><f a="id">
	<c path="String"/>
	<t path="nme.media.Sound"/>
</f></getSound>
		<getText public="1" set="method" line="289" static="1"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getText>
		<haxe_doc>* ...
 * @author Joshua Granick</haxe_doc>
	</class>
	<typedef path="nme.media.Sound" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/media/Sound.hx"><c path="flash.media.Sound"/></typedef>
	<typedef path="nme.media.SoundChannel" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/media/SoundChannel.hx"><c path="flash.media.SoundChannel"/></typedef>
	<typedef path="nme.media.SoundTransform" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/media/SoundTransform.hx"><c path="flash.media.SoundTransform"/></typedef>
	<typedef path="nme.net.SharedObject" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/net/SharedObject.hx"><c path="flash.net.SharedObject"/></typedef>
	<typedef path="nme.net.SharedObjectFlushStatus" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/net/SharedObjectFlushStatus.hx"><c path="flash.net.SharedObjectFlushStatus"/></typedef>
	<typedef path="nme.net.URLRequest" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/net/URLRequest.hx"><c path="flash.net.URLRequest"/></typedef>
	<typedef path="nme.system.System" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/system/System.hx"><c path="flash.system.System"/></typedef>
	<typedef path="nme.text.Font" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/text/Font.hx"><c path="flash.text.Font"/></typedef>
	<typedef path="nme.text.TextField" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/text/TextField.hx"><c path="flash.text.TextField"/></typedef>
	<typedef path="nme.text.TextFieldType" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/text/TextFieldType.hx"><e path="flash.text.TextFieldType"/></typedef>
	<typedef path="nme.text.TextFormat" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/text/TextFormat.hx"><c path="flash.text.TextFormat"/></typedef>
	<typedef path="nme.text.TextFormatAlign" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/text/TextFormatAlign.hx"><e path="flash.text.TextFormatAlign"/></typedef>
	<typedef path="nme.ui.Keyboard" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/ui/Keyboard.hx"><c path="flash.ui.Keyboard"/></typedef>
	<typedef path="nme.ui.Mouse" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/ui/Mouse.hx"><c path="flash.ui.Mouse"/></typedef>
	<typedef path="nme.ui.Multitouch" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/ui/Multitouch.hx"><c path="flash.ui.Multitouch"/></typedef>
	<typedef path="nme.ui.MultitouchInputMode" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/ui/MultitouchInputMode.hx"><e path="flash.ui.MultitouchInputMode"/></typedef>
	<typedef path="nme.utils.ByteArray" params="" file="/usr/lib/haxe/lib/nme/3,4,4/nme/utils/ByteArray.hx"><c path="flash.utils.ByteArray"/></typedef>
	<class path="org.flixel.FlxAssets" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/FlxAssets.hx">
		<imgDefaultButton public="1" line="14" static="1"><c path="String"/></imgDefaultButton>
		<imgLogo public="1" line="15" static="1"><c path="String"/></imgLogo>
		<imgDefault public="1" line="16" static="1"><c path="String"/></imgDefault>
		<imgAuto public="1" line="17" static="1"><c path="String"/></imgAuto>
		<imgAutoAlt public="1" line="18" static="1"><c path="String"/></imgAutoAlt>
		<imgLogoCorners public="1" line="19" static="1"><c path="String"/></imgLogoCorners>
		<imgLogoLight public="1" line="20" static="1"><c path="String"/></imgLogoLight>
		<imgHandle public="1" line="21" static="1"><c path="String"/></imgHandle>
		<imgDefaultCursor public="1" line="22" static="1"><c path="String"/></imgDefaultCursor>
		<imgBounds public="1" line="23" static="1"><c path="String"/></imgBounds>
		<imgOpen public="1" line="24" static="1"><c path="String"/></imgOpen>
		<imgRecordOff public="1" line="25" static="1"><c path="String"/></imgRecordOff>
		<imgRecordOn public="1" line="26" static="1"><c path="String"/></imgRecordOn>
		<imgStop public="1" line="27" static="1"><c path="String"/></imgStop>
		<imgFlixel public="1" line="28" static="1"><c path="String"/></imgFlixel>
		<imgRestart public="1" line="29" static="1"><c path="String"/></imgRestart>
		<imgPause public="1" line="30" static="1"><c path="String"/></imgPause>
		<imgPlay public="1" line="31" static="1"><c path="String"/></imgPlay>
		<imgStep public="1" line="32" static="1"><c path="String"/></imgStep>
		<imgBase public="1" line="34" static="1"><c path="String"/></imgBase>
		<imgStick public="1" line="35" static="1"><c path="String"/></imgStick>
		<imgButtonA public="1" line="36" static="1"><c path="String"/></imgButtonA>
		<imgButtonB public="1" line="37" static="1"><c path="String"/></imgButtonB>
		<imgButtonC public="1" line="38" static="1"><c path="String"/></imgButtonC>
		<imgButtonX public="1" line="39" static="1"><c path="String"/></imgButtonX>
		<imgButtonY public="1" line="40" static="1"><c path="String"/></imgButtonY>
		<imgButtonUp public="1" line="41" static="1"><c path="String"/></imgButtonUp>
		<imgButtonDown public="1" line="42" static="1"><c path="String"/></imgButtonDown>
		<imgButtonLeft public="1" line="43" static="1"><c path="String"/></imgButtonLeft>
		<imgButtonRight public="1" line="44" static="1"><c path="String"/></imgButtonRight>
		<nokiaFont public="1" get="getNokiaFont" set="null" static="1"><c path="String"/></nokiaFont>
		<getNokiaFont public="1" set="method" line="47" static="1"><f a=""><c path="String"/></f></getNokiaFont>
		<courierFont public="1" get="getCourierFont" set="null" static="1"><c path="String"/></courierFont>
		<getCourierFont public="1" set="method" line="53" static="1"><f a=""><c path="String"/></f></getCourierFont>
		<sndBeep public="1" line="58" static="1"><c path="String"/></sndBeep>
		<drawLogo public="1" set="method" line="60" static="1"><f a="graph">
	<t path="nme.display.Graphics"/>
	<e path="Void"/>
</f></drawLogo>
		<cacheSounds public="1" set="method" line="117" static="1"><f a=""><e path="Void"/></f></cacheSounds>
		<haxe_doc>* ...
 * @author Zaphod</haxe_doc>
	</class>
	<class path="org.flixel.FlxRect" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/FlxRect.hx">
		<overlaps public="1" get="inline" set="null" line="161">
			<f a="Rect">
				<c path="org.flixel.FlxRect"/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Checks to see if some <code>FlxRect</code> object overlaps this <code>FlxRect</code> object.
	 * @param	Rect	The rectangle being tested.
	 * @return	Whether or not the two rectangles overlap.]]></haxe_doc>
		</overlaps>
		<copyToFlash public="1" get="inline" set="null" line="147">
			<f a="FlashRect">
				<t path="nme.geom.Rectangle"/>
				<t path="nme.geom.Rectangle"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from this rectangle to the specified Flash rectangle.
	 * @param	Point	Any <code>Rectangle</code>.
	 * @return	A reference to the altered rectangle parameter.]]></haxe_doc>
		</copyToFlash>
		<copyFromFlash public="1" get="inline" set="null" line="133">
			<f a="FlashRect">
				<t path="nme.geom.Rectangle"/>
				<c path="org.flixel.FlxRect"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from the specified Flash rectangle.
	 * @param	FlashRect	Any <code>Rectangle</code>.
	 * @return	A reference to itself.]]></haxe_doc>
		</copyFromFlash>
		<copyTo public="1" get="inline" set="null" line="119">
			<f a="Rect">
				<c path="org.flixel.FlxRect"/>
				<c path="org.flixel.FlxRect"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from this rectangle to the specified rectangle.
	 * @param	Point	Any <code>FlxRect</code>.
	 * @return	A reference to the altered rectangle parameter.]]></haxe_doc>
		</copyTo>
		<copyFrom public="1" get="inline" set="null" line="105">
			<f a="Rect">
				<c path="org.flixel.FlxRect"/>
				<c path="org.flixel.FlxRect"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from the specified rectangle.
	 * @param	Rect	Any <code>FlxRect</code>.
	 * @return	A reference to itself.]]></haxe_doc>
		</copyFrom>
		<make public="1" get="inline" set="null" line="91">
			<f a="?X:?Y:?Width:?Height">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="org.flixel.FlxRect"/>
			</f>
			<haxe_doc>* Fill this rectangle with the data provided.
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.
	 * @param	Width	Desired width of the rectangle.
	 * @param	Height	Desired height of the rectangle.
	 * @return	A reference to itself.</haxe_doc>
		</make>
		<getBottom public="1" set="method" line="78">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* The Y coordinate of the bottom of the rectangle.  Read-only.</haxe_doc>
		</getBottom>
		<bottom public="1" get="getBottom" set="null"><c path="Float"/></bottom>
		<getTop public="1" set="method" line="68">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* The Y coordinate of the top of the rectangle.  Read-only.</haxe_doc>
		</getTop>
		<top public="1" get="getTop" set="null"><c path="Float"/></top>
		<getRight public="1" set="method" line="58">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* The X coordinate of the right side of the rectangle.  Read-only.</haxe_doc>
		</getRight>
		<right public="1" get="getRight" set="null"><c path="Float"/></right>
		<getLeft public="1" set="method" line="48">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* The X coordinate of the left side of the rectangle.  Read-only.</haxe_doc>
		</getLeft>
		<left public="1" get="getLeft" set="null"><c path="Float"/></left>
		<height public="1">
			<c path="Float"/>
			<haxe_doc>* @default 0</haxe_doc>
		</height>
		<width public="1">
			<c path="Float"/>
			<haxe_doc>* @default 0</haxe_doc>
		</width>
		<y public="1">
			<c path="Float"/>
			<haxe_doc>* @default 0</haxe_doc>
		</y>
		<x public="1">
			<c path="Float"/>
			<haxe_doc>* @default 0</haxe_doc>
		</x>
		<new public="1" set="method" line="35">
			<f a="?X:?Y:?Width:?Height">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Instantiate a new rectangle.
	 * 
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.
	 * @param	Width	Desired width of the rectangle.
	 * @param	Height	Desired height of the rectangle.</haxe_doc>
		</new>
		<haxe_doc>* Stores a rectangle.</haxe_doc>
	</class>
	<class path="org.flixel.FlxPoint" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/FlxPoint.hx">
		<toString public="1" get="inline" set="null" line="98">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Convert object to readable string name.  Useful for debugging, save games, etc.</haxe_doc>
		</toString>
		<copyToFlash public="1" get="inline" set="null" line="88">
			<f a="FlashPoint">
				<t path="nme.geom.Point"/>
				<t path="nme.geom.Point"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from this point to the specified Flash point.
	 * @param	Point	Any <code>Point</code>.
	 * @return	A reference to the altered point parameter.]]></haxe_doc>
		</copyToFlash>
		<copyFromFlash public="1" get="inline" set="null" line="76">
			<f a="FlashPoint">
				<t path="nme.geom.Point"/>
				<c path="org.flixel.FlxPoint"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from the specified Flash point.
	 * @param	Point	Any <code>Point</code>.
	 * @return	A reference to itself.]]></haxe_doc>
		</copyFromFlash>
		<copyTo public="1" get="inline" set="null" line="64">
			<f a="point">
				<c path="org.flixel.FlxPoint"/>
				<c path="org.flixel.FlxPoint"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from this point to the specified point.
	 * @param	Point	Any <code>FlxPoint</code>.
	 * @return	A reference to the altered point parameter.]]></haxe_doc>
		</copyTo>
		<copyFrom public="1" get="inline" set="null" line="52">
			<f a="point">
				<c path="org.flixel.FlxPoint"/>
				<c path="org.flixel.FlxPoint"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from the specified point.
	 * @param	Point	Any <code>FlxPoint</code>.
	 * @return	A reference to itself.]]></haxe_doc>
		</copyFrom>
		<make public="1" get="inline" set="null" line="40">
			<f a="?X:?Y">
				<c path="Float"/>
				<c path="Float"/>
				<c path="org.flixel.FlxPoint"/>
			</f>
			<haxe_doc>* Instantiate a new point object.
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.</haxe_doc>
		</make>
		<y public="1">
			<c path="Float"/>
			<haxe_doc>* @default 0</haxe_doc>
		</y>
		<x public="1">
			<c path="Float"/>
			<haxe_doc>* @default 0</haxe_doc>
		</x>
		<new public="1" set="method" line="29">
			<f a="?X:?Y">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Instantiate a new point object.
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.</haxe_doc>
		</new>
		<haxe_doc>* Stores a 2D floating point coordinate.</haxe_doc>
	</class>
	<class path="org.flixel.FlxObject" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/FlxObject.hx">
		<extends path="org.flixel.FlxBasic"/>
		<SEPARATE_BIAS public="1" line="21" static="1">
			<c path="Float"/>
			<haxe_doc>* This value dictates the maximum number of pixels two objects have to intersect before collision stops trying to separate them.
	 * Don't modify this unless your objects are passing through eachother.</haxe_doc>
		</SEPARATE_BIAS>
		<LEFT public="1" get="inline" set="null" line="25" static="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[* Generic value for "left" Used by <code>facing</code>, <code>allowCollisions</code>, and <code>touching</code>.]]></haxe_doc>
		</LEFT>
		<RIGHT public="1" get="inline" set="null" line="29" static="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[* Generic value for "right" Used by <code>facing</code>, <code>allowCollisions</code>, and <code>touching</code>.]]></haxe_doc>
		</RIGHT>
		<UP public="1" get="inline" set="null" line="33" static="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[* Generic value for "up" Used by <code>facing</code>, <code>allowCollisions</code>, and <code>touching</code>.]]></haxe_doc>
		</UP>
		<DOWN public="1" get="inline" set="null" line="37" static="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[* Generic value for "down" Used by <code>facing</code>, <code>allowCollisions</code>, and <code>touching</code>.]]></haxe_doc>
		</DOWN>
		<NONE public="1" get="inline" set="null" line="41" static="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[* Special-case constant meaning no collisions, used mainly by <code>allowCollisions</code> and <code>touching</code>.]]></haxe_doc>
		</NONE>
		<CEILING public="1" get="inline" set="null" line="45" static="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[* Special-case constant meaning up, used mainly by <code>allowCollisions</code> and <code>touching</code>.]]></haxe_doc>
		</CEILING>
		<FLOOR public="1" get="inline" set="null" line="49" static="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[* Special-case constant meaning down, used mainly by <code>allowCollisions</code> and <code>touching</code>.]]></haxe_doc>
		</FLOOR>
		<WALL public="1" get="inline" set="null" line="53" static="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[* Special-case constant meaning only the left and right sides, used mainly by <code>allowCollisions</code> and <code>touching</code>.]]></haxe_doc>
		</WALL>
		<ANY public="1" get="inline" set="null" line="57" static="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[* Special-case constant meaning any direction, used mainly by <code>allowCollisions</code> and <code>touching</code>.]]></haxe_doc>
		</ANY>
		<PATH_FORWARD public="1" get="inline" set="null" line="62" static="1">
			<c path="Int"/>
			<haxe_doc>* Path behavior controls: move from the start of the path to the end then stop.</haxe_doc>
		</PATH_FORWARD>
		<PATH_BACKWARD public="1" get="inline" set="null" line="66" static="1">
			<c path="Int"/>
			<haxe_doc>* Path behavior controls: move from the end of the path to the start then stop.</haxe_doc>
		</PATH_BACKWARD>
		<PATH_LOOP_FORWARD public="1" get="inline" set="null" line="70" static="1">
			<c path="Int"/>
			<haxe_doc>* Path behavior controls: move from the start of the path to the end then directly back to the start, and start over.</haxe_doc>
		</PATH_LOOP_FORWARD>
		<PATH_LOOP_BACKWARD public="1" get="inline" set="null" line="74" static="1">
			<c path="Int"/>
			<haxe_doc>* Path behavior controls: move from the end of the path to the start then directly back to the end, and start over.</haxe_doc>
		</PATH_LOOP_BACKWARD>
		<PATH_YOYO public="1" get="inline" set="null" line="78" static="1">
			<c path="Int"/>
			<haxe_doc>* Path behavior controls: move from the start of the path to the end then turn around and go back to the start, over and over.</haxe_doc>
		</PATH_YOYO>
		<PATH_HORIZONTAL_ONLY public="1" get="inline" set="null" line="82" static="1">
			<c path="Int"/>
			<haxe_doc>* Path behavior controls: ignores any vertical component to the path data, only follows side to side.</haxe_doc>
		</PATH_HORIZONTAL_ONLY>
		<PATH_VERTICAL_ONLY public="1" get="inline" set="null" line="86" static="1">
			<c path="Int"/>
			<haxe_doc>* Path behavior controls: ignores any horizontal component to the path data, only follows up and down.</haxe_doc>
		</PATH_VERTICAL_ONLY>
		<_firstSeparateFlxRect line="88" static="1"><c path="org.flixel.FlxRect"/></_firstSeparateFlxRect>
		<_secondSeparateFlxRect line="89" static="1"><c path="org.flixel.FlxRect"/></_secondSeparateFlxRect>
		<_pZero get="inline" set="null" line="167" static="1">
			<c path="org.flixel.FlxPoint"/>
			<haxe_doc><![CDATA[* Should always represent (0,0) - useful for different things, for avoiding unnecessary <code>new</code> calls.]]></haxe_doc>
		</_pZero>
		<separate public="1" get="inline" set="null" line="1075" static="1">
			<f a="Object1:Object2">
				<c path="org.flixel.FlxObject"/>
				<c path="org.flixel.FlxObject"/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* The main collision resolution function in flixel.
	 * @param	Object1 	Any <code>FlxObject</code>.
	 * @param	Object2		Any other <code>FlxObject</code>.
	 * @return	Whether the objects in fact touched and were separated.]]></haxe_doc>
		</separate>
		<separateX public="1" set="method" line="1088" static="1">
			<f a="Object1:Object2">
				<c path="org.flixel.FlxObject"/>
				<c path="org.flixel.FlxObject"/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* The X-axis component of the object separation process.
	 * @param	Object1 	Any <code>FlxObject</code>.
	 * @param	Object2		Any other <code>FlxObject</code>.
	 * @return	Whether the objects in fact touched and were separated along the X axis.]]></haxe_doc>
		</separateX>
		<separateY public="1" set="method" line="1199" static="1">
			<f a="Object1:Object2">
				<c path="org.flixel.FlxObject"/>
				<c path="org.flixel.FlxObject"/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* The Y-axis component of the object separation process.
	 * @param	Object1 	Any <code>FlxObject</code>.
	 * @param	Object2		Any other <code>FlxObject</code>.
	 * @return	Whether the objects in fact touched and were separated along the Y axis.]]></haxe_doc>
		</separateY>
		<hurt public="1" set="method" line="1060">
			<f a="Damage">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Reduces the "health" variable of this sprite by the amount specified in Damage.
	 * Calls kill() if health drops to or below zero.
	 * @param	Damage		How much health to take away (use a negative number to give a health bonus).</haxe_doc>
		</hurt>
		<justTouched public="1" get="inline" set="null" line="1050">
			<f a="Direction">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Handy function for checking if this object is just landed on a particular surface.
	 * @param	Direction	Any of the collision flags (e.g. LEFT, FLOOR, etc).
	 * @return	Whether the object just landed on (any of) the specified surface(s) this frame.</haxe_doc>
		</justTouched>
		<isTouching public="1" get="inline" set="null" line="1040">
			<f a="Direction">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Handy function for checking if this object is touching a particular surface.
	 * @param	Direction	Any of the collision flags (e.g. LEFT, FLOOR, etc).
	 * @return	Whether the object is touching an object in (any of) the specified direction(s) this frame.</haxe_doc>
		</isTouching>
		<reset public="1" set="method" line="1022">
			<f a="X:Y">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Handy function for reviving game objects.
	 * Resets their existence flags and position.
	 * @param	X	The new X position of this object.
	 * @param	Y	The new Y position of this object.</haxe_doc>
		</reset>
		<getMidpoint public="1" get="inline" set="null" line="1005">
			<f a="?point">
				<c path="org.flixel.FlxPoint"/>
				<c path="org.flixel.FlxPoint"/>
			</f>
			<haxe_doc><![CDATA[* Retrieve the midpoint of this object in world coordinates.
	 * @Point	Allows you to pass in an existing <code>FlxPoint</code> object if you're so inclined.  Otherwise a new one is created.
	 * @return	A <code>FlxPoint</code> object containing the midpoint of this object in world coordinates.]]></haxe_doc>
		</getMidpoint>
		<setSolid set="method" line="987">
			<f a="Solid">
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</setSolid>
		<getSolid set="method" line="979">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Whether the object collides or not.  For more control over what directions
	 * the object will collide from, use collision constants (like LEFT, FLOOR, etc)
	 * to set the value of allowCollisions directly.</haxe_doc>
		</getSolid>
		<solid public="1" get="getSolid" set="setSolid"><e path="Bool"/></solid>
		<getFlickering set="method" line="967"><f a=""><e path="Bool"/></f></getFlickering>
		<flickering public="1" get="getFlickering" set="null">
			<e path="Bool"/>
			<haxe_doc>* Check to see if the object is still flickering.
	 * @return	Whether the object is flickering or not.</haxe_doc>
		</flickering>
		<flicker public="1" set="method" line="952">
			<f a="?Duration">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Tells this object to flicker, retro-style.
	 * Pass a negative value to flicker forever.
	 * @param	Duration	How many seconds to flicker for.</haxe_doc>
		</flicker>
		<getScreenXY public="1" get="inline" set="null" line="930">
			<f a="?point:?Camera">
				<c path="org.flixel.FlxPoint"/>
				<c path="org.flixel.FlxCamera"/>
				<c path="org.flixel.FlxPoint"/>
			</f>
			<haxe_doc><![CDATA[* Call this function to figure out the on-screen position of the object.
	 * @param	Camera		Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @param	Point		Takes a <code>FlxPoint</code> object and assigns the post-scrolled X and Y values of this object to it.
	 * @return	The <code>Point</code> you passed in, or a new <code>Point</code> if you didn't pass one, containing the screen X and Y position of this object.]]></haxe_doc>
		</getScreenXY>
		<onScreenObject get="inline" set="null" line="914"><f a="?Camera">
	<c path="org.flixel.FlxCamera"/>
	<e path="Bool"/>
</f></onScreenObject>
		<onScreen public="1" set="method" line="909">
			<f a="?Camera">
				<c path="org.flixel.FlxCamera"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Check and see if this object is currently on screen.
	 * @param	Camera		Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether the object is on screen or not.</haxe_doc>
		</onScreen>
		<overlapsPoint public="1" set="method" line="887">
			<f a="point:?InScreenSpace:?Camera">
				<c path="org.flixel.FlxPoint"/>
				<e path="Bool"/>
				<c path="org.flixel.FlxCamera"/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Checks to see if a point in 2D world space overlaps this <code>FlxObject</code> object.
	 * @param	Point			The point in world space you want to check.
	 * @param	InScreenSpace	Whether to take scroll factors into account when checking for overlap.
	 * @param	Camera			Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether or not the point overlaps this object.]]></haxe_doc>
		</overlapsPoint>
		<overlapsAt public="1" set="method" line="831">
			<f a="X:Y:ObjectOrGroup:?InScreenSpace:?Camera">
				<c path="Float"/>
				<c path="Float"/>
				<c path="org.flixel.FlxBasic"/>
				<e path="Bool"/>
				<c path="org.flixel.FlxCamera"/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Checks to see if this <code>FlxObject</code> were located at the given position, would it overlap the <code>FlxObject</code> or <code>FlxGroup</code>?
	 * This is distinct from overlapsPoint(), which just checks that point, rather than taking the object's size into account.
	 * WARNING: Currently tilemaps do NOT support screen space overlap checks!
	 * @param	X				The X position you want to check.  Pretends this object (the caller, not the parameter) is located here.
	 * @param	Y				The Y position you want to check.  Pretends this object (the caller, not the parameter) is located here.
	 * @param	ObjectOrGroup	The object or group being tested.
	 * @param	InScreenSpace	Whether to take scroll factors into account when checking for overlap.  Default is false, or "only compare in world space."
	 * @param	Camera			Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether or not the two objects overlap.]]></haxe_doc>
		</overlapsAt>
		<overlaps public="1" set="method" line="778">
			<f a="ObjectOrGroup:?InScreenSpace:?Camera">
				<c path="org.flixel.FlxBasic"/>
				<e path="Bool"/>
				<c path="org.flixel.FlxCamera"/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Checks to see if some <code>FlxObject</code> overlaps this <code>FlxObject</code> or <code>FlxGroup</code>.
	 * If the group has a LOT of things in it, it might be faster to use <code>FlxG.overlaps()</code>.
	 * WARNING: Currently tilemaps do NOT support screen space overlap checks!
	 * @param	ObjectOrGroup	The object or group being tested.
	 * @param	InScreenSpace	Whether to take scroll factors into account when checking for overlap.  Default is false, or "only compare in world space."
	 * @param	Camera			Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether or not the two objects overlap.]]></haxe_doc>
		</overlaps>
		<updatePathMotion get="inline" set="null" line="681">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Internal function for moving the object along the path.
	 * Generally this function is called automatically by <code>preUpdate()</code>.
	 * The first half of the function decides if the object can advance to the next node in the path,
	 * while the second half handles actually picking a velocity toward the next node.]]></haxe_doc>
		</updatePathMotion>
		<advancePath set="method" line="589">
			<f a="?Snap">
				<e path="Bool"/>
				<c path="org.flixel.FlxPoint"/>
			</f>
			<haxe_doc><![CDATA[* Internal function that decides what node in the path to aim for next based on the behavior flags.
	 * @return	The node (a <code>FlxPoint</code> object) we are aiming for next.]]></haxe_doc>
		</advancePath>
		<stopFollowingPath public="1" set="method" line="572">
			<f a="?DestroyPath">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Tells this object to stop following the path its on.
	 * @param	DestroyPath		Tells this function whether to call destroy on the path object.  Default value is false.</haxe_doc>
		</stopFollowingPath>
		<followPath public="1" set="method" line="542">
			<f a="Path:?Speed:?Mode:?AutoRotate">
				<c path="org.flixel.FlxPath"/>
				<c path="Float"/>
				<c path="Int"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Call this function to give this object a path to follow.
	 * If the path does not have at least one node in it, this function
	 * will log a warning message and return.
	 * @param	Path		The <code>FlxPath</code> you want this object to follow.
	 * @param	Speed		How fast to travel along the path in pixels per second.
	 * @param	Mode		Optional, controls the behavior of the object following the path using the path behavior constants.  Can use multiple flags at once, for example PATH_YOYO|PATH_HORIZONTAL_ONLY will make an object move back and forth along the X axis of the path only.
	 * @param	AutoRotate	Automatically point the object toward the next node.  Assumes the graphic is pointing upward.  Default behavior is false, or no automatic rotation.]]></haxe_doc>
		</followPath>
		<drawDebug public="1" set="method" line="461" override="1">
			<f a="?Camera">
				<c path="org.flixel.FlxCamera"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Override this function to draw custom "debug mode" graphics to the
	 * specified camera while the debugger's visual mode is toggled on.
	 * 
	 * @param	Camera	Which camera to draw the debug visuals to.</haxe_doc>
		</drawDebug>
		<draw public="1" set="method" line="431" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Rarely called, and in this case just increments the visible objects count and calls <code>drawDebug()</code> if necessary.]]></haxe_doc>
		</draw>
		<updateMotion get="inline" set="null" line="403">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Internal function for updating the position and speed of this object.
	 * Useful for cases when you need to update this but are buried down in too many supers.
	 * Does a slightly fancier-than-normal integration to help with higher fidelity framerate-independenct motion.</haxe_doc>
		</updateMotion>
		<postUpdate public="1" set="method" line="387" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Post-update is called right after <code>update()</code> on each object in the game loop.
	 * In <code>FlxObject</code> this function handles integrating the objects motion
	 * based on the velocity and acceleration settings, and tracking/clearing the <code>touching</code> flags.]]></haxe_doc>
		</postUpdate>
		<preUpdate public="1" set="method" line="359" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Pre-update is called right before <code>update()</code> on each object in the game loop.
	 * In <code>FlxObject</code> it controls the flicker timer,
	 * tracking the last coordinates for collision purposes,
	 * and checking if the object is moving along a path or not.]]></haxe_doc>
		</preUpdate>
		<destroy public="1" set="method" line="334" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Override this function to null out variables or
	 * manually call destroy() on class members if necessary.
	 * Don't forget to call super.destroy()!</haxe_doc>
		</destroy>
		<onBoundingBoxColorSet set="method" line="270"><f a="val">
	<c path="Int"/>
	<c path="Int"/>
</f></onBoundingBoxColorSet>
		<_boundingBoxColorOverritten><e path="Bool"/></_boundingBoxColorOverritten>
		<debugBoundingBoxColor public="1" set="onBoundingBoxColorSet">
			<t path="UInt"/>
			<haxe_doc>* Overriding this will force a specific color to be used for debug rect.</haxe_doc>
		</debugBoundingBoxColor>
		<_pathRotate>
			<e path="Bool"/>
			<haxe_doc>* Internal flag for whether the object's angle should be adjusted to the path angle during path follow behavior.</haxe_doc>
		</_pathRotate>
		<_pathInc>
			<c path="Int"/>
			<haxe_doc>* Internal helper for node navigation, specifically yo-yo and backwards movement.</haxe_doc>
		</_pathInc>
		<_pathMode>
			<c path="Int"/>
			<haxe_doc>* Internal tracker for path behavior flags (like looping, horizontal only, etc).</haxe_doc>
		</_pathMode>
		<_pathNodeIndex>
			<c path="Int"/>
			<haxe_doc>* Internal helper, tracks which node of the path this object is moving toward.</haxe_doc>
		</_pathNodeIndex>
		<pathAngle public="1">
			<c path="Float"/>
			<haxe_doc>* The angle in degrees between this object and the next node, where 0 is directly upward, and 90 is to the right.</haxe_doc>
		</pathAngle>
		<pathSpeed public="1">
			<c path="Float"/>
			<haxe_doc><![CDATA[* The speed at which the object is moving on the path.
	 * When an object completes a non-looping path circuit,
	 * the pathSpeed will be zeroed out, but the <code>path</code> reference
	 * will NOT be nulled out.  So <code>pathSpeed</code> is a good way
	 * to check if this object is currently following a path or not.]]></haxe_doc>
		</pathSpeed>
		<path public="1">
			<c path="org.flixel.FlxPath"/>
			<haxe_doc><![CDATA[* A reference to a path object.  Null by default, assigned by <code>followPath()</code>.]]></haxe_doc>
		</path>
		<last public="1">
			<c path="org.flixel.FlxPoint"/>
			<haxe_doc><![CDATA[* Important variable for collision processing.
	 * By default this value is set automatically during <code>preUpdate()</code>.]]></haxe_doc>
		</last>
		<allowCollisions public="1">
			<c path="Int"/>
			<haxe_doc>* Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating collision directions.
	 * Use bitwise operators to check the values stored here.
	 * Useful for things like one-way platforms (e.g. allowCollisions = UP;)
	 * The accessor "solid" just flips this variable between NONE and ANY.</haxe_doc>
		</allowCollisions>
		<wasTouching public="1">
			<c path="Int"/>
			<haxe_doc>* Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating surface contacts from the previous game loop step.
	 * Use bitwise operators to check the values stored here, or use touching(), justStartedTouching(), etc.
	 * You can even use them broadly as boolean values if you're feeling saucy!</haxe_doc>
		</wasTouching>
		<touching public="1">
			<c path="Int"/>
			<haxe_doc>* Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating surface contacts.
	 * Use bitwise operators to check the values stored here, or use touching(), justStartedTouching(), etc.
	 * You can even use them broadly as boolean values if you're feeling saucy!</haxe_doc>
		</touching>
		<moves public="1">
			<e path="Bool"/>
			<haxe_doc><![CDATA[* Set this to false if you want to skip the automatic motion/movement stuff (see <code>updateMotion()</code>).
	 * FlxObject and FlxSprite default to true.
	 * FlxText, FlxTileblock and FlxTilemap default to false.]]></haxe_doc>
		</moves>
		<_rect public="1">
			<c path="org.flixel.FlxRect"/>
			<haxe_doc>* This is just a pre-allocated rectangle container to be used however you like</haxe_doc>
		</_rect>
		<_point public="1">
			<c path="org.flixel.FlxPoint"/>
			<haxe_doc>* This is just a pre-allocated x-y point container to be used however you like</haxe_doc>
		</_point>
		<health public="1">
			<c path="Float"/>
			<haxe_doc>* Handy for storing health percentage or armor points or whatever.</haxe_doc>
		</health>
		<_flickerTimer>
			<c path="Float"/>
			<haxe_doc>* Internal helper used for retro-style flickering.</haxe_doc>
		</_flickerTimer>
		<_flicker>
			<e path="Bool"/>
			<haxe_doc>* Internal helper used for retro-style flickering.</haxe_doc>
		</_flicker>
		<scrollFactor public="1">
			<c path="org.flixel.FlxPoint"/>
			<haxe_doc>* A point that can store numbers from 0 to 1 (for X and Y independently)
	 * that governs how much this object is affected by the camera subsystem.
	 * 0 means it never moves, like a HUD element or far background graphic.
	 * 1 means it scrolls along a the same speed as the foreground layer.
	 * scrollFactor is initialized as (1,1) by default.</haxe_doc>
		</scrollFactor>
		<maxAngular public="1">
			<c path="Float"/>
			<haxe_doc><![CDATA[* Use in conjunction with <code>angularAcceleration</code> for fluid spin speed control.]]></haxe_doc>
		</maxAngular>
		<angularDrag public="1">
			<c path="Float"/>
			<haxe_doc><![CDATA[* Like <code>drag</code> but for spinning.]]></haxe_doc>
		</angularDrag>
		<angularAcceleration public="1">
			<c path="Float"/>
			<haxe_doc>* How fast the spin speed should change.</haxe_doc>
		</angularAcceleration>
		<angularVelocity public="1">
			<c path="Float"/>
			<haxe_doc>* This is how fast you want this sprite to spin.</haxe_doc>
		</angularVelocity>
		<angle public="1">
			<c path="Float"/>
			<haxe_doc>* Set the angle of a sprite to rotate it.
	 * WARNING: rotating sprites decreases rendering
	 * performance for this sprite by a factor of 10x!</haxe_doc>
		</angle>
		<maxVelocity public="1">
			<c path="org.flixel.FlxPoint"/>
			<haxe_doc><![CDATA[* If you are using <code>acceleration</code>, you can use <code>maxVelocity</code> with it
	 * to cap the speed automatically (very useful!).]]></haxe_doc>
		</maxVelocity>
		<drag public="1">
			<c path="org.flixel.FlxPoint"/>
			<haxe_doc>* This isn't drag exactly, more like deceleration that is only applied
	 * when acceleration is not affecting the sprite.</haxe_doc>
		</drag>
		<acceleration public="1">
			<c path="org.flixel.FlxPoint"/>
			<haxe_doc>* How fast the speed of this object is changing.
	 * Useful for smooth movement and gravity.</haxe_doc>
		</acceleration>
		<elasticity public="1">
			<c path="Float"/>
			<haxe_doc>* The bounciness of this object.  Only affects collisions.  Default value is 0, or "not bouncy at all."</haxe_doc>
		</elasticity>
		<mass public="1">
			<c path="Float"/>
			<haxe_doc><![CDATA[* The virtual mass of the object. Default value is 1.
	 * Currently only used with <code>elasticity</code> during collision resolution.
	 * Change at your own risk; effects seem crazy unpredictable so far!]]></haxe_doc>
		</mass>
		<velocity public="1">
			<c path="org.flixel.FlxPoint"/>
			<haxe_doc>* The basic speed of this object.</haxe_doc>
		</velocity>
		<immovable public="1">
			<e path="Bool"/>
			<haxe_doc>* Whether an object will move/alter position after a collision.</haxe_doc>
		</immovable>
		<height public="1">
			<c path="Float"/>
			<haxe_doc>* The height of this object.</haxe_doc>
		</height>
		<width public="1">
			<c path="Float"/>
			<haxe_doc>* The width of this object.</haxe_doc>
		</width>
		<y public="1">
			<c path="Float"/>
			<haxe_doc>* Y position of the upper left corner of this object in world space.</haxe_doc>
		</y>
		<x public="1">
			<c path="Float"/>
			<haxe_doc>* X position of the upper left corner of this object in world space.</haxe_doc>
		</x>
		<new public="1" set="method" line="285">
			<f a="?X:?Y:?Width:?Height">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Instantiates a <code>FlxObject</code>.
	 * 
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.
	 * @param	Width	Desired width of the rectangle.
	 * @param	Height	Desired height of the rectangle.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* This is the base class for most of the display objects (<code>FlxSprite</code>, <code>FlxText</code>, etc).
 * It includes some basic attributes about game objects, including retro-style flickering,
 * basic state information, sizes, scrolling, and basic physics and motion.]]></haxe_doc>
	</class>
	<class path="org.flixel.FlxSprite" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/FlxSprite.hx">
		<extends path="org.flixel.FlxObject"/>
		<overlapsPoint public="1" set="method" line="1663" override="1"><f a="point:?InScreenSpace:?Camera">
	<c path="org.flixel.FlxPoint"/>
	<e path="Bool"/>
	<c path="org.flixel.FlxCamera"/>
	<e path="Bool"/>
</f></overlapsPoint>
		<updateFrameData public="1" set="method" line="1625" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Use this method for creating tileSheet for FlxSprite. Must be called after makeGraphic(), loadGraphic or loadRotatedGraphic().
	 * If you forget to call it then you will not see this FlxSprite on c++ target</haxe_doc>
		</updateFrameData>
		<simpleRenderSprite get="inline" set="null" line="1587"><f a=""><e path="Bool"/></f></simpleRenderSprite>
		<getSimpleRender set="method" line="1582"><f a=""><e path="Bool"/></f></getSimpleRender>
		<simpleRender public="1" get="getSimpleRender" set="null">
			<e path="Bool"/>
			<haxe_doc>* If the Sprite is beeing rendered in simple mode.</haxe_doc>
		</simpleRender>
		<bakedRotation public="1" set="null">
			<c path="Float"/>
			<haxe_doc>* How many frames of "baked" rotation there are (if any).</haxe_doc>
		</bakedRotation>
		<flipped public="1" set="null">
			<c path="Int"/>
			<haxe_doc>* If the Sprite is flipped.</haxe_doc>
		</flipped>
		<setAntialiasing set="method" line="1558"><f a="val">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setAntialiasing>
		<antialiasing public="1" set="setAntialiasing">
			<e path="Bool"/>
			<haxe_doc>* Controls whether the object is smoothed when rotated, affects performance.
	 * @default false</haxe_doc>
		</antialiasing>
		<calcFrame set="method" line="1466">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Internal function to update the current animation frame.</haxe_doc>
		</calcFrame>
		<pixelsOverlapPoint public="1" set="method" line="1401">
			<f a="point:?Mask:?Camera">
				<c path="org.flixel.FlxPoint"/>
				<t path="UInt"/>
				<c path="org.flixel.FlxCamera"/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Checks to see if a point in 2D world space overlaps this <code>FlxSprite</code> object's current displayed pixels.
	 * This check is ALWAYS made in screen space, and always takes scroll factors into account.
	 * @param	Point		The point in world space you want to check.
	 * @param	Mask		Used in the pixel hit test to determine what counts as solid.
	 * @param	Camera		Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether or not the point overlaps this object.]]></haxe_doc>
		</pixelsOverlapPoint>
		<onScreenSprite get="inline" set="null" line="1358"><f a="?Camera">
	<c path="org.flixel.FlxCamera"/>
	<e path="Bool"/>
</f></onScreenSprite>
		<onScreen public="1" set="method" line="1353" override="1">
			<f a="?Camera">
				<c path="org.flixel.FlxCamera"/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Check and see if this object is currently on screen.
	 * Differs from <code>FlxObject</code>'s implementation
	 * in that it takes the actual graphic into account,
	 * not just the hitbox or bounding box or whatever.
	 * @param	Camera		Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether the object is on screen or not.]]></haxe_doc>
		</onScreen>
		<setFrame public="1" set="method" line="1328">
			<f a="Frame">
				<t path="UInt"/>
				<t path="UInt"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</setFrame>
		<getFrame public="1" set="method" line="1316">
			<f a=""><t path="UInt"/></f>
			<haxe_doc>* Tell the sprite to change to a specific frame of animation.
	 * 
	 * @param	Frame	The frame you want to display.</haxe_doc>
		</getFrame>
		<setColor public="1" set="method" line="1255">
			<f a="Color">
				<t path="UInt"/>
				<t path="UInt"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</setColor>
		<getColor public="1" set="method" line="1243">
			<f a=""><t path="UInt"/></f>
			<haxe_doc><![CDATA[* Set <code>color</code> to a number in this format: 0xRRGGBB.
	 * <code>color</code> IGNORES ALPHA.  To change the opacity use <code>alpha</code>.
	 * Tints the whole sprite to be this color (similar to OpenGL vertex colors).]]></haxe_doc>
		</getColor>
		<setAlpha set="method" line="1208">
			<f a="Alpha">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</setAlpha>
		<alpha public="1" set="setAlpha">
			<c path="Float"/>
			<haxe_doc><![CDATA[* Set <code>alpha</code> to a number between 0 and 1 to change the opacity of the sprite.]]></haxe_doc>
		</alpha>
		<setFacing public="1" set="method" line="1190">
			<f a="Direction">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</setFacing>
		<setPixels public="1" set="method" line="1167">
			<f a="Pixels">
				<t path="nme.display.BitmapData"/>
				<t path="nme.display.BitmapData"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</setPixels>
		<getPixels public="1" set="method" line="1159">
			<f a=""><t path="nme.display.BitmapData"/></f>
			<haxe_doc><![CDATA[* Set <code>pixels</code> to any <code>BitmapData</code> object.
	 * Automatically adjust graphic size and render helpers.]]></haxe_doc>
		</getPixels>
		<pixels public="1" get="getPixels" set="setPixels"><t path="nme.display.BitmapData"/></pixels>
		<replaceColor public="1" set="method" line="1115"><f a="Color:NewColor:?FetchPositions">
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<c path="Array"><c path="org.flixel.FlxPoint"/></c>
</f></replaceColor>
		<centerOffsets public="1" set="method" line="1103">
			<f a="?AdjustPosition">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Helper function that adjusts the offset automatically to center the bounding box within the graphic.
	 * @param	AdjustPosition		Adjusts the actual X and Y position just once to match the offset change. Default is false.</haxe_doc>
		</centerOffsets>
		<setOriginToCorner public="1" set="method" line="1094">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Helper function that just sets origin to (0,0)</haxe_doc>
		</setOriginToCorner>
		<randomFrame public="1" set="method" line="1078">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Tell the sprite to change to a random frame of animation
	 * Useful for instantiating particles or other weird things.</haxe_doc>
		</randomFrame>
		<play public="1" set="method" line="1027">
			<f a="AnimName:?Force">
				<c path="String"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Plays an existing animation (e.g. "run").
	 * If you call an animation that is already playing it will be ignored.
	 * @param	AnimName	The string name of the animation you want to play.
	 * @param	Force		Whether to force the animation to restart.</haxe_doc>
		</play>
		<addAnimationCallback public="1" set="method" line="1013">
			<f a="AnimationCallback">
				<f a="::">
					<c path="String"/>
					<t path="UInt"/>
					<t path="UInt"/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>* Pass in a function to be called whenever this sprite's animation changes.
	 * @param	AnimationCallback		A function that has 3 parameters: a string name, a uint frame number, and a uint frame index.</haxe_doc>
		</addAnimationCallback>
		<addAnimation public="1" set="method" line="1003">
			<f a="Name:Frames:?FrameRate:?Looped">
				<c path="String"/>
				<c path="Array"><c path="Int"/></c>
				<c path="Int"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Adds a new animation to the sprite.
	 * @param	Name		What this animation should be called (e.g. "run").
	 * @param	Frames		An array of numbers indicating what frames to play in what order (e.g. 1, 2, 3).
	 * @param	FrameRate	The speed in frames per second that the animation should play at (e.g. 40 fps).
	 * @param	Looped		Whether or not the animation is looped or just plays once.</haxe_doc>
		</addAnimation>
		<drawFrame public="1" set="method" line="984">
			<f a="?Force">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Request (or force) that the sprite update the frame before rendering.
	 * Useful if you are doing procedural generation or other weirdness!
	 * @param	Force	Force the frame to redraw, even if its not flagged as necessary.</haxe_doc>
		</drawFrame>
		<updateAnimation set="method" line="912">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Internal function for updating the sprite's animation.
	 * Useful for cases when you need to update this but are buried down in too many supers.
	 * This function is called automatically by <code>FlxSprite.postUpdate()</code>.]]></haxe_doc>
		</updateAnimation>
		<fill public="1" set="method" line="889">
			<f a="Color">
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Fills this sprite's graphic with a specific color.
	 * @param	Color		The color with which to fill the graphic, format 0xAARRGGBB.</haxe_doc>
		</fill>
		<drawLine public="1" set="method" line="848">
			<f a="StartX:StartY:EndX:EndY:Color:?Thickness">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<t path="UInt"/>
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* This function draws a line on this sprite from position X1,Y1
	 * to position X2,Y2 with the specified color.
	 * @param	StartX		X coordinate of the line's start point.
	 * @param	StartY		Y coordinate of the line's start point.
	 * @param	EndX		X coordinate of the line's end point.
	 * @param	EndY		Y coordinate of the line's end point.
	 * @param	Color		The line's color.
	 * @param	Thickness	How thick the line is in pixels (default value is 1).</haxe_doc>
		</drawLine>
		<stamp public="1" set="method" line="794">
			<f a="Brush:?X:?Y">
				<c path="org.flixel.FlxSprite"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* This function draws or stamps one <code>FlxSprite</code> onto another.
	 * This function is NOT intended to replace <code>draw()</code>!
	 * @param	Brush		The image you want to use as a brush or stamp or pen or whatever.
	 * @param	X			The X coordinate of the brush's top left corner on this sprite.
	 * @param	Y			They Y coordinate of the brush's top left corner on this sprite.]]></haxe_doc>
		</stamp>
		<draw public="1" set="method" line="606" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Called by game loop, updates then blits or renders current frame of animation to the screen</haxe_doc>
		</draw>
		<postUpdate public="1" set="method" line="597" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Automatically called after update() by the game loop,
	 * this function just calls updateAnimation().</haxe_doc>
		</postUpdate>
		<resetHelpers set="method" line="554">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Resets some important variables for sprite optimization and rendering.</haxe_doc>
		</resetHelpers>
		<makeGraphic public="1" set="method" line="522">
			<f a="Width:Height:?Color:?Unique:?Key">
				<t path="UInt"/>
				<t path="UInt"/>
				<t path="UInt"/>
				<e path="Bool"/>
				<c path="String"/>
				<c path="org.flixel.FlxSprite"/>
			</f>
			<haxe_doc>* This function creates a flat colored square image dynamically.
	 * @param	Width		The width of the sprite you want to generate.
	 * @param	Height		The height of the sprite you want to generate.
	 * @param	Color		Specifies the color of the generated block.
	 * @param	Unique		Whether the graphic should be a unique instance in the graphics cache.  Default is false.
	 * @param	Key			Optional parameter - specify a string key to identify this graphic in the cache.  Trumps Unique flag.
	 * @return	This FlxSprite instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</makeGraphic>
		<loadRotatedGraphic public="1" set="method" line="380">
			<f a="Graphic:?Rotations:?Frame:?AntiAliasing:?AutoBuffer:?Key">
				<d/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="String"/>
				<c path="org.flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Create a pre-rotated sprite sheet from a simple sprite.
	 * This can make a huge difference in graphical performance!
	 * @param	Graphic			The image you want to rotate and stamp.
	 * @param	Rotations		The number of rotation frames the final sprite should have.  For small sprites this can be quite a large number (360 even) without any problems.
	 * @param	Frame			If the Graphic has a single row of square animation frames on it, you can specify which of the frames you want to use here.  Default is -1, or "use whole graphic."
	 * @param	AntiAliasing	Whether to use high quality rotations when creating the graphic.  Default is false.
	 * @param	AutoBuffer		Whether to automatically increase the image size to accomodate rotated corners.  Default is false.  Will create frames that are 150% larger on each axis than the original frame or graphic.
	 * @param	Key			Optional, set this parameter if you're loading BitmapData.
	 * @return	This FlxSprite instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</loadRotatedGraphic>
		<loadGraphic public="1" set="method" line="299">
			<f a="Graphic:?Animated:?Reverse:?Width:?Height:?Unique:?Key">
				<d/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
				<c path="String"/>
				<c path="org.flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Load an image from an embedded graphic file.
	 * @param	Graphic		The image you want to use.
	 * @param	Animated	Whether the Graphic parameter is a single sprite or a row of sprites.
	 * @param	Reverse		Whether you need this class to generate horizontally flipped versions of the animation frames.
	 * @param	Width		Optional, specify the width of your sprite (helps FlxSprite figure out what to do with non-square sprites or sprite sheets).
	 * @param	Height		Optional, specify the height of your sprite (helps FlxSprite figure out what to do with non-square sprites or sprite sheets).
	 * @param	Unique		Optional, whether the graphic should be a unique instance in the graphics cache.  Default is false.
	 * @param	Key			Optional, set this parameter if you're loading BitmapData.
	 * @return	This FlxSprite instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</loadGraphic>
		<destroy public="1" set="method" line="246" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_matrix>
			<t path="nme.geom.Matrix"/>
			<haxe_doc>* Internal, helps with animation, caching and drawing.</haxe_doc>
		</_matrix>
		<_colorTransform>
			<t path="nme.geom.ColorTransform"/>
			<haxe_doc>* Internal, helps with animation, caching and drawing.</haxe_doc>
		</_colorTransform>
		<_flashPointZero>
			<t path="nme.geom.Point"/>
			<haxe_doc>* Internal, reused frequently during drawing and animating. Always contains (0,0).</haxe_doc>
		</_flashPointZero>
		<_flashRect2>
			<t path="nme.geom.Rectangle"/>
			<haxe_doc>* Internal, reused frequently during drawing and animating.</haxe_doc>
		</_flashRect2>
		<_flashRect>
			<t path="nme.geom.Rectangle"/>
			<haxe_doc>* Internal, reused frequently during drawing and animating.</haxe_doc>
		</_flashRect>
		<_flashPoint>
			<t path="nme.geom.Point"/>
			<haxe_doc>* Internal, reused frequently during drawing and animating.</haxe_doc>
		</_flashPoint>
		<_pixels>
			<t path="nme.display.BitmapData"/>
			<haxe_doc>* Internal, stores the entire source graphic (not the current displayed animation frame), used with Flash getter/setter.</haxe_doc>
		</_pixels>
		<_color>
			<t path="UInt"/>
			<haxe_doc>* Internal tracker for color tint, used with Flash getter/setter.</haxe_doc>
		</_color>
		<_callback>
			<f a="::">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Internal tracker for the animation callback.  Default is null.
	 * If assigned, will be called each time the current frame changes.
	 * A function that has 3 parameters: a string name, a uint frame number, and a uint frame index.</haxe_doc>
		</_callback>
		<_frameTimer>
			<c path="Float"/>
			<haxe_doc>* Internal, used to time each frame of animation.</haxe_doc>
		</_frameTimer>
		<_curIndex>
			<c path="Int"/>
			<haxe_doc>* Internal, keeps track of the current index into the tile sheet based on animation or rotation.</haxe_doc>
		</_curIndex>
		<_curFrame>
			<c path="Int"/>
			<haxe_doc>* Internal, keeps track of the current frame of animation.
	 * This is NOT an index into the tile sheet, but the frame number in the animation object.</haxe_doc>
		</_curFrame>
		<_curAnim>
			<c path="org.flixel.system.FlxAnim"/>
			<haxe_doc>* Internal, keeps track of the current animation being played.</haxe_doc>
		</_curAnim>
		<_animations>
			<c path="Array"><c path="org.flixel.system.FlxAnim"/></c>
			<haxe_doc>* Internal, stores all the animations that were added to this sprite.</haxe_doc>
		</_animations>
		<dirty public="1">
			<e path="Bool"/>
			<haxe_doc>* Set this flag to true to force the sprite to update during the draw() call.
	 * NOTE: Rarely if ever necessary, most sprite operations will flip this flag automatically.</haxe_doc>
		</dirty>
		<framePixels public="1">
			<t path="nme.display.BitmapData"/>
			<haxe_doc><![CDATA[* The actual Flash <code>BitmapData</code> object representing the current display state of the sprite.]]></haxe_doc>
		</framePixels>
		<frames public="1">
			<c path="Int"/>
			<haxe_doc>* The total number of frames in this image.  WARNING: assumes each row in the sprite sheet is full!</haxe_doc>
		</frames>
		<frameHeight public="1">
			<c path="Int"/>
			<haxe_doc>* The height of the actual graphic or image being displayed (not necessarily the game object/bounding box).
	 * NOTE: Edit at your own risk!!  This is intended to be read-only.</haxe_doc>
		</frameHeight>
		<frameWidth public="1">
			<c path="Int"/>
			<haxe_doc>* The width of the actual graphic or image being displayed (not necessarily the game object/bounding box).
	 * NOTE: Edit at your own risk!!  This is intended to be read-only.</haxe_doc>
		</frameWidth>
		<paused public="1">
			<e path="Bool"/>
			<haxe_doc>* Whether the current animation gets updated or not.</haxe_doc>
		</paused>
		<finished public="1">
			<e path="Bool"/>
			<haxe_doc>* Whether the current animation has finished its first (or only) loop.</haxe_doc>
		</finished>
		<blend public="1">
			<t path="nme.display.BlendMode"/>
			<haxe_doc>* Blending modes, just like Photoshop or whatever.
	 * E.g. "multiply", "screen", etc.
	 * @default null</haxe_doc>
		</blend>
		<scale public="1">
			<c path="org.flixel.FlxPoint"/>
			<haxe_doc>* Change the size of your sprite's graphic.
	 * NOTE: Scale doesn't currently affect collisions automatically,
	 * you will need to adjust the width, height and offset manually.
	 * WARNING: scaling sprites decreases rendering performance for this sprite by a factor of 10x!</haxe_doc>
		</scale>
		<offset public="1">
			<c path="org.flixel.FlxPoint"/>
			<haxe_doc>* If you changed the size of your sprite object after loading or making the graphic,
	* you might need to offset the graphic away from the bound box to center it the way you want.</haxe_doc>
		</offset>
		<origin public="1">
			<c path="org.flixel.FlxPoint"/>
			<haxe_doc>* WARNING: The origin of the sprite will default to its center.
	 * If you change this, the visuals and the collisions will likely be
	 * pretty out-of-sync if you do any rotation.</haxe_doc>
		</origin>
		<frame public="1" get="getFrame" set="setFrame"><t path="UInt"/></frame>
		<color public="1" get="getColor" set="setColor"><t path="UInt"/></color>
		<facing public="1" set="setFacing">
			<c path="Int"/>
			<haxe_doc><![CDATA[* Set <code>facing</code> using <code>FlxSprite.LEFT</code>,<code>RIGHT</code>,
	 * <code>UP</code>, and <code>DOWN</code> to take advantage of
	 * flipped sprites and/or just track player orientation more easily.]]></haxe_doc>
		</facing>
		<new public="1" set="method" line="189">
			<f a="?X:?Y:?SimpleGraphic">
				<c path="Float"/>
				<c path="Float"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a white 8x8 square <code>FlxSprite</code> at the specified position.
	 * Optionally can load a simple, one-frame graphic instead.
	 * @param	X				The initial X position of the sprite.
	 * @param	Y				The initial Y position of the sprite.
	 * @param	SimpleGraphic	The graphic you want to display (OPTIONAL - for simple stuff only, do NOT use for animated images!).]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The main "game object" class, the sprite is a <code>FlxObject</code>
 * with a bunch of graphics options and abilities, like animation and stamping.]]></haxe_doc>
	</class>
	<class path="org.flixel.FlxButton" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/FlxButton.hx">
		<extends path="org.flixel.FlxSprite"/>
		<NORMAL public="1" get="inline" set="null" line="28" static="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[* Used with public variable <code>status</code>, means not highlighted or pressed.]]></haxe_doc>
		</NORMAL>
		<HIGHLIGHT public="1" get="inline" set="null" line="32" static="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[* Used with public variable <code>status</code>, means highlighted (usually from mouse over).]]></haxe_doc>
		</HIGHLIGHT>
		<PRESSED public="1" get="inline" set="null" line="36" static="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[* Used with public variable <code>status</code>, means pressed (usually from mouse click).]]></haxe_doc>
		</PRESSED>
		<onMouseUp set="method" line="478">
			<f a="event">
				<t path="nme.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Internal function for handling the actual callback call (for UI thread dependent calls like <code>FlxU.openURL()</code>).]]></haxe_doc>
		</onMouseUp>
		<setSounds public="1" set="method" line="455">
			<f a="?SoundOver:?SoundOverVolume:?SoundOut:?SoundOutVolume:?SoundDown:?SoundDownVolume:?SoundUp:?SoundUpVolume">
				<t path="nme.media.Sound"/>
				<c path="Float"/>
				<t path="nme.media.Sound"/>
				<c path="Float"/>
				<t path="nme.media.Sound"/>
				<c path="Float"/>
				<t path="nme.media.Sound"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set sounds to play during mouse-button interactions.
	 * These operations can be done manually as well, and the public
	 * sound variables can be used after this for more fine-tuning,
	 * such as positional audio, etc.
	 * @param SoundOver			What embedded sound effect to play when the mouse goes over the button. Default is null, or no sound.
	 * @param SoundOverVolume	How load the that sound should be.
	 * @param SoundOut			What embedded sound effect to play when the mouse leaves the button area. Default is null, or no sound.
	 * @param SoundOutVolume	How load the that sound should be.
	 * @param SoundDown			What embedded sound effect to play when the mouse presses the button down. Default is null, or no sound.
	 * @param SoundDownVolume	How load the that sound should be.
	 * @param SoundUp			What embedded sound effect to play when the mouse releases the button. Default is null, or no sound.
	 * @param SoundUpVolume		How load the that sound should be.</haxe_doc>
		</setSounds>
		<resetHelpers set="method" line="430" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Updates the size of the text field to match the button.</haxe_doc>
		</resetHelpers>
		<swapLayers public="1" set="method" line="403">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Helper function for changing draw order of button's background and label.</haxe_doc>
		</swapLayers>
		<makeGraphic public="1" set="method" line="379" override="1"><f a="Width:Height:?Color:?Unique:?Key">
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<c path="String"/>
	<c path="org.flixel.FlxSprite"/>
</f></makeGraphic>
		<draw public="1" set="method" line="368" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Just draws the button graphic and text label to the screen.</haxe_doc>
		</draw>
		<updateButtonStatus set="method" line="330"><f a="Point:Camera:JustPressed">
	<c path="org.flixel.FlxPoint"/>
	<c path="org.flixel.FlxCamera"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></updateButtonStatus>
		<updateButton set="method" line="254">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Basic button update logic</haxe_doc>
		</updateButton>
		<update public="1" set="method" line="228" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Called by the game loop automatically, handles mouseover and click detection.</haxe_doc>
		</update>
		<preUpdate public="1" set="method" line="196" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Since button uses its own mouse handler for thread reasons,
	 * we run a little pre-check here to make sure that we only add
	 * the mouse handler when it is actually safe to do so.</haxe_doc>
		</preUpdate>
		<destroy public="1" set="method" line="142" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Called by the game state when state is changed (if this object belongs to the state)</haxe_doc>
		</destroy>
		<loadGraphic public="1" set="method" line="132" override="1"><f a="Graphic:?Animated:?Reverse:?Width:?Height:?Unique:?Key">
	<d/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<c path="String"/>
	<c path="org.flixel.FlxSprite"/>
</f></loadGraphic>
		<_initialized>
			<e path="Bool"/>
			<haxe_doc>* Whether or not the button has initialized itself yet.</haxe_doc>
		</_initialized>
		<_pressed>
			<e path="Bool"/>
			<haxe_doc>* Tracks whether or not the button is currently pressed.</haxe_doc>
		</_pressed>
		<soundUp public="1">
			<c path="org.flixel.FlxSound"/>
			<haxe_doc>* Set this to play a sound when the button is released.
	 * We recommend using the helper function setSounds()!</haxe_doc>
		</soundUp>
		<soundDown public="1">
			<c path="org.flixel.FlxSound"/>
			<haxe_doc>* Set this to play a sound when the button is pressed down.
	 * We recommend using the helper function setSounds()!</haxe_doc>
		</soundDown>
		<soundOut public="1">
			<c path="org.flixel.FlxSound"/>
			<haxe_doc>* Set this to play a sound when the mouse leaves the button.
	 * We recommend using the helper function setSounds()!</haxe_doc>
		</soundOut>
		<soundOver public="1">
			<c path="org.flixel.FlxSound"/>
			<haxe_doc>* Set this to play a sound when the mouse goes over the button.
	 * We recommend using the helper function setSounds()!</haxe_doc>
		</soundOver>
		<status public="1">
			<c path="Int"/>
			<haxe_doc>* Shows the current state of the button.</haxe_doc>
		</status>
		<onOut public="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* This function is called when the mouse leaves the button area.</haxe_doc>
		</onOut>
		<onOver public="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* This function is called when the mouse goes over the button.</haxe_doc>
		</onOver>
		<onDown public="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* This function is called when the button is pressed down.</haxe_doc>
		</onDown>
		<onUp public="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* This function is called when the button is released.
	 * We recommend assigning your main button behavior to this function
	 * via the <code>FlxButton</code> constructor.]]></haxe_doc>
		</onUp>
		<labelOffset public="1">
			<c path="org.flixel.FlxPoint"/>
			<haxe_doc>* Controls the offset (from top left) of the text from the button.</haxe_doc>
		</labelOffset>
		<label public="1">
			<c path="org.flixel.FlxText"/>
			<haxe_doc>* The text that appears on the button.</haxe_doc>
		</label>
		<on public="1">
			<e path="Bool"/>
			<haxe_doc>* Use this to toggle checkbox-style behavior.</haxe_doc>
		</on>
		<new public="1" set="method" line="105">
			<f a="?X:?Y:?Label:?OnClick">
				<c path="Float"/>
				<c path="Float"/>
				<c path="String"/>
				<f a=""><e path="Void"/></f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new <code>FlxButton</code> object with a gray background
	 * and a callback function on the UI thread.
	 * @param	X			The X position of the button.
	 * @param	Y			The Y position of the button.
	 * @param	Label		The text that you want to appear on the button.
	 * @param	OnClick		The function to call whenever the button is clicked.]]></haxe_doc>
		</new>
		<haxe_doc>* A simple button class that calls a function when clicked by the mouse.</haxe_doc>
	</class>
	<class path="org.flixel.FlxCamera" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/FlxCamera.hx">
		<extends path="org.flixel.FlxBasic"/>
		<STYLE_LOCKON public="1" get="inline" set="null" line="22" static="1">
			<c path="Int"/>
			<haxe_doc>* Camera "follow" style preset: camera has no deadzone, just tracks the focus object directly.</haxe_doc>
		</STYLE_LOCKON>
		<STYLE_PLATFORMER public="1" get="inline" set="null" line="26" static="1">
			<c path="Int"/>
			<haxe_doc>* Camera "follow" style preset: camera deadzone is narrow but tall.</haxe_doc>
		</STYLE_PLATFORMER>
		<STYLE_TOPDOWN public="1" get="inline" set="null" line="30" static="1">
			<c path="Int"/>
			<haxe_doc>* Camera "follow" style preset: camera deadzone is a medium-size square around the focus object.</haxe_doc>
		</STYLE_TOPDOWN>
		<STYLE_TOPDOWN_TIGHT public="1" get="inline" set="null" line="34" static="1">
			<c path="Int"/>
			<haxe_doc>* Camera "follow" style preset: camera deadzone is a small square around the focus object.</haxe_doc>
		</STYLE_TOPDOWN_TIGHT>
		<STYLE_SCREEN_BY_SCREEN public="1" get="inline" set="null" line="38" static="1">
			<c path="Int"/>
			<haxe_doc>* Camera "follow" style preset: camera will move screenwise.</haxe_doc>
		</STYLE_SCREEN_BY_SCREEN>
		<STYLE_NO_DEAD_ZONE public="1" get="inline" set="null" line="42" static="1">
			<c path="Int"/>
			<haxe_doc>* Camera "follow" style preset: camera has no deadzone, just tracks the focus object directly and centers it.</haxe_doc>
		</STYLE_NO_DEAD_ZONE>
		<SHAKE_BOTH_AXES public="1" get="inline" set="null" line="46" static="1">
			<c path="Int"/>
			<haxe_doc>* Camera "shake" effect preset: shake camera on both the X and Y axes.</haxe_doc>
		</SHAKE_BOTH_AXES>
		<SHAKE_HORIZONTAL_ONLY public="1" get="inline" set="null" line="50" static="1">
			<c path="Int"/>
			<haxe_doc>* Camera "shake" effect preset: shake camera on the X axis only.</haxe_doc>
		</SHAKE_HORIZONTAL_ONLY>
		<SHAKE_VERTICAL_ONLY public="1" get="inline" set="null" line="54" static="1">
			<c path="Int"/>
			<haxe_doc>* Camera "shake" effect preset: shake camera on the Y axis only.</haxe_doc>
		</SHAKE_VERTICAL_ONLY>
		<defaultZoom public="1" static="1">
			<c path="Float"/>
			<haxe_doc>* While you can alter the zoom of each camera after the fact,
	 * this variable determines what value the camera will start at when created.</haxe_doc>
		</defaultZoom>
		<setHeight set="method" line="1128"><f a="val">
	<c path="Int"/>
	<c path="Int"/>
</f></setHeight>
		<setWidth set="method" line="1102"><f a="val">
	<c path="Int"/>
	<c path="Int"/>
</f></setWidth>
		<drawFX public="1" set="method" line="1033">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Internal helper function, handles the actual drawing of all the special effects.</haxe_doc>
		</drawFX>
		<fill public="1" set="method" line="984">
			<f a="Color:?BlendAlpha">
				<t path="UInt"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Fill the camera with the specified color.
	 * @param	Color		The color to fill with in 0xAARRGGBB hex format.
	 * @param	BlendAlpha	Whether to blend the alpha value or just wipe the previous contents.  Default is true.</haxe_doc>
		</fill>
		<getContainerSprite public="1" set="method" line="973">
			<f a=""><t path="nme.display.Sprite"/></f>
			<haxe_doc><![CDATA[* Fetches a reference to the Flash <code>Sprite</code> object
	 * that contains the camera display in the Flash display list.
	 * Uses include 3D projection, advanced display list modification, and more.
	 * NOTE: We don't recommend modifying this directly unless you are
	 * fairly experienced.  For simple changes to the camera display,
	 * like scaling, rotation, and color tinting, we recommend
	 * using the existing <code>FlxCamera</code> variables.
	 * @return	A Flash <code>Sprite</code> object containing the camera display.]]></haxe_doc>
		</getContainerSprite>
		<setScale public="1" set="method" line="953">
			<f a="X:Y">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</setScale>
		<getScale public="1" set="method" line="945">
			<f a=""><c path="org.flixel.FlxPoint"/></f>
			<haxe_doc>* The scale of the camera object, irrespective of zoom.
	 * Currently yields weird display results,
	 * since cameras aren't nested in an extra display object yet.</haxe_doc>
		</getScale>
		<setAntialiasing set="method" line="930">
			<f a="Antialiasing">
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</setAntialiasing>
		<antialiasing public="1" set="setAntialiasing">
			<e path="Bool"/>
			<haxe_doc>* Whether the camera display is smooth and filtered, or chunky and pixelated.
	 * Default behavior is chunky-style.</haxe_doc>
		</antialiasing>
		<setColor set="method" line="891">
			<f a="Color">
				<t path="UInt"/>
				<t path="UInt"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</setColor>
		<color public="1" set="setColor">
			<t path="UInt"/>
			<haxe_doc>* The color tint of the camera display.
	 * (Internal, help with color transforming the flash bitmap.)</haxe_doc>
		</color>
		<setAngle set="method" line="870"><f a="Angle">
	<c path="Float"/>
	<c path="Float"/>
</f></setAngle>
		<angle public="1" set="setAngle">
			<c path="Float"/>
			<haxe_doc>* The angle of the camera display (in degrees).
	 * Currently yields weird display results,
	 * since cameras aren't nested in an extra display object yet.</haxe_doc>
		</angle>
		<setAlpha set="method" line="852">
			<f a="Alpha">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</setAlpha>
		<alpha public="1" set="setAlpha">
			<c path="Float"/>
			<haxe_doc>* The alpha value of this camera display (a Number between 0.0 and 1.0).</haxe_doc>
		</alpha>
		<setZoom set="method" line="830">
			<f a="Zoom">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>* The zoom level of this camera. 1 = 1:1, 2 = 2x zoom, etc.
	 * Indicates how far the camera is zoomed in.</haxe_doc>
		</setZoom>
		<zoom public="1" set="setZoom"><c path="Float"/></zoom>
		<copyFrom public="1" set="method" line="791">
			<f a="Camera">
				<c path="org.flixel.FlxCamera"/>
				<c path="org.flixel.FlxCamera"/>
			</f>
			<haxe_doc><![CDATA[* Copy the bounds, focus object, and deadzone info from an existing camera.
	 * @param	Camera	The camera you want to copy from.
	 * @return	A reference to this <code>FlxCamera</code> object.]]></haxe_doc>
		</copyFrom>
		<stopFX public="1" set="method" line="777">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Just turns off all the camera effects instantly.</haxe_doc>
		</stopFX>
		<shake public="1" set="method" line="761">
			<f a="?Intensity:?Duration:?OnComplete:?Force:?Direction">
				<c path="Float"/>
				<c path="Float"/>
				<f a=""><e path="Void"/></f>
				<e path="Bool"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* A simple screen-shake effect.
	 * @param	Intensity	Percentage of screen size representing the maximum distance that the screen can move while shaking.
	 * @param	Duration	The length in seconds that the shaking effect should last.
	 * @param	OnComplete	A function you want to run when the shake effect finishes.
	 * @param	Force		Force the effect to reset (default = true, unlike flash() and fade()!).
	 * @param	Direction	Whether to shake on both axes, just up and down, or just side to side (use class constants SHAKE_BOTH_AXES, SHAKE_VERTICAL_ONLY, or SHAKE_HORIZONTAL_ONLY).</haxe_doc>
		</shake>
		<fade public="1" set="method" line="712">
			<f a="?Color:?Duration:?FadeIn:?OnComplete:?Force">
				<t path="UInt"/>
				<c path="Float"/>
				<e path="Bool"/>
				<f a=""><e path="Void"/></f>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* The screen is gradually filled with this color.
	 * @param	Color		The color you want to use.
	 * @param	Duration	How long it takes for the fade to finish.
	 * @param   FadeIn      True fades from a color, false fades to it.
	 * @param	OnComplete	A function you want to run when the fade finishes.
	 * @param	Force		Force the effect to reset.</haxe_doc>
		</fade>
		<flash public="1" set="method" line="672">
			<f a="?Color:?Duration:?OnComplete:?Force">
				<t path="UInt"/>
				<c path="Float"/>
				<f a=""><e path="Void"/></f>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* The screen is filled with this color and gradually returns to normal.
	 * @param	Color		The color you want to use.
	 * @param	Duration	How long it takes for the flash to fade.
	 * @param	OnComplete	A function you want to run when the flash finishes.
	 * @param	Force		Force the effect to reset.</haxe_doc>
		</flash>
		<setBounds public="1" set="method" line="650">
			<f a="?X:?Y:?Width:?Height:?UpdateWorld">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Specify the boundaries of the level or where the camera is allowed to move.
	 * @param	X				The smallest X value of your level (usually 0).
	 * @param	Y				The smallest Y value of your level (usually 0).
	 * @param	Width			The largest X value of your level (usually the level width).
	 * @param	Height			The largest Y value of your level (usually the level height).
	 * @param	UpdateWorld		Whether the global quad-tree's dimensions should be updated to match (default: false).</haxe_doc>
		</setBounds>
		<focusOn public="1" set="method" line="635">
			<f a="point">
				<c path="org.flixel.FlxPoint"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Move the camera focus to this location instantly.
	 * @param	Point		Where you want the camera to focus.</haxe_doc>
		</focusOn>
		<follow public="1" set="method" line="598">
			<f a="Target:?Style:?Offset">
				<c path="org.flixel.FlxObject"/>
				<c path="Int"/>
				<c path="org.flixel.FlxPoint"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Tells this camera object what <code>FlxObject</code> to track.
	 * @param	Target		The object you want the camera to track.  Set to null to not follow anything.
	 * @param	Style		Leverage one of the existing "deadzone" presets.  If you use a custom deadzone, ignore this parameter and manually specify the deadzone after calling <code>follow()</code>.
	 * @param  Offset    Offset the follow deadzone by a certain amount. Only applicable for STYLE_PLATFORMER and STYLE_LOCKON styles.]]></haxe_doc>
		</follow>
		<update public="1" set="method" line="414" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Updates the camera scroll as well as special effects like screen-shake or fades.</haxe_doc>
		</update>
		<destroy public="1" set="method" line="370" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_fxFadeIn>
			<e path="Bool"/>
			<haxe_doc>* Internal, used to control the "fade" special effect.</haxe_doc>
		</_fxFadeIn>
		<_fill>
			<t path="nme.display.BitmapData"/>
			<haxe_doc>* Internal helper variable for doing better wipes/fills between renders.</haxe_doc>
		</_fill>
		<_fxShakeDirection>
			<c path="Int"/>
			<haxe_doc>* Internal, used to control the "shake" special effect.</haxe_doc>
		</_fxShakeDirection>
		<_fxShakeOffset>
			<c path="org.flixel.FlxPoint"/>
			<haxe_doc>* Internal, used to control the "shake" special effect.</haxe_doc>
		</_fxShakeOffset>
		<_fxShakeComplete>
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Internal, used to control the "shake" special effect.</haxe_doc>
		</_fxShakeComplete>
		<_fxShakeDuration>
			<c path="Float"/>
			<haxe_doc>* Internal, used to control the "shake" special effect.</haxe_doc>
		</_fxShakeDuration>
		<_fxShakeIntensity>
			<c path="Float"/>
			<haxe_doc>* Internal, used to control the "shake" special effect.</haxe_doc>
		</_fxShakeIntensity>
		<_fxFadeAlpha>
			<c path="Float"/>
			<haxe_doc>* Internal, used to control the "fade" special effect.</haxe_doc>
		</_fxFadeAlpha>
		<_fxFadeComplete>
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Internal, used to control the "fade" special effect.</haxe_doc>
		</_fxFadeComplete>
		<_fxFadeDuration>
			<c path="Float"/>
			<haxe_doc>* Internal, used to control the "fade" special effect.</haxe_doc>
		</_fxFadeDuration>
		<_fxFadeColor>
			<t path="UInt"/>
			<haxe_doc>* Internal, used to control the "fade" special effect.</haxe_doc>
		</_fxFadeColor>
		<_fxFlashAlpha>
			<c path="Float"/>
			<haxe_doc>* Internal, used to control the "flash" special effect.</haxe_doc>
		</_fxFlashAlpha>
		<_fxFlashComplete>
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Internal, used to control the "flash" special effect.</haxe_doc>
		</_fxFlashComplete>
		<_fxFlashDuration>
			<c path="Float"/>
			<haxe_doc>* Internal, used to control the "flash" special effect.</haxe_doc>
		</_fxFlashDuration>
		<_fxFlashColor>
			<t path="UInt"/>
			<haxe_doc>* Internal, used to control the "flash" special effect.</haxe_doc>
		</_fxFlashColor>
		<_flashPoint>
			<t path="nme.geom.Point"/>
			<haxe_doc>* Internal, used to render buffer to screen space.</haxe_doc>
		</_flashPoint>
		<_flashRect>
			<t path="nme.geom.Rectangle"/>
			<haxe_doc>* Internal, used to render buffer to screen space.</haxe_doc>
		</_flashRect>
		<_flashOffsetY public="1">
			<c path="Float"/>
			<haxe_doc>* Internal, used to render buffer to screen space.</haxe_doc>
		</_flashOffsetY>
		<_flashOffsetX public="1">
			<c path="Float"/>
			<haxe_doc>* Internal, used to render buffer to screen space.</haxe_doc>
		</_flashOffsetX>
		<_flashSprite public="1">
			<t path="nme.display.Sprite"/>
			<haxe_doc>* Internal, used to render buffer to screen space.</haxe_doc>
		</_flashSprite>
		<_flashBitmap>
			<t path="nme.display.Bitmap"/>
			<haxe_doc>* Internal, used to render buffer to screen space.</haxe_doc>
		</_flashBitmap>
		<_point>
			<c path="org.flixel.FlxPoint"/>
			<haxe_doc>* Internal, to help avoid costly allocations.</haxe_doc>
		</_point>
		<screen public="1">
			<c path="org.flixel.FlxSprite"/>
			<haxe_doc><![CDATA[* Sometimes it's easier to just work with a <code>FlxSprite</code> than it is to work
	 * directly with the <code>BitmapData</code> buffer.  This sprite reference will
	 * allow you to do exactly that.]]></haxe_doc>
		</screen>
		<bgColor public="1">
			<t path="UInt"/>
			<haxe_doc>* The natural background color of the camera. Defaults to FlxG.bgColor.
	 * NOTE: can be transparent for crazy FX!</haxe_doc>
		</bgColor>
		<buffer public="1">
			<t path="nme.display.BitmapData"/>
			<haxe_doc>* The actual bitmap data of the camera display itself.</haxe_doc>
		</buffer>
		<scroll public="1">
			<c path="org.flixel.FlxPoint"/>
			<haxe_doc>* Stores the basic parallax scrolling values.</haxe_doc>
		</scroll>
		<bounds public="1">
			<c path="org.flixel.FlxRect"/>
			<haxe_doc>* The edges of the camera's range, i.e. where to stop scrolling.
	 * Measured in game pixels and world coordinates.</haxe_doc>
		</bounds>
		<deadzone public="1">
			<c path="org.flixel.FlxRect"/>
			<haxe_doc><![CDATA[* You can assign a "dead zone" to the camera in order to better control its movement.
	 * The camera will always keep the focus object inside the dead zone,
	 * unless it is bumping up against the bounds rectangle's edges.
	 * The deadzone's coordinates are measured from the camera's upper left corner in game pixels.
	 * For rapid prototyping, you can use the preset deadzones (e.g. <code>STYLE_PLATFORMER</code>) with <code>follow()</code>.]]></haxe_doc>
		</deadzone>
		<target public="1">
			<c path="org.flixel.FlxObject"/>
			<haxe_doc><![CDATA[* Tells the camera to follow this <code>FlxObject</code> object around.]]></haxe_doc>
		</target>
		<style public="1">
			<c path="Int"/>
			<haxe_doc>* Tells the camera to use this following style.</haxe_doc>
		</style>
		<height public="1" set="setHeight">
			<c path="Int"/>
			<haxe_doc>* How tall the camera display is, in game pixels.</haxe_doc>
		</height>
		<width public="1" set="setWidth">
			<c path="Int"/>
			<haxe_doc>* How wide the camera display is, in game pixels.</haxe_doc>
		</width>
		<y public="1">
			<c path="Float"/>
			<haxe_doc>* The Y position of this camera's display.  Zoom does NOT affect this number.
	 * Measured in pixels from the top of the flash window.</haxe_doc>
		</y>
		<x public="1">
			<c path="Float"/>
			<haxe_doc>* The X position of this camera's display.  Zoom does NOT affect this number.
	 * Measured in pixels from the left side of the flash window.</haxe_doc>
		</x>
		<new public="1" set="method" line="261">
			<f a="X:Y:Width:Height:?Zoom">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Instantiates a new camera at the specified location, with the specified size and zoom level.
	 * @param X			X location of the camera's display in pixels. Uses native, 1:1 resolution, ignores zoom.
	 * @param Y			Y location of the camera's display in pixels. Uses native, 1:1 resolution, ignores zoom.
	 * @param Width		The width of the camera display in pixels.
	 * @param Height	The height of the camera display in pixels.
	 * @param Zoom		The initial zoom level of the camera.  A zoom level of 2 will make all pixels display at 2x resolution.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The camera class is used to display the game's visuals in the Flash player.
 * By default one camera is created automatically, that is the same size as the Flash player.
 * You can add more cameras or even replace the main camera using utilities in <code>FlxG</code>.]]></haxe_doc>
	</class>
	<class path="org.flixel.FlxG" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/FlxG.hx">
		<maxTouchPoints public="1" line="51" static="1">
			<c path="Int"/>
			<haxe_doc>* The maximum number of concurrent touch points supported by the current device.</haxe_doc>
		</maxTouchPoints>
		<supportsTouchEvents public="1" line="56" static="1">
			<e path="Bool"/>
			<haxe_doc>* Indicates whether the current environment supports basic touch input, such as a single finger tap.</haxe_doc>
		</supportsTouchEvents>
		<touchManager public="1" static="1">
			<c path="org.flixel.system.input.TouchManager"/>
			<haxe_doc><![CDATA[* A reference to a <code>TouchManager</code> object. Useful for devices with multitouch support]]></haxe_doc>
		</touchManager>
		<tweener public="1" line="73" static="1">
			<c path="org.flixel.FlxBasic"/>
			<haxe_doc>* Global tweener for tweening between multiple worlds</haxe_doc>
		</tweener>
		<bgColor public="1" get="getBgColor" set="setBgColor" static="1"><c path="Int"/></bgColor>
		<flashFramerate public="1" get="getFlashFramerate" set="setFlashFramerate" static="1"><c path="Int"/></flashFramerate>
		<LIBRARY_NAME public="1" get="inline" set="null" line="89" static="1">
			<c path="String"/>
			<haxe_doc>* If you build and maintain your own version of flixel,
	 * you can give it your own name here.</haxe_doc>
		</LIBRARY_NAME>
		<LIBRARY_MAJOR_VERSION public="1" get="inline" set="null" line="95" static="1">
			<c path="String"/>
			<haxe_doc>* Assign a major version to your library.
	 * Appears before the decimal in the console.</haxe_doc>
		</LIBRARY_MAJOR_VERSION>
		<LIBRARY_MINOR_VERSION public="1" get="inline" set="null" line="101" static="1">
			<c path="String"/>
			<haxe_doc>* Assign a minor version to your library.
	 * Appears after the decimal in the console.</haxe_doc>
		</LIBRARY_MINOR_VERSION>
		<DEBUGGER_STANDARD public="1" get="inline" set="null" line="106" static="1">
			<c path="Int"/>
			<haxe_doc>* Debugger overlay layout preset: Wide but low windows at the bottom of the screen.</haxe_doc>
		</DEBUGGER_STANDARD>
		<DEBUGGER_MICRO public="1" get="inline" set="null" line="111" static="1">
			<c path="Int"/>
			<haxe_doc>* Debugger overlay layout preset: Tiny windows in the screen corners.</haxe_doc>
		</DEBUGGER_MICRO>
		<DEBUGGER_BIG public="1" get="inline" set="null" line="116" static="1">
			<c path="Int"/>
			<haxe_doc>* Debugger overlay layout preset: Large windows taking up bottom half of screen.</haxe_doc>
		</DEBUGGER_BIG>
		<DEBUGGER_TOP public="1" get="inline" set="null" line="121" static="1">
			<c path="Int"/>
			<haxe_doc>* Debugger overlay layout preset: Wide but low windows at the top of the screen.</haxe_doc>
		</DEBUGGER_TOP>
		<DEBUGGER_LEFT public="1" get="inline" set="null" line="126" static="1">
			<c path="Int"/>
			<haxe_doc>* Debugger overlay layout preset: Large windows taking up left third of screen.</haxe_doc>
		</DEBUGGER_LEFT>
		<DEBUGGER_RIGHT public="1" get="inline" set="null" line="131" static="1">
			<c path="Int"/>
			<haxe_doc>* Debugger overlay layout preset: Large windows taking up right third of screen.</haxe_doc>
		</DEBUGGER_RIGHT>
		<RED public="1" get="inline" set="null" line="141" static="1">
			<c path="Int"/>
			<haxe_doc>* Some handy color presets.  Less glaring than pure RGB full values.
	 * Primarily used in the visual debugger mode for bounding box displays.
	 * Red is used to indicate an active, movable, solid object.</haxe_doc>
		</RED>
		<GREEN public="1" get="inline" set="null" line="149" static="1">
			<c path="Int"/>
			<haxe_doc>* Green is used to indicate solid but immovable objects.</haxe_doc>
		</GREEN>
		<BLUE public="1" get="inline" set="null" line="157" static="1">
			<c path="Int"/>
			<haxe_doc>* Blue is used to indicate non-solid objects.</haxe_doc>
		</BLUE>
		<PINK public="1" get="inline" set="null" line="165" static="1">
			<c path="Int"/>
			<haxe_doc>* Pink is used to indicate objects that are only partially solid, like one-way platforms.</haxe_doc>
		</PINK>
		<WHITE public="1" get="inline" set="null" line="173" static="1">
			<c path="Int"/>
			<haxe_doc>* White... for white stuff.</haxe_doc>
		</WHITE>
		<BLACK public="1" get="inline" set="null" line="181" static="1">
			<c path="Int"/>
			<haxe_doc>* And black too.</haxe_doc>
		</BLACK>
		<_game public="1" static="1">
			<c path="org.flixel.FlxGame"/>
			<haxe_doc>* Internal tracker for game object.</haxe_doc>
		</_game>
		<paused public="1" static="1">
			<e path="Bool"/>
			<haxe_doc>* Handy shared variable for implementing your own pause behavior.</haxe_doc>
		</paused>
		<debug public="1" static="1">
			<e path="Bool"/>
			<haxe_doc><![CDATA[* Whether you are running in Debug or Release mode.
	 * Set automatically by <code>FlxPreloader</code> during startup.]]></haxe_doc>
		</debug>
		<elapsed public="1" static="1">
			<c path="Float"/>
			<haxe_doc>* Represents the amount of time in seconds that passed since last frame.</haxe_doc>
		</elapsed>
		<timeScale public="1" static="1">
			<c path="Float"/>
			<haxe_doc>* How fast or slow time should pass in the game; default is 1.0.</haxe_doc>
		</timeScale>
		<width public="1" static="1">
			<c path="Int"/>
			<haxe_doc>* The width of the screen in game pixels.</haxe_doc>
		</width>
		<height public="1" static="1">
			<c path="Int"/>
			<haxe_doc>* The height of the screen in game pixels.</haxe_doc>
		</height>
		<worldBounds public="1" static="1">
			<c path="org.flixel.FlxRect"/>
			<haxe_doc>* The dimensions of the game world, used by the quad tree for collisions and overlap checks.</haxe_doc>
		</worldBounds>
		<worldDivisions public="1" static="1">
			<c path="Int"/>
			<haxe_doc>* How many times the quad tree should divide the world on each axis.
	 * Generally, sparse collisions can have fewer divisons,
	 * while denser collision activity usually profits from more.
	 * Default value is 6.</haxe_doc>
		</worldDivisions>
		<visualDebug public="1" static="1">
			<e path="Bool"/>
			<haxe_doc>* Whether to show visual debug displays or not.
	 * Default = false.</haxe_doc>
		</visualDebug>
		<mobile public="1" static="1">
			<e path="Bool"/>
			<haxe_doc>* Setting this to true will disable/skip stuff that isn't necessary for mobile platforms like Android. [BETA]</haxe_doc>
		</mobile>
		<globalSeed public="1" static="1">
			<c path="Float"/>
			<haxe_doc>* The global random number generator seed (for deterministic behavior in recordings and saves).</haxe_doc>
		</globalSeed>
		<levels public="1" static="1">
			<c path="Array"><d/></c>
			<haxe_doc><![CDATA[* <code>FlxG.levels</code> and <code>FlxG.scores</code> are generic
	 * global variables that can be used for various cross-state stuff.]]></haxe_doc>
		</levels>
		<level public="1" static="1"><c path="Int"/></level>
		<scores public="1" static="1"><c path="Array"><d/></c></scores>
		<score public="1" static="1"><c path="Int"/></score>
		<saves public="1" static="1">
			<c path="Array"><d/></c>
			<haxe_doc><![CDATA[* <code>FlxG.saves</code> is a generic bucket for storing
	 * FlxSaves so you can access them whenever you want.]]></haxe_doc>
		</saves>
		<save public="1" static="1"><c path="Int"/></save>
		<mouse public="1" static="1">
			<c path="org.flixel.system.input.Mouse"/>
			<haxe_doc><![CDATA[* A reference to a <code>FlxMouse</code> object.  Important for input!]]></haxe_doc>
		</mouse>
		<keys public="1" static="1">
			<c path="org.flixel.system.input.Keyboard"/>
			<haxe_doc><![CDATA[* A reference to a <code>FlxKeyboard</code> object.  Important for input!]]></haxe_doc>
		</keys>
		<music public="1" static="1">
			<c path="org.flixel.FlxSound"/>
			<haxe_doc>* A handy container for a background music object.</haxe_doc>
		</music>
		<sounds public="1" static="1">
			<c path="org.flixel.FlxGroup"/>
			<haxe_doc>* A list of all the sounds being played in the game.</haxe_doc>
		</sounds>
		<mute public="1" static="1">
			<e path="Bool"/>
			<haxe_doc>* Whether or not the game sounds are muted.</haxe_doc>
		</mute>
		<cameras public="1" static="1">
			<c path="Array"><c path="org.flixel.FlxCamera"/></c>
			<haxe_doc><![CDATA[* An array of <code>FlxCamera</code> objects that are used to draw stuff.
	 * By default flixel creates one camera the size of the screen.]]></haxe_doc>
		</cameras>
		<camera public="1" static="1">
			<c path="org.flixel.FlxCamera"/>
			<haxe_doc>* By default this just refers to the first entry in the cameras array
	 * declared above, but you can do what you like with it.</haxe_doc>
		</camera>
		<useBufferLocking public="1" static="1">
			<e path="Bool"/>
			<haxe_doc><![CDATA[* Allows you to possibly slightly optimize the rendering process IF
	 * you are not doing any pre-processing in your game state's <code>draw()</code> call.
	 * @default false]]></haxe_doc>
		</useBufferLocking>
		<_cameraRect static="1">
			<t path="nme.geom.Rectangle"/>
			<haxe_doc>* Internal helper variable for clearing the cameras each frame.</haxe_doc>
		</_cameraRect>
		<plugins public="1" static="1">
			<c path="Array"><c path="org.flixel.FlxBasic"/></c>
			<haxe_doc>* An array container for plugins.
	 * By default flixel uses a couple of plugins:
	 * DebugPathDisplay, and TimerManager.</haxe_doc>
		</plugins>
		<volumeHandler public="1" static="1">
			<f a="">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Set this hook to get a callback whenever the volume changes.
	 * Function should take the form <code>myVolumeHandler(Volume:Number)</code>.]]></haxe_doc>
		</volumeHandler>
		<flashGfxSprite public="1" static="1">
			<t path="nme.display.Sprite"/>
			<haxe_doc>* Useful helper objects for doing Flash-specific rendering.
	 * Primarily used for "debug visuals" like drawing bounding boxes directly to the screen buffer.</haxe_doc>
		</flashGfxSprite>
		<flashGfx public="1" static="1"><t path="nme.display.Graphics"/></flashGfx>
		<_cache public="1" static="1">
			<c path="Hash"><t path="nme.display.BitmapData"/></c>
			<haxe_doc>* Internal storage system to prevent graphics from being used repeatedly in memory.</haxe_doc>
		</_cache>
		<_lastBitmapDataKey public="1" static="1"><c path="String"/></_lastBitmapDataKey>
		<getLibraryName public="1" set="method" line="322" static="1"><f a=""><c path="String"/></f></getLibraryName>
		<log public="1" set="method" line="331" static="1">
			<f a="Data">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Log data to the debugger.
	 * @param	Data		Anything you want to log to the console.</haxe_doc>
		</log>
		<watch public="1" set="method" line="346" static="1">
			<f a="AnyObject:VariableName:?DisplayName">
				<d/>
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Add a variable to the watch list in the debugger.
	 * This lets you see the value of the variable all the time.
	 * @param	AnyObject		A reference to any object in your game, e.g. Player or Robot or this.
	 * @param	VariableName	The name of the variable you want to watch, in quotes, as a string: e.g. "speed" or "health".
	 * @param	DisplayName		Optional, display your own string instead of the class name + variable name: e.g. "enemy count".</haxe_doc>
		</watch>
		<unwatch public="1" set="method" line="360" static="1">
			<f a="AnyObject:?VariableName">
				<d/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Remove a variable from the watch list in the debugger.
	 * Don't pass a Variable Name to remove all watched variables for the specified object.
	 * @param	AnyObject		A reference to any object in your game, e.g. Player or Robot or this.
	 * @param	VariableName	The name of the variable you want to watch, in quotes, as a string: e.g. "speed" or "health".</haxe_doc>
		</unwatch>
		<framerate public="1" get="getFramerate" set="setFramerate" static="1"><c path="Int"/></framerate>
		<getFramerate public="1" set="method" line="375" static="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* How many times you want your game to update each second.
	 * More updates usually means better collisions and smoother motion.
	 * NOTE: This is NOT the same thing as the Flash Player framerate!</haxe_doc>
		</getFramerate>
		<setFramerate public="1" set="method" line="383" static="1">
			<f a="Framerate">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</setFramerate>
		<getFlashFramerate public="1" set="method" line="399" static="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* How many times you want your game to update each second.
	 * More updates usually means better collisions and smoother motion.
	 * NOTE: This is NOT the same thing as the Flash Player framerate!</haxe_doc>
		</getFlashFramerate>
		<setFlashFramerate public="1" set="method" line="409" static="1">
			<f a="Framerate">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</setFlashFramerate>
		<fullscreen public="1" set="method" line="428" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Switch to full-screen display.</haxe_doc>
		</fullscreen>
		<random public="1" get="inline" set="null" line="443" static="1">
			<f a=""><c path="Float"/></f>
			<haxe_doc><![CDATA[* Generates a random number.  Deterministic, meaning safe
	 * to use if you want to record replays in random environments.
	 * @return	A <code>Number</code> between 0 and 1.]]></haxe_doc>
		</random>
		<shuffle public="1" get="inline" set="null" line="458" static="1">
			<f a="Objects:HowManyTimes">
				<c path="Array"><d/></c>
				<c path="Int"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc><![CDATA[* Shuffles the entries in an array into a new random order.
	 * <code>FlxG.shuffle()</code> is deterministic and safe for use with replays/recordings.
	 * HOWEVER, <code>FlxU.shuffle()</code> is NOT deterministic and unsafe for use with replays/recordings.
	 * @param	A				A Flash <code>Array</code> object containing...stuff.
	 * @param	HowManyTimes	How many swaps to perform during the shuffle operation.  Good rule of thumb is 2-4 times as many objects are in the list.
	 * @return	The same Flash <code>Array</code> object that you passed in in the first place.]]></haxe_doc>
		</shuffle>
		<getRandom public="1" set="method" line="487" static="1">
			<f a="Objects:?StartIndex:?Length">
				<c path="Array"><d/></c>
				<c path="Int"/>
				<c path="Int"/>
				<d/>
			</f>
			<haxe_doc><![CDATA[* Fetch a random entry from the given array.
	 * Will return null if random selection is missing, or array has no entries.
	 * <code>FlxG.getRandom()</code> is deterministic and safe for use with replays/recordings.
	 * HOWEVER, <code>FlxU.getRandom()</code> is NOT deterministic and unsafe for use with replays/recordings.
	 * @param	Objects		A Flash array of objects.
	 * @param	StartIndex	Optional offset off the front of the array. Default value is 0, or the beginning of the array.
	 * @param	Length		Optional restriction on the number of values you want to randomly select from.
	 * @return	The random object that was selected.]]></haxe_doc>
		</getRandom>
		<loadReplay public="1" set="method" line="515" static="1">
			<f a="Data:?State:?CancelKeys:?Timeout:?Callback">
				<c path="String"/>
				<c path="org.flixel.FlxState"/>
				<c path="Array"><c path="String"/></c>
				<c path="Float"/>
				<f a=""><e path="Void"/></f>
				<e path="Void"/>
			</f>
			<haxe_doc>* Load replay data from a string and play it back.
	 * @param	Data		The replay that you want to load.
	 * @param	State		Optional parameter: if you recorded a state-specific demo or cutscene, pass a new instance of that state here.
	 * @param	CancelKeys	Optional parameter: an array of string names of keys (see FlxKeyboard) that can be pressed to cancel the playback, e.g. ["ESCAPE","ENTER"].  Also accepts 2 custom key names: "ANY" and "MOUSE" (fairly self-explanatory I hope!).
	 * @param	Timeout		Optional parameter: set a time limit for the replay.  CancelKeys will override this if pressed.
	 * @param	Callback	Optional parameter: if set, called when the replay finishes.  Running to the end, CancelKeys, and Timeout will all trigger Callback(), but only once, and CancelKeys and Timeout will NOT call FlxG.stopReplay() if Callback is set!</haxe_doc>
		</loadReplay>
		<reloadReplay public="1" set="method" line="536" static="1">
			<f a="?StandardMode">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Resets the game or state and replay requested flag.
	 * @param	StandardMode	If true, reload entire game, else just reload current game state.</haxe_doc>
		</reloadReplay>
		<stopReplay public="1" set="method" line="555" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Stops the current replay.</haxe_doc>
		</stopReplay>
		<recordReplay public="1" set="method" line="569" static="1">
			<f a="?StandardMode">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Resets the game or state and requests a new recording.
	 * @param	StandardMode	If true, reset the entire game, else just reset the current state.</haxe_doc>
		</recordReplay>
		<stopRecording public="1" set="method" line="586" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc><![CDATA[* Stop recording the current replay and return the replay data.
	 * @return	The replay data in simple ASCII format (see <code>FlxReplay.save()</code>).]]></haxe_doc>
		</stopRecording>
		<resetState public="1" set="method" line="599" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Request a reset of the current game state.</haxe_doc>
		</resetState>
		<resetGame public="1" set="method" line="607" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Like hitting the reset button a game console, this will re-launch the game as if it just started.</haxe_doc>
		</resetGame>
		<resetInput public="1" set="method" line="615" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Reset the input helper objects (useful when changing screens or states)</haxe_doc>
		</resetInput>
		<playMusic public="1" set="method" line="631" static="1">
			<f a="Music:?Volume">
				<d/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set up and play a looping background soundtrack.
	 * @param	Music		The sound file you want to loop in the background.
	 * @param	Volume		How loud the sound should be, from 0 to 1.</haxe_doc>
		</playMusic>
		<loadSound public="1" set="method" line="657" static="1">
			<f a="?EmbeddedSound:?Volume:?Looped:?AutoDestroy:?AutoPlay:?URL">
				<d/>
				<c path="Float"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="String"/>
				<c path="org.flixel.FlxSound"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new sound object. 
	 * @param	EmbeddedSound	The embedded sound resource you want to play.  To stream, use the optional URL parameter instead.
	 * @param	Volume			How loud to play it (0 to 1).
	 * @param	Looped			Whether to loop this sound.
	 * @param	AutoDestroy		Whether to destroy this sound when it finishes playing.  Leave this value set to "false" if you want to re-use this <code>FlxSound</code> instance.
	 * @param	AutoPlay		Whether to play the sound.
	 * @param	URL				Load a sound from an external web resource instead.  Only used if EmbeddedSound = null.
	 * @return	A <code>FlxSound</code> object.]]></haxe_doc>
		</loadSound>
		<play public="1" set="method" line="730" static="1">
			<f a="EmbeddedSound:?Volume:?Looped:?AutoDestroy">
				<d/>
				<c path="Float"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="org.flixel.FlxSound"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new sound object from an embedded <code>Class</code> object.
	 * NOTE: Just calls FlxG.loadSound() with AutoPlay == true.
	 * @param	EmbeddedSound	The sound you want to play.
	 * @param	Volume			How loud to play it (0 to 1).
	 * @param	Looped			Whether to loop this sound.
	 * @param	AutoDestroy		Whether to destroy this sound when it finishes playing.  Leave this value set to "false" if you want to re-use this <code>FlxSound</code> instance.
	 * @return	A <code>FlxSound</code> object.]]></haxe_doc>
		</play>
		<stream public="1" set="method" line="745" static="1">
			<f a="URL:?Volume:?Looped:?AutoDestroy">
				<c path="String"/>
				<c path="Float"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="org.flixel.FlxSound"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new sound object from a URL.
	 * NOTE: Just calls FlxG.loadSound() with AutoPlay == true.
	 * @param	URL		The URL of the sound you want to play.
	 * @param	Volume	How loud to play it (0 to 1).
	 * @param	Looped	Whether or not to loop this sound.
	 * @param	AutoDestroy		Whether to destroy this sound when it finishes playing.  Leave this value set to "false" if you want to re-use this <code>FlxSound</code> instance.
	 * @return	A FlxSound object.]]></haxe_doc>
		</stream>
		<volume public="1" set="setVolume" static="1">
			<c path="Float"/>
			<haxe_doc><![CDATA[* 
	 * Set <code>volume</code> to a number between 0 and 1 to change the global volume.
	 * 
	 * @default 0.5]]></haxe_doc>
		</volume>
		<setVolume set="method" line="761" static="1">
			<f a="Volume">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</setVolume>
		<destroySounds public="1" set="method" line="786" static="1">
			<f a="?ForceDestroy">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Called by FlxGame on state changes to stop and destroy sounds.
	 * 
	 * @param	ForceDestroy		Kill sounds even if they're flagged <code>survive</code>.]]></haxe_doc>
		</destroySounds>
		<updateSounds public="1" set="method" line="816" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Called by the game loop to make sure the sounds get updated each frame.</haxe_doc>
		</updateSounds>
		<pauseSounds public="1" set="method" line="831" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Pause all sounds currently playing.</haxe_doc>
		</pauseSounds>
		<resumeSounds public="1" set="method" line="853" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Resume playing existing sounds.</haxe_doc>
		</resumeSounds>
		<checkBitmapCache public="1" set="method" line="877" static="1">
			<f a="Key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Check the local bitmap cache to see if a bitmap with this key has been loaded already.
	 * @param	Key		The string key identifying the bitmap.
	 * @return	Whether or not this file can be found in the cache.</haxe_doc>
		</checkBitmapCache>
		<createBitmap public="1" set="method" line="892" static="1">
			<f a="Width:Height:Color:?Unique:?Key">
				<t path="UInt"/>
				<t path="UInt"/>
				<t path="UInt"/>
				<e path="Bool"/>
				<c path="String"/>
				<t path="nme.display.BitmapData"/>
			</f>
			<haxe_doc><![CDATA[* Generates a new <code>BitmapData</code> object (a colored square) and caches it.
	 * @param	Width	How wide the square should be.
	 * @param	Height	How high the square should be.
	 * @param	Color	What color the square should be (0xAARRGGBB)
	 * @param	Unique	Ensures that the bitmap data uses a new slot in the cache.
	 * @param	Key		Force the cache to use a specific Key to index the bitmap.
	 * @return	The <code>BitmapData</code> we just created.]]></haxe_doc>
		</createBitmap>
		<addBitmap public="1" set="method" line="926" static="1">
			<f a="Graphic:?Reverse:?Unique:?Key:?FrameWidth:?FrameHeight">
				<d/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<t path="nme.display.BitmapData"/>
			</f>
			<haxe_doc><![CDATA[* Loads a bitmap from a file, caches it, and generates a horizontally flipped version if necessary.
	 * @param	Graphic		The image file that you want to load.
	 * @param	Reverse		Whether to generate a flipped version.
	 * @param	Unique		Ensures that the bitmap data uses a new slot in the cache.
	 * @param	Key			Force the cache to use a specific Key to index the bitmap.
	 * @return	The <code>BitmapData</code> we just created.]]></haxe_doc>
		</addBitmap>
		<getCacheKeyFor public="1" set="method" line="1057" static="1">
			<f a="bmd">
				<t path="nme.display.BitmapData"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets key from bitmap cache for specified bitmapdata
	 * @param	bmd	bitmapdata to find in cache
	 * @return	bitmapdata's key or null if there isn't such bitmapdata in cache</haxe_doc>
		</getCacheKeyFor>
		<getUniqueBitmapKey public="1" set="method" line="1075" static="1">
			<f a="?baseKey">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets unique key for bitmap cache
	 * @param	baseKey	key's prefix
	 * @return	unique key</haxe_doc>
		</getUniqueBitmapKey>
		<fromAssetsCache set="method" line="1090" static="1"><f a="bmd">
	<t path="nme.display.BitmapData"/>
	<e path="Bool"/>
</f></fromAssetsCache>
		<removeBitmap public="1" set="method" line="1111" static="1">
			<f a="Graphic">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Removes bitmapdata from cache
	 * @param	Graphic	bitmapdata's key to remove</haxe_doc>
		</removeBitmap>
		<clearBitmapCache public="1" set="method" line="1128" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Dumps the cache's image references.</haxe_doc>
		</clearBitmapCache>
		<clearAssetsCache public="1" set="method" line="1150" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clears nme.Assests.cachedBitmapData. Use it only when you need it and know what are you doing.</haxe_doc>
		</clearAssetsCache>
		<stage public="1" get="getStage" set="null" static="1"><t path="nme.display.Stage"/></stage>
		<getStage public="1" set="method" line="1166" static="1">
			<f a=""><t path="nme.display.Stage"/></f>
			<haxe_doc>* Read-only: retrieves the Flash stage object (required for event listeners)
	 * Will be null if it's not safe/useful yet.</haxe_doc>
		</getStage>
		<state public="1" get="getState" set="null" static="1"><c path="org.flixel.FlxState"/></state>
		<getState public="1" set="method" line="1180" static="1">
			<f a=""><c path="org.flixel.FlxState"/></f>
			<haxe_doc>* Read-only: access the current game state from anywhere.</haxe_doc>
		</getState>
		<switchState public="1" set="method" line="1188" static="1">
			<f a="State">
				<c path="org.flixel.FlxState"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Switch from the current game state to the one specified here.</haxe_doc>
		</switchState>
		<setDebuggerLayout public="1" set="method" line="1197" static="1">
			<f a="Layout">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Change the way the debugger's windows are laid out.
	 * @param	Layout		See the presets above (e.g. <code>DEBUGGER_MICRO</code>, etc).]]></haxe_doc>
		</setDebuggerLayout>
		<resetDebuggerLayout public="1" set="method" line="1208" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Just resets the debugger windows to whatever the last selected layout was (<code>DEBUGGER_STANDARD</code> by default).]]></haxe_doc>
		</resetDebuggerLayout>
		<addCamera public="1" set="method" line="1222" static="1">
			<f a="NewCamera">
				<c path="org.flixel.FlxCamera"/>
				<c path="org.flixel.FlxCamera"/>
			</f>
			<haxe_doc><![CDATA[* Add a new camera object to the game.
	 * Handy for PiP, split-screen, etc.
	 * @param	NewCamera	The camera you want to add.
	 * @return	This <code>FlxCamera</code> instance.]]></haxe_doc>
		</addCamera>
		<removeCamera public="1" set="method" line="1235" static="1">
			<f a="Camera:?Destroy">
				<c path="org.flixel.FlxCamera"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Remove a camera from the game.
	 * @param	Camera	The camera you want to remove.
	 * @param	Destroy	Whether to call destroy() on the camera, default value is true.</haxe_doc>
		</removeCamera>
		<resetCameras public="1" set="method" line="1266" static="1">
			<f a="?NewCamera">
				<c path="org.flixel.FlxCamera"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Dumps all the current cameras and resets to just one camera.
	 * Handy for doing split-screen especially.
	 * 
	 * @param	NewCamera	Optional; specify a specific camera object to be the new main camera.</haxe_doc>
		</resetCameras>
		<flash public="1" set="method" line="1294" static="1">
			<f a="?Color:?Duration:?OnComplete:?Force">
				<t path="UInt"/>
				<c path="Float"/>
				<f a=""><e path="Void"/></f>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* All screens are filled with this color and gradually return to normal.
	 * @param	Color		The color you want to use.
	 * @param	Duration	How long it takes for the flash to fade.
	 * @param	OnComplete	A function you want to run when the flash finishes.
	 * @param	Force		Force the effect to reset.</haxe_doc>
		</flash>
		<fade public="1" set="method" line="1323" static="1">
			<f a="?Color:?Duration:?FadeIn:?OnComplete:?Force">
				<t path="UInt"/>
				<c path="Float"/>
				<e path="Bool"/>
				<f a=""><e path="Void"/></f>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* The screen is gradually filled with this color.
	 * @param	Color		The color you want to use.
	 * @param	Duration	How long it takes for the fade to finish.
	 * @param 	FadeIn 		True fades from a color, false fades to it.
	 * @param	OnComplete	A function you want to run when the fade finishes.
	 * @param	Force		Force the effect to reset.</haxe_doc>
		</fade>
		<shake public="1" set="method" line="1351" static="1">
			<f a="?Intensity:?Duration:?OnComplete:?Force:?Direction">
				<c path="Float"/>
				<c path="Float"/>
				<f a=""><e path="Void"/></f>
				<e path="Bool"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* A simple screen-shake effect.
	 * @param	Intensity	Percentage of screen size representing the maximum distance that the screen can move while shaking.
	 * @param	Duration	The length in seconds that the shaking effect should last.
	 * @param	OnComplete	A function you want to run when the shake effect finishes.
	 * @param	Force		Force the effect to reset (default = true, unlike flash() and fade()!).
	 * @param	Direction	Whether to shake on both axes, just up and down, or just side to side (use class constants SHAKE_BOTH_AXES, SHAKE_VERTICAL_ONLY, or SHAKE_HORIZONTAL_ONLY).  Default value is SHAKE_BOTH_AXES (0).</haxe_doc>
		</shake>
		<getBgColor public="1" set="method" line="1367" static="1">
			<f a=""><t path="UInt"/></f>
			<haxe_doc>* Get and set the background color of the game.
	 * Get functionality is equivalent to FlxG.camera.bgColor.
	 * Set functionality sets the background color of all the current cameras.</haxe_doc>
		</getBgColor>
		<setBgColor public="1" set="method" line="1383" static="1"><f a="Color">
	<t path="UInt"/>
	<t path="UInt"/>
</f></setBgColor>
		<overlap public="1" get="inline" set="null" line="1409" static="1">
			<f a="?ObjectOrGroup1:?ObjectOrGroup2:?NotifyCallback:?ProcessCallback">
				<c path="org.flixel.FlxBasic"/>
				<c path="org.flixel.FlxBasic"/>
				<f a=":">
					<c path="org.flixel.FlxObject"/>
					<c path="org.flixel.FlxObject"/>
					<e path="Void"/>
				</f>
				<f a=":">
					<c path="org.flixel.FlxObject"/>
					<c path="org.flixel.FlxObject"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Call this function to see if one <code>FlxObject</code> overlaps another.
	 * Can be called with one object and one group, or two groups, or two objects,
	 * whatever floats your boat! For maximum performance try bundling a lot of objects
	 * together using a <code>FlxGroup</code> (or even bundling groups together!).
	 * <p>NOTE: does NOT take objects' scrollfactor into account, all overlaps are checked in world space.</p>
	 * @param	ObjectOrGroup1	The first object or group you want to check.
	 * @param	ObjectOrGroup2	The second object or group you want to check.  If it is the same as the first, flixel knows to just do a comparison within that group.
	 * @param	NotifyCallback	A function with two <code>FlxObject</code> parameters - e.g. <code>myOverlapFunction(Object1:FlxObject,Object2:FlxObject)</code> - that is called if those two objects overlap.
	 * @param	ProcessCallback	A function with two <code>FlxObject</code> parameters - e.g. <code>myOverlapFunction(Object1:FlxObject,Object2:FlxObject)</code> - that is called if those two objects overlap.  If a ProcessCallback is provided, then NotifyCallback will only be called if ProcessCallback returns true for those objects!
	 * @return	Whether any oevrlaps were detected.]]></haxe_doc>
		</overlap>
		<collide public="1" get="inline" set="null" line="1440" static="1">
			<f a="?ObjectOrGroup1:?ObjectOrGroup2:?NotifyCallback">
				<c path="org.flixel.FlxBasic"/>
				<c path="org.flixel.FlxBasic"/>
				<f a=":">
					<c path="org.flixel.FlxObject"/>
					<c path="org.flixel.FlxObject"/>
					<e path="Void"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Call this function to see if one <code>FlxObject</code> collides with another.
	 * Can be called with one object and one group, or two groups, or two objects,
	 * whatever floats your boat! For maximum performance try bundling a lot of objects
	 * together using a <code>FlxGroup</code> (or even bundling groups together!).
	 * <p>This function just calls FlxG.overlap and presets the ProcessCallback parameter to FlxObject.separate.
	 * To create your own collision logic, write your own ProcessCallback and use FlxG.overlap to set it up.</p>
	 * <p>NOTE: does NOT take objects' scrollfactor into account, all overlaps are checked in world space.</p>
	 * @param	ObjectOrGroup1	The first object or group you want to check.
	 * @param	ObjectOrGroup2	The second object or group you want to check.  If it is the same as the first, flixel knows to just do a comparison within that group.
	 * @param	NotifyCallback	A function with two <code>FlxObject</code> parameters - e.g. <code>myOverlapFunction(Object1:FlxObject,Object2:FlxObject)</code> - that is called if those two objects overlap.
	 * @return	Whether any objects were successfully collided/separated.]]></haxe_doc>
		</collide>
		<addPlugin public="1" set="method" line="1450" static="1">
			<f a="Plugin">
				<c path="org.flixel.FlxBasic"/>
				<c path="org.flixel.FlxBasic"/>
			</f>
			<haxe_doc><![CDATA[* Adds a new plugin to the global plugin array.
	 * @param	Plugin	Any object that extends FlxBasic. Useful for managers and other things.  See org.flixel.plugin for some examples!
	 * @return	The same <code>FlxBasic</code>-based plugin you passed in.]]></haxe_doc>
		</addPlugin>
		<getPlugin public="1" set="method" line="1473" static="1">
			<f a="ClassType">
				<c path="Class"><c path="org.flixel.FlxBasic"/></c>
				<c path="org.flixel.FlxBasic"/>
			</f>
			<haxe_doc><![CDATA[* Retrieves a plugin based on its class name from the global plugin array.
	 * @param	ClassType	The class name of the plugin you want to retrieve. See the <code>FlxPath</code> or <code>FlxTimer</code> constructors for example usage.
	 * @return	The plugin object, or null if no matching plugin was found.]]></haxe_doc>
		</getPlugin>
		<removePlugin public="1" set="method" line="1494" static="1">
			<f a="Plugin">
				<c path="org.flixel.FlxBasic"/>
				<c path="org.flixel.FlxBasic"/>
			</f>
			<haxe_doc><![CDATA[* Removes an instance of a plugin from the global plugin array.
	 * @param	Plugin	The plugin instance you want to remove.
	 * @return	The same <code>FlxBasic</code>-based plugin you passed in.]]></haxe_doc>
		</removePlugin>
		<removePluginType public="1" set="method" line="1515" static="1">
			<f a="ClassType">
				<c path="Class"><c path="org.flixel.FlxBasic"/></c>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Removes an instance of a plugin from the global plugin array.
	 * @param	ClassType	The class name of the plugin type you want removed from the array.
	 * @return	Whether or not at least one instance of this plugin type was removed.</haxe_doc>
		</removePluginType>
		<init public="1" set="method" line="1536" static="1">
			<f a="Game:Width:Height:Zoom">
				<c path="org.flixel.FlxGame"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Called by <code>FlxGame</code> to set up <code>FlxG</code> during <code>FlxGame</code>'s constructor.]]></haxe_doc>
		</init>
		<reset public="1" set="method" line="1585" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Called whenever the game is reset, doesn't have to do quite as much work as the basic initialization stuff.</haxe_doc>
		</reset>
		<updateInput public="1" get="inline" set="null" line="1616" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Called by the game object to update the keyboard and mouse input tracking objects.</haxe_doc>
		</updateInput>
		<lockCameras public="1" get="inline" set="null" line="1637" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Called by the game object to lock all the camera buffers and clear them for the next draw pass.</haxe_doc>
		</lockCameras>
		<unlockCameras public="1" get="inline" set="null" line="1678" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Called by the game object to draw the special FX and unlock all the camera buffers.</haxe_doc>
		</unlockCameras>
		<updateCameras public="1" get="inline" set="null" line="1705" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Called by the game object to update the cameras and their tracking/special effects logic.</haxe_doc>
		</updateCameras>
		<updatePlugins public="1" get="inline" set="null" line="1731" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Used by the game object to call <code>update()</code> on all the plugins.]]></haxe_doc>
		</updatePlugins>
		<drawPlugins public="1" get="inline" set="null" line="1750" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Used by the game object to call <code>draw()</code> on all the plugins.]]></haxe_doc>
		</drawPlugins>
		<tween public="1" set="method" line="1780" static="1">
			<f a="object:values:duration:?options">
				<d/>
				<d/>
				<c path="Float"/>
				<d/>
				<c path="org.flixel.tweens.misc.MultiVarTween"/>
			</f>
			<haxe_doc>* Tweens numeric public properties of an Object. Shorthand for creating a MultiVarTween tween, starting it and adding it to a Tweener.
	 * @param	object		The object containing the properties to tween.
	 * @param	values		An object containing key/value pairs of properties and target values.
	 * @param	duration	Duration of the tween.
	 * @param	options		An object containing key/value pairs of the following optional parameters:
	 * 						type		Tween type.
	 * 						complete	Optional completion callback function.
	 * 						ease		Optional easer function.
	 * 						tweener		The Tweener to add this Tween to.
	 * @return	The added MultiVarTween object.
	 *
	 * Example: FlxG.tween(object, { x: 500, y: 350 }, 2.0, { ease: easeFunction, complete: onComplete } );</haxe_doc>
		</tween>
		<new public="1" set="method" line="83"><f a=""><e path="Void"/></f></new>
		<haxe_doc><![CDATA[* This is a global helper class full of useful functions for audio,
 * input, basic info, and the camera system among other things.
 * Utilities for maths and color and things can be found in <code>FlxU</code>.
 * <code>FlxG</code> is specifically for Flixel-specific properties.]]></haxe_doc>
	</class>
	<class path="org.flixel.FlxLayer" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/FlxLayer.hx">
		<_layerCache line="20" static="1">
			<c path="Hash"><c path="org.flixel.FlxLayer"/></c>
			<haxe_doc>* Storage for all created layers in current state</haxe_doc>
		</_layerCache>
		<fromBitmapData public="1" set="method" line="417" static="1">
			<f a="Key:BmData:?Unique">
				<c path="String"/>
				<t path="nme.display.BitmapData"/>
				<e path="Bool"/>
				<c path="org.flixel.FlxLayer"/>
			</f>
			<haxe_doc>* Creates new layer from specified bitmapdata and stores it in layer cache, or gets cached layer if you don't need unique layer
	 * @param	Key			key to store in layer cache
	 * @param	BmData		bitmapdata for atlas
	 * @param	Unique		set this param to true if you want to be sure in key's uniqueness (plus you should provide unique bitmapdata for totally unique layer and it's atlas)
	 * @return	newly created layer or layer from cache (if Unique is set to false and layer with the same key was found in cache)</haxe_doc>
		</fromBitmapData>
		<fromLayer public="1" set="method" line="451" static="1">
			<f a="Layer:Key">
				<c path="org.flixel.FlxLayer"/>
				<c path="String"/>
				<c path="org.flixel.FlxLayer"/>
			</f>
			<haxe_doc>* Creates new layer with atlas from specified Layer and stores it in cache with Key
	 * @param	Layer	layer to copy atlas from
	 * @param	Key		key to store in layer cache
	 * @return	newly created layer</haxe_doc>
		</fromLayer>
		<createAtlas public="1" set="method" line="476" static="1">
			<f a="Width:Height:Key">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
				<c path="org.flixel.system.layer.Atlas"/>
			</f>
			<haxe_doc>* Creates empty atlas with specified dimensions
	 * @param	Width	atlas width
	 * @param	Height	atlas height
	 * @param	Key		atlas key (or name)
	 * @return	new empty atlas object</haxe_doc>
		</createAtlas>
		<checkCache public="1" set="method" line="487" static="1">
			<f a="Key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Checks if there is layer with Key in layer cache
	 * @param	Key	layer key
	 * @return	true if layer cache contains layer with specified key; false when it doesn't</haxe_doc>
		</checkCache>
		<getLayer public="1" set="method" line="497" static="1">
			<f a="Key">
				<c path="String"/>
				<c path="org.flixel.FlxLayer"/>
			</f>
			<haxe_doc>* Gets the layer from cache
	 * @param	Key	layer key
	 * @return	store layer or null if there isn't layer with such key</haxe_doc>
		</getLayer>
		<removeLayerFromCache public="1" set="method" line="507" static="1">
			<f a="Layer:?total">
				<c path="org.flixel.FlxLayer"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Removes layer from cache and destroys it. Or do nothing when layer is on 'stage' or contains objects
	 * @param	Layer	FlxLayer to remove
	 * @param	total	if true then layer's atlas will be destroyed. So keep attention or it can break another layers with the same atlas</haxe_doc>
		</removeLayerFromCache>
		<clearLayerCache public="1" set="method" line="531" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clears layer cache. You shouldn't call this method, or there will be troubles.</haxe_doc>
		</clearLayerCache>
		<set_atlas set="method" line="391"><f a="value">
	<c path="org.flixel.system.layer.Atlas"/>
	<c path="org.flixel.system.layer.Atlas"/>
</f></set_atlas>
		<get_atlas set="method" line="386"><f a=""><c path="org.flixel.system.layer.Atlas"/></f></get_atlas>
		<set_blend set="method" line="369"><f a="value">
	<t path="nme.display.BlendMode"/>
	<t path="nme.display.BlendMode"/>
</f></set_blend>
		<get_blend set="method" line="356"><f a=""><t path="nme.display.BlendMode"/></f></get_blend>
		<blend public="1" get="get_blend" set="set_blend">
			<t path="nme.display.BlendMode"/>
			<haxe_doc>* Layer's blendMode. It supports only NORMAL and ADD modes currently</haxe_doc>
		</blend>
		<atlas public="1" get="get_atlas" set="set_atlas">
			<c path="org.flixel.system.layer.Atlas"/>
			<haxe_doc>* Layer's atlas. You can't change layer's atlas if layer contains any object already.</haxe_doc>
		</atlas>
		<hasImage public="1" set="method" line="279"><f a="Key">
	<c path="String"/>
	<e path="Bool"/>
</f></hasImage>
		<addImage public="1" set="method" line="236">
			<f a="Image:?Key:?Unique">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
				<c path="org.flixel.system.layer.Node"/>
			</f>
			<haxe_doc>* Adds image to layer's atlas.</haxe_doc>
		</addImage>
		<removeObjectFromLayer set="method" line="224"><f a="Object">
	<c path="org.flixel.FlxBasic"/>
	<c path="org.flixel.FlxBasic"/>
</f></removeObjectFromLayer>
		<remove public="1" set="method" line="197">
			<f a="Object">
				<c path="org.flixel.FlxBasic"/>
				<c path="org.flixel.FlxBasic"/>
			</f>
			<haxe_doc>* Removes object from this layer
	 * @param	Object	object to remove
	 * @return	removed object</haxe_doc>
		</remove>
		<addObjectToLayer set="method" line="175"><f a="Object">
	<c path="org.flixel.FlxBasic"/>
	<c path="org.flixel.FlxBasic"/>
</f></addObjectToLayer>
		<add public="1" set="method" line="138">
			<f a="Object">
				<c path="org.flixel.FlxBasic"/>
				<c path="org.flixel.FlxBasic"/>
			</f>
			<haxe_doc>* Adds object to this layer. May remove it if object was on another layer. Tries to add object's bitmapdata on layer's atlas.
	 * Important note: You will still need to add an object not only in the layer, but in the state using state's add() method
	 * @param	Object	object to add.
	 * @return	added object. May return null if object can't be added on this layer.</haxe_doc>
		</add>
		<destroy public="1" set="method" line="118">
			<f a="?total">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Destroys layer (clean memory)
	 * @param	total	set it to true if you want to destroy layer's atlas. But be carefull, since many layers can use same atlas.</haxe_doc>
		</destroy>
		<updateFlags set="method" line="103">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Updates drawing flags</haxe_doc>
		</updateFlags>
		<set_isColored set="method" line="93"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></set_isColored>
		<isColored public="1" set="set_isColored"><e path="Bool"/></isColored>
		<redrawNode public="1" set="method" line="86">
			<f a="node">
				<c path="org.flixel.system.layer.Node"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Updates atlas' bitmapdata. Call it after changin' sprite's graphic
	 * @param	node	Node with changed bitmapdata</haxe_doc>
		</redrawNode>
		<redrawAtlas public="1" set="method" line="77">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Updates whole atlas' bitmapdata. this could be very slow, so use it if you really need it.</haxe_doc>
		</redrawAtlas>
		<onStage public="1">
			<e path="Bool"/>
			<haxe_doc>* Bool flag to track if the layer is on state. Please, do not modify it's value.</haxe_doc>
		</onStage>
		<antialiasing public="1">
			<e path="Bool"/>
			<haxe_doc>* Layer antialiasing</haxe_doc>
		</antialiasing>
		<positionData public="1">
			<c path="Array"><c path="Int"/></c>
			<haxe_doc>* position offsets in drawData arrays. I use them for little optimization</haxe_doc>
		</positionData>
		<drawData public="1">
			<c path="Array"><c path="Array"><c path="Float"/></c></c>
			<haxe_doc>* draw data for tilesheet rendering</haxe_doc>
		</drawData>
		<_blend>
			<c path="Int"/>
			<haxe_doc>* Layer blending flag.</haxe_doc>
		</_blend>
		<flags public="1">
			<c path="Int"/>
			<haxe_doc>* Drawing flags, used for tilesheet rendering</haxe_doc>
		</flags>
		<_numObjects>
			<c path="Int"/>
			<haxe_doc>* Number of objects on this layer</haxe_doc>
		</_numObjects>
		<_tileSheet><c path="nme.display.Tilesheet"/></_tileSheet>
		<_atlas><c path="org.flixel.system.layer.Atlas"/></_atlas>
		<new public="1" set="method" line="60">
			<f a="Name">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructot
	 * @param	Name	layer name. Need to be unique.</haxe_doc>
		</new>
	</class>
	<class path="org.flixel.FlxPath" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/FlxPath.hx">
		<manager public="1" get="getManager" set="null" static="1"><c path="org.flixel.plugin.DebugPathDisplay"/></manager>
		<getManager public="1" set="method" line="336" static="1"><f a=""><c path="org.flixel.plugin.DebugPathDisplay"/></f></getManager>
		<drawDebug public="1" set="method" line="228">
			<f a="?Camera">
				<c path="org.flixel.FlxCamera"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* While this doesn't override <code>FlxBasic.drawDebug()</code>, the behavior is very similar.
	 * Based on this path data, it draws a simple lines-and-boxes representation of the path
	 * if the visual debug mode was toggled in the debugger overlay.  You can use <code>debugColor</code>
	 * and <code>debugScrollFactor</code> to control the path's appearance.
	 * @param	Camera		The camera object the path will draw to.]]></haxe_doc>
		</drawDebug>
		<tail public="1" set="method" line="212">
			<f a=""><c path="org.flixel.FlxPoint"/></f>
			<haxe_doc>* Get the last node in the list.
	 * @return	The last node in the path.</haxe_doc>
		</tail>
		<head public="1" set="method" line="199">
			<f a=""><c path="org.flixel.FlxPoint"/></f>
			<haxe_doc>* Get the first node in the list.
	 * @return	The first node in the path.</haxe_doc>
		</head>
		<removeAt public="1" set="method" line="182">
			<f a="Index">
				<c path="Int"/>
				<c path="org.flixel.FlxPoint"/>
			</f>
			<haxe_doc>* Remove a node from the path using the specified position in the list of path nodes.
	 * @param	Index	Where within the list of path nodes you want to remove a node.
	 * @return	The node that was excised.  Returns null if there were no nodes in the path.</haxe_doc>
		</removeAt>
		<remove public="1" set="method" line="164">
			<f a="Node">
				<c path="org.flixel.FlxPoint"/>
				<c path="org.flixel.FlxPoint"/>
			</f>
			<haxe_doc><![CDATA[* Remove a node from the path.
	 * NOTE: only works with points added by reference or with references from <code>nodes</code> itself!
	 * @param	Node	The point object you want to remove from the path.
	 * @return	The node that was excised.  Returns null if the node was not found.]]></haxe_doc>
		</remove>
		<addPointAt public="1" set="method" line="141">
			<f a="Node:Index:?AsReference">
				<c path="org.flixel.FlxPoint"/>
				<c path="Int"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Sometimes its easier or faster to just pass a point object instead of separate X and Y coordinates.
	 * This also gives you the option of not creating a new node but actually adding that specific
	 * <code>FlxPoint</code> object to the path.  This allows you to do neat things, like dynamic paths.
	 * @param	Node			The point in world coordinates you want to add to the path.
	 * @param	Index			Where within the list of path nodes to insert this new point.
	 * @param	AsReference		Whether to add the point as a reference, or to create a new point with the specified values.]]></haxe_doc>
		</addPointAt>
		<addPoint public="1" set="method" line="121">
			<f a="Node:?AsReference">
				<c path="org.flixel.FlxPoint"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Sometimes its easier or faster to just pass a point object instead of separate X and Y coordinates.
	 * This also gives you the option of not creating a new node but actually adding that specific
	 * <code>FlxPoint</code> object to the path.  This allows you to do neat things, like dynamic paths.
	 * @param	Node			The point in world coordinates you want to add to the path.
	 * @param	AsReference		Whether to add the point as a reference, or to create a new point with the specified values.]]></haxe_doc>
		</addPoint>
		<addAt public="1" set="method" line="104">
			<f a="X:Y:Index">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Add a new node to the path at the specified location and index within the path.
	 * @param	X		X position of the new path point in world coordinates.
	 * @param	Y		Y position of the new path point in world coordinates.
	 * @param	Index	Where within the list of path nodes to insert this new point.</haxe_doc>
		</addAt>
		<add public="1" set="method" line="93">
			<f a="X:Y">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Add a new node to the end of the path at the specified location.
	 * @param	X	X position of the new path point in world coordinates.
	 * @param	Y	Y position of the new path point in world coordinates.</haxe_doc>
		</add>
		<destroy public="1" set="method" line="75">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_point>
			<c path="org.flixel.FlxPoint"/>
			<haxe_doc>* Internal helper for keeping new variable instantiations under control.</haxe_doc>
		</_point>
		<ignoreDrawDebug public="1">
			<e path="Bool"/>
			<haxe_doc>* Setting this to true will prevent the object from appearing
	 * when the visual debug mode in the debugger overlay is toggled on.
	 * @default false</haxe_doc>
		</ignoreDrawDebug>
		<debugScrollFactor public="1">
			<c path="org.flixel.FlxPoint"/>
			<haxe_doc>* Specify a debug display scroll factor for the path.  Default is (1,1).
	 * NOTE: does not affect world movement!  Object scroll factors take care of that.</haxe_doc>
		</debugScrollFactor>
		<debugColor public="1">
			<t path="UInt"/>
			<haxe_doc>* Specify a debug display color for the path.  Default is white.</haxe_doc>
		</debugColor>
		<nodes public="1">
			<c path="Array"><c path="org.flixel.FlxPoint"/></c>
			<haxe_doc><![CDATA[* The list of <code>FlxPoint</code>s that make up the path data.]]></haxe_doc>
		</nodes>
		<new public="1" set="method" line="50">
			<f a="?Nodes">
				<c path="Array"><c path="org.flixel.FlxPoint"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* Instantiate a new path object.
	 * 
	 * @param	Nodes	Optional, can specify all the points for the path up front if you want.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* This is a simple path data container.  Basically a list of points that
 * a <code>FlxObject</code> can follow.  Also has code for drawing debug visuals.
 * <code>FlxTilemap.findPath()</code> returns a path object, but you can
 * also just make your own, using the <code>add()</code> functions below
 * or by creating your own array of points.]]></haxe_doc>
	</class>
	<class path="org.flixel.FlxSave" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/FlxSave.hx">
		<SUCCESS line="21" static="1"><c path="Int"/></SUCCESS>
		<PENDING line="22" static="1"><c path="Int"/></PENDING>
		<ERROR line="23" static="1"><c path="Int"/></ERROR>
		<checkBinding set="method" line="210">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Handy utility function for checking and warning if the shared object is bound yet or not.
	 * @return	Whether the shared object was bound yet.</haxe_doc>
		</checkBinding>
		<onDone set="method" line="185">
			<f a="Result">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Event handler for special case storage requests.
	 * Handles logging of errors and calling of callback.
	 * @param	Result		One of the result codes (PENDING, ERROR, or SUCCESS).
	 * @return	Whether the operation was a success or not.</haxe_doc>
		</onDone>
		<onFlushStatus set="method" line="172">
			<f a="E">
				<c path="flash.events.NetStatusEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Event handler for special case storage requests.
	 * @param	E	Flash net status event.</haxe_doc>
		</onFlushStatus>
		<erase public="1" set="method" line="157">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Erases everything stored in the local shared object.
	 * Data is immediately erased and the object is saved that way,
	 * so use with caution!
	 * @return	Returns false if the save object is not bound yet.</haxe_doc>
		</erase>
		<flush public="1" set="method" line="113">
			<f a="?MinFileSize:?OnComplete">
				<c path="Int"/>
				<f a="">
					<e path="Bool"/>
					<e path="Void"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Writes the local shared object to disk immediately.  Leaves the object open in memory.
	 * @param	MinFileSize		If you need X amount of space for your save, specify it here.
	 * @param	OnComplete		This callback will be triggered when the data is written successfully.
	 * @return	Whether or not the data was written immediately.  False could be an error OR a storage request popup.</haxe_doc>
		</flush>
		<close public="1" set="method" line="101">
			<f a="?MinFileSize:?OnComplete">
				<c path="Int"/>
				<f a="">
					<e path="Bool"/>
					<e path="Void"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* A way to safely call <code>flush()</code> and <code>destroy()</code> on your save file.
	 * Will correctly handle storage size popups and all that good stuff.
	 * If you don't want to save your changes first, just call <code>destroy()</code> instead.
	 * @param	MinFileSize		If you need X amount of space for your save, specify it here.
	 * @param	OnComplete		This callback will be triggered when the data is written successfully.
	 * @return	The result of result of the <code>flush()</code> call (see below for more details).]]></haxe_doc>
		</close>
		<bind public="1" set="method" line="75">
			<f a="Name">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Automatically creates or reconnects to locally saved data.
	 * @param	Name	The name of the object (should be the same each time to access old data).
	 * @return	Whether or not you successfully connected to the save data.</haxe_doc>
		</bind>
		<destroy public="1" set="method" line="61">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_closeRequested>
			<e path="Bool"/>
			<haxe_doc>* Internal tracker for save object close request.</haxe_doc>
		</_closeRequested>
		<_onComplete>
			<f a="">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Internal tracker for callback function in case save takes too long.</haxe_doc>
		</_onComplete>
		<_sharedObject>
			<t path="nme.net.SharedObject"/>
			<haxe_doc>* The local shared object itself.
	 * @default null</haxe_doc>
		</_sharedObject>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* The name of the local shared object.
	 * @default null</haxe_doc>
		</name>
		<data public="1">
			<d/>
			<haxe_doc>* Allows you to directly access the data container in the local shared object.
	 * @default null</haxe_doc>
		</data>
		<new public="1" set="method" line="53">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Blanks out the containers.</haxe_doc>
		</new>
		<haxe_doc>* A class to help automate and simplify save game functionality.
 * Basicaly a wrapper for the Flash SharedObject thing, but
 * handles some annoying storage request stuff too.</haxe_doc>
	</class>
	<class path="org.flixel.FlxSound" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/FlxSound.hx">
		<extends path="org.flixel.FlxBasic"/>
		<gotID3 set="method" line="538">
			<f a="?event">
				<t path="nme.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Internal event handler for ID3 info (i.e. fetching the song name).
	 * @param	event	An <code>Event</code> object.]]></haxe_doc>
		</gotID3>
		<cleanup set="method" line="511">
			<f a="destroySound:?resetPosition">
				<e path="Bool"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* An internal helper function used to help Flash clean up (and potentially re-use) finished sounds.
	 * 
	 * @param	destroySound		Whether or not to destroy the sound</haxe_doc>
		</cleanup>
		<stopped set="method" line="493">
			<f a="?event">
				<t path="nme.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* An internal helper function used to help Flash clean up finished sounds or restart looped sounds.
	 * @param	event		An <code>Event</code> object.]]></haxe_doc>
		</stopped>
		<startSound set="method" line="471">
			<f a="Position">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* An internal helper function used to attempt to start playing the sound and populate the `_channel` variable.</haxe_doc>
		</startSound>
		<updateTransform set="method" line="459">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Call after adjusting the volume to update the sound channel's settings.</haxe_doc>
		</updateTransform>
		<getActualVolume public="1" set="method" line="451">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Returns the currently selected "real" volume of the sound (takes fades and proximity into account).
	 * @return	The adjusted volume of the sound.</haxe_doc>
		</getActualVolume>
		<setVolume public="1" set="method" line="432">
			<f a="Volume">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</setVolume>
		<volume public="1" set="setVolume">
			<c path="Float"/>
			<haxe_doc><![CDATA[* Set <code>volume</code> to a value between 0 and 1 to change how this sound is.]]></haxe_doc>
		</volume>
		<fadeIn public="1" set="method" line="416">
			<f a="Seconds">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Call this function to make a sound fade in over a certain
	 * time interval (calls <code>play()</code> automatically).
	 * @param	Seconds		The amount of time the fade-in operation should take.]]></haxe_doc>
		</fadeIn>
		<fadeOut public="1" set="method" line="403">
			<f a="Seconds:?PauseInstead">
				<c path="Float"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Call this function to make this sound fade out over a certain time interval.
	 * @param	Seconds			The amount of time the fade out operation should take.
	 * @param	PauseInstead	Tells the sound to pause on fadeout, instead of stopping.</haxe_doc>
		</fadeOut>
		<stop public="1" set="method" line="393">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Call this function to stop this sound.</haxe_doc>
		</stop>
		<pause public="1" set="method" line="379">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Call this function to pause this sound.</haxe_doc>
		</pause>
		<resume public="1" set="method" line="368">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Unpause a sound.  Only works on sounds that have been paused.</haxe_doc>
		</resume>
		<play public="1" set="method" line="339">
			<f a="?ForceRestart">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Call this function to play the sound - also works on paused sounds.
	 * @param	ForceRestart	Whether to start the sound over or not.  Default value is false, meaning if the sound is already playing or was paused when you call <code>play()</code>, it will continue playing from its current position, NOT start again from the beginning.]]></haxe_doc>
		</play>
		<proximity public="1" set="method" line="325">
			<f a="X:Y:TargetObject:Radius:?Pan">
				<c path="Float"/>
				<c path="Float"/>
				<c path="org.flixel.FlxObject"/>
				<c path="Float"/>
				<e path="Bool"/>
				<c path="org.flixel.FlxSound"/>
			</f>
			<haxe_doc>* Call this function if you want this sound's volume to change
	 * based on distance from a particular FlxCore object.
	 * @param	X		The X position of the sound.
	 * @param	Y		The Y position of the sound.
	 * @param	TargetObject	The object you want to track.
	 * @param	Radius	The maximum distance this sound can travel.
	 * @param	Pan		Whether the sound should pan in addition to the volume changes (default: true).
	 * @return	This FlxSound instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</proximity>
		<loadStream public="1" set="method" line="301">
			<f a="SoundURL:?Looped:?AutoDestroy">
				<c path="String"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="org.flixel.FlxSound"/>
			</f>
			<haxe_doc><![CDATA[* One of two main setup functions for sounds, this function loads a sound from a URL.
	 * @param	EmbeddedSound	A string representing the URL of the MP3 file you want to play.
	 * @param	Looped			Whether or not this sound should loop endlessly.
	 * @param	AutoDestroy		Whether or not this <code>FlxSound</code> instance should be destroyed when the sound finishes playing.  Default value is false, but FlxG.play() and FlxG.stream() will set it to true by default.
	 * @return	This <code>FlxSound</code> instance (nice for chaining stuff together, if you're into that).]]></haxe_doc>
		</loadStream>
		<loadEmbedded public="1" set="method" line="269">
			<f a="EmbeddedSound:?Looped:?AutoDestroy">
				<d/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="org.flixel.FlxSound"/>
			</f>
			<haxe_doc><![CDATA[* One of two main setup functions for sounds, this function loads a sound from an embedded MP3.
	 * @param	EmbeddedSound	An embedded Class object representing an MP3 file.
	 * @param	Looped			Whether or not this sound should loop endlessly.
	 * @param	AutoDestroy		Whether or not this <code>FlxSound</code> instance should be destroyed when the sound finishes playing.  Default value is false, but FlxG.play() and FlxG.stream() will set it to true by default.
	 * @return	This <code>FlxSound</code> instance (nice for chaining stuff together, if you're into that).]]></haxe_doc>
		</loadEmbedded>
		<kill public="1" set="method" line="256" override="1"><f a=""><e path="Void"/></f></kill>
		<update public="1" set="method" line="189" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Handles fade out, fade in, panning, proximity, and amplitude operations each frame.</haxe_doc>
		</update>
		<destroy public="1" set="method" line="165" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<createSound set="method" line="127">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* An internal function for clearing all the variables used by sounds.</haxe_doc>
		</createSound>
		<_fadeInTotal>
			<c path="Float"/>
			<haxe_doc>* Internal helper for fading in sounds.</haxe_doc>
		</_fadeInTotal>
		<_fadeInTimer>
			<c path="Float"/>
			<haxe_doc>* Internal timer for fading in the sound playback.</haxe_doc>
		</_fadeInTimer>
		<_pauseOnFadeOut>
			<e path="Bool"/>
			<haxe_doc>* Internal flag for whether to pause or stop the sound when it's done fading out.</haxe_doc>
		</_pauseOnFadeOut>
		<_fadeOutTotal>
			<c path="Float"/>
			<haxe_doc>* Internal helper for fading out sounds.</haxe_doc>
		</_fadeOutTotal>
		<_fadeOutTimer>
			<c path="Float"/>
			<haxe_doc>* Internal timer used to keep track of requests to fade out the sound playback.</haxe_doc>
		</_fadeOutTimer>
		<_pan>
			<e path="Bool"/>
			<haxe_doc>* Internal tracker for whether to pan the sound left and right.  Default is false.</haxe_doc>
		</_pan>
		<_radius>
			<c path="Float"/>
			<haxe_doc>* Internal tracker for the maximum effective radius of this sound (for proximity and panning).</haxe_doc>
		</_radius>
		<_target>
			<c path="org.flixel.FlxObject"/>
			<haxe_doc>* Internal tracker for the sound's "target" (for proximity and panning).</haxe_doc>
		</_target>
		<_looped>
			<e path="Bool"/>
			<haxe_doc>* Internal tracker for whether the sound is looping or not.</haxe_doc>
		</_looped>
		<_volumeAdjust>
			<c path="Float"/>
			<haxe_doc>* Internal tracker for total volume adjustment.</haxe_doc>
		</_volumeAdjust>
		<_position>
			<c path="Float"/>
			<haxe_doc>* Internal tracker for the position in runtime of the music playback.</haxe_doc>
		</_position>
		<_paused>
			<e path="Bool"/>
			<haxe_doc>* Internal tracker for whether the sound is paused or not (not the same as stopped).</haxe_doc>
		</_paused>
		<_transform>
			<t path="nme.media.SoundTransform"/>
			<haxe_doc>* Internal tracker for a Flash sound transform object.</haxe_doc>
		</_transform>
		<_channel>
			<t path="nme.media.SoundChannel"/>
			<haxe_doc>* Internal tracker for a Flash sound channel object.</haxe_doc>
		</_channel>
		<_sound>
			<t path="nme.media.Sound"/>
			<haxe_doc>* Internal tracker for a Flash sound object.</haxe_doc>
		</_sound>
		<autoDestroy public="1">
			<e path="Bool"/>
			<haxe_doc>* Whether to call destroy() when the sound has finished.</haxe_doc>
		</autoDestroy>
		<amplitudeRight public="1">
			<c path="Float"/>
			<haxe_doc>* Just the amplitude of the left stereo channel</haxe_doc>
		</amplitudeRight>
		<amplitudeLeft public="1">
			<c path="Float"/>
			<haxe_doc>* Just the amplitude of the left stereo channel</haxe_doc>
		</amplitudeLeft>
		<amplitude public="1">
			<c path="Float"/>
			<haxe_doc>* Stores the average wave amplitude of both stereo channels</haxe_doc>
		</amplitude>
		<artist public="1">
			<c path="String"/>
			<haxe_doc>* The ID3 artist name.  Defaults to null.  Currently only works for streamed sounds.</haxe_doc>
		</artist>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* The ID3 song name.  Defaults to null.  Currently only works for streamed sounds.</haxe_doc>
		</name>
		<survive public="1">
			<e path="Bool"/>
			<haxe_doc>* Whether or not this sound should be automatically destroyed when you switch states.</haxe_doc>
		</survive>
		<y public="1">
			<c path="Float"/>
			<haxe_doc>* The Y position of this sound in world coordinates.
	 * Only really matters if you are doing proximity/panning stuff.</haxe_doc>
		</y>
		<x public="1">
			<c path="Float"/>
			<haxe_doc>* The X position of this sound in world coordinates.
	 * Only really matters if you are doing proximity/panning stuff.</haxe_doc>
		</x>
		<new public="1" set="method" line="118">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* The FlxSound constructor gets all the variables initialized, but NOT ready to play a sound yet.</haxe_doc>
		</new>
		<haxe_doc>* This is the universal flixel sound object, used for streaming, music, and sound effects.</haxe_doc>
	</class>
	<class path="org.flixel.FlxText" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/FlxText.hx">
		<extends path="org.flixel.FlxSprite"/>
		<updateFrameData public="1" set="method" line="503" override="1"><f a=""><e path="Void"/></f></updateFrameData>
		<updateLayerInfo public="1" set="method" line="487" override="1">
			<f a="?updateAtlas">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* FlxText objects can't be added on any level. They create their own layers</haxe_doc>
		</updateLayerInfo>
		<convertTextAlignmentFromString set="method" line="451">
			<f a="strAlign">
				<c path="String"/>
				<t path="nme.text.TextFormatAlign"/>
			</f>
			<haxe_doc>* Method for converting string to TextFormatAlign</haxe_doc>
		</convertTextAlignmentFromString>
		<dtfCopy set="method" line="441">
			<f a=""><t path="nme.text.TextFormat"/></f>
			<haxe_doc><![CDATA[* A helper function for updating the <code>TextField</code> that we use for rendering.
	 * @return	A writable copy of <code>TextField.defaultTextFormat</code>.]]></haxe_doc>
		</dtfCopy>
		<calcFrame set="method" line="348" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Internal function to update the current animation frame.</haxe_doc>
		</calcFrame>
		<setShadow public="1" set="method" line="330">
			<f a="Color">
				<t path="UInt"/>
				<t path="UInt"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</setShadow>
		<getShadow public="1" set="method" line="318">
			<f a=""><t path="UInt"/></f>
			<haxe_doc>* The color of the text shadow in 0xAARRGGBB hex format.</haxe_doc>
		</getShadow>
		<setAlignment public="1" set="method" line="300">
			<f a="Alignment">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</setAlignment>
		<getAlignment public="1" set="method" line="292">
			<f a=""><c path="String"/></f>
			<haxe_doc>* The alignment of the font ("left", "right", or "center").</haxe_doc>
		</getAlignment>
		<alignment public="1" get="getAlignment" set="setAlignment"><c path="String"/></alignment>
		<setFont public="1" set="method" line="272">
			<f a="Font">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</setFont>
		<getFont public="1" set="method" line="264">
			<f a=""><c path="String"/></f>
			<haxe_doc>* The font used for this text.</haxe_doc>
		</getFont>
		<font public="1" get="getFont" set="setFont"><c path="String"/></font>
		<setColor public="1" set="method" line="237" override="1">
			<f a="Color">
				<t path="UInt"/>
				<t path="UInt"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</setColor>
		<getColor public="1" set="method" line="218" override="1">
			<f a=""><t path="UInt"/></f>
			<haxe_doc>* The color of the text being displayed.</haxe_doc>
		</getColor>
		<setSize public="1" set="method" line="199">
			<f a="Size">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</setSize>
		<getSize public="1" set="method" line="191">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* The size of the text being displayed.</haxe_doc>
		</getSize>
		<size public="1" get="getSize" set="setSize"><c path="Float"/></size>
		<setText public="1" set="method" line="170">
			<f a="Text">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</setText>
		<getText public="1" set="method" line="162">
			<f a=""><c path="String"/></f>
			<haxe_doc>* The text being displayed.</haxe_doc>
		</getText>
		<text public="1" get="getText" set="setText"><c path="String"/></text>
		<setFormat public="1" set="method" line="127">
			<f a="?Font:?Size:?Color:?Alignment:?ShadowColor">
				<c path="String"/>
				<c path="Float"/>
				<t path="UInt"/>
				<c path="String"/>
				<t path="UInt"/>
				<c path="org.flixel.FlxText"/>
			</f>
			<haxe_doc>* You can use this if you have a lot of text parameters
	 * to set instead of the individual properties.
	 * @param	Font		The name of the font face for the text display.
	 * @param	Size		The size of the font (in pixels essentially).
	 * @param	Color		The color of the text in traditional flash 0xRRGGBB format.
	 * @param	Alignment	A string representing the desired alignment ("left,"right" or "center").
	 * @param	ShadowColor	A uint representing the desired text shadow color in flash 0xRRGGBB format.
	 * @return	This FlxText instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</setFormat>
		<destroy public="1" set="method" line="106" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_shadow>
			<t path="UInt"/>
			<haxe_doc>* Internal tracker for the text shadow color, default is clear/transparent.</haxe_doc>
		</_shadow>
		<_regen>
			<e path="Bool"/>
			<haxe_doc><![CDATA[* Whether the actual text field needs to be regenerated and stamped again.
	 * This is NOT the same thing as <code>FlxSprite.dirty</code>.]]></haxe_doc>
		</_regen>
		<_textField>
			<t path="nme.text.TextField"/>
			<haxe_doc><![CDATA[* Internal reference to a Flash <code>TextField</code> object.]]></haxe_doc>
		</_textField>
		<shadow public="1" get="getShadow" set="setShadow"><t path="UInt"/></shadow>
		<new public="1" set="method" line="52">
			<f a="X:Y:Width:?Text:?EmbeddedFont">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Int"/>
				<c path="String"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new <code>FlxText</code> object at the specified position.
	 * @param	X				The X position of the text.
	 * @param	Y				The Y position of the text.
	 * @param	Width			The width of the text object (height is determined automatically).
	 * @param	Text			The actual text you would like to display initially.
	 * @param	EmbeddedFont	Whether this text field uses embedded fonts or not]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Extends <code>FlxSprite</code> to support rendering text.
 * Can tint, fade, rotate and scale just like a sprite.
 * Doesn't really animate though, as far as I know.
 * Also does nice pixel-perfect centering on pixel fonts
 * as long as they are only one liners.]]></haxe_doc>
	</class>
	<class path="org.flixel.FlxTilemap" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/FlxTilemap.hx">
		<extends path="org.flixel.FlxObject"/>
		<imgAuto public="1" get="inline" set="null" line="23" static="1"><c path="String"/></imgAuto>
		<imgAutoAlt public="1" get="inline" set="null" line="24" static="1"><c path="String"/></imgAutoAlt>
		<OFF public="1" get="inline" set="null" line="29" static="1">
			<c path="Int"/>
			<haxe_doc>* No auto-tiling.</haxe_doc>
		</OFF>
		<AUTO public="1" get="inline" set="null" line="33" static="1">
			<c path="Int"/>
			<haxe_doc>* Good for levels with thin walls that don'tile need interior corner art.</haxe_doc>
		</AUTO>
		<ALT public="1" get="inline" set="null" line="37" static="1">
			<c path="Int"/>
			<haxe_doc>* Better for levels with thick walls that look better with interior corner art.</haxe_doc>
		</ALT>
		<arrayToCSV public="1" set="method" line="1678" static="1">
			<f a="Data:Width:?Invert">
				<c path="Array"><c path="Int"/></c>
				<c path="Int"/>
				<e path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Converts a one-dimensional array of tile data to a comma-separated string.
	 * @param	Data		An array full of integer tile references.
	 * @param	Width		The number of tiles in each row.
	 * @param	Invert		Recommended only for 1-bit arrays - changes 0s to 1s and vice versa.
	 * @return	A comma-separated string containing the level data in a <code>FlxTilemap</code>-friendly format.]]></haxe_doc>
		</arrayToCSV>
		<bitmapToCSV public="1" set="method" line="1737" static="1">
			<f a="bitmapData:?Invert:?Scale:?ColorMap">
				<t path="nme.display.BitmapData"/>
				<e path="Bool"/>
				<c path="Int"/>
				<c path="Array"><t path="UInt"/></c>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Converts a <code>BitmapData</code> object to a comma-separated string.
	 * Black pixels are flagged as 'solid' by default,
	 * non-black pixels are set as non-colliding.
	 * Black pixels must be PURE BLACK.
	 * @param	bitmapData	A Flash <code>BitmapData</code> object, preferably black and white.
	 * @param	Invert		Load white pixels as solid instead.
	 * @param	Scale		Default is 1.  Scale of 2 means each pixel forms a 2x2 block of tiles, and so on.
	 * @param  ColorMap  An array of color values (uint 0xAARRGGBB) in the order they're intended to be assigned as indices
	 * @return	A comma-separated string containing the level data in a <code>FlxTilemap</code>-friendly format.]]></haxe_doc>
		</bitmapToCSV>
		<imageToCSV public="1" set="method" line="1818" static="1">
			<f a="ImageFile:?Invert:?Scale">
				<d/>
				<e path="Bool"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Converts a resource image file to a comma-separated string.
	 * Black pixels are flagged as 'solid' by default,
	 * non-black pixels are set as non-colliding.
	 * Black pixels must be PURE BLACK.
	 * @param	ImageFile	An embedded graphic, preferably black and white.
	 * @param	Invert		Load white pixels as solid instead.
	 * @param	Scale		Default is 1.  Scale of 2 means each pixel forms a 2x2 block of tiles, and so on.
	 * @return	A comma-separated string containing the level data in a <code>FlxTilemap</code>-friendly format.]]></haxe_doc>
		</imageToCSV>
		<tileToFlxSprite public="1" set="method" line="1926">
			<f a="X:Y:?NewTile">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="org.flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Change a particular tile to FlxSprite. Or just copy the graphic if you dont want any changes to mapdata itself.
	 * @link http://forums.flixel.org/index.php/topic,5398.0.html
	 * @param	X		The X coordinate of the tile (in tiles, not pixels).
	 * @param	Y		The Y coordinate of the tile (in tiles, not pixels).
	 * @param	NewTile	New tile to the mapdata. Use -1 if you dont want any changes. Default = 0 (empty)
	 * @return	FlxSprite.</haxe_doc>
		</tileToFlxSprite>
		<updateFrameData public="1" set="method" line="1900" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Use this method for creating tileSheet for FlxTilemap. Must be called after loadMap() method.
	 * If you forget to call it then you will not see this FlxTilemap on c++ target</haxe_doc>
		</updateFrameData>
		<updateTile set="method" line="1870">
			<f a="Index">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Internal function used in setTileByIndex() and the constructor to update the map.
	 * @param	Index		The index of the tile you want to update.</haxe_doc>
		</updateTile>
		<autoTile set="method" line="1836">
			<f a="Index">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* An internal function used by the binary auto-tilers.
	 * @param	Index		The index of the tile you want to analyze.</haxe_doc>
		</autoTile>
		<rayHit public="1" set="method" line="1583">
			<f a="Start:End:?Resolution">
				<c path="org.flixel.FlxPoint"/>
				<c path="org.flixel.FlxPoint"/>
				<c path="Float"/>
				<c path="org.flixel.FlxPoint"/>
			</f>
			<haxe_doc>* Works exactly like ray() except it explicitly returns the hit result.
	* Shoots a ray from the start point to the end point.
	* If/when it passes through a tile, it returns that point.
	* If it does not, it returns null.
	* Usage:
	* var hit:FlxPoint = tilemap.rayHit(startPoint, endPoint);
	* if (hit != null) //code ;
	*
	* @param Start The world coordinates of the start of the ray.
	* @param End The world coordinates of the end of the ray.
	* @param Resolution Defaults to 1, meaning check every tile or so. Higher means more checks!
	* @return Returns null if the ray made it from Start to End without hitting anything. Returns FlxPoint if a tile was hit.</haxe_doc>
		</rayHit>
		<ray public="1" set="method" line="1484">
			<f a="Start:End:?Result:?Resolution">
				<c path="org.flixel.FlxPoint"/>
				<c path="org.flixel.FlxPoint"/>
				<c path="org.flixel.FlxPoint"/>
				<c path="Float"/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Shoots a ray from the start point to the end point.
	 * If/when it passes through a tile, it stores that point and returns false.
	 * @param	Start		The world coordinates of the start of the ray.
	 * @param	End			The world coordinates of the end of the ray.
	 * @param	Result		A <code>Point</code> object containing the first wall impact.
	 * @param	Resolution	Defaults to 1, meaning check every tile or so.  Higher means more checks!
	 * @return	Returns true if the ray made it from Start to End without hitting anything.  Returns false and fills Result if a tile was hit.]]></haxe_doc>
		</ray>
		<getBounds public="1" set="method" line="1466">
			<f a="?Bounds">
				<c path="org.flixel.FlxRect"/>
				<c path="org.flixel.FlxRect"/>
			</f>
			<haxe_doc><![CDATA[* Get the world coordinates and size of the entire tilemap as a <code>FlxRect</code>.
	 * @param	Bounds		Optional, pass in a pre-existing <code>FlxRect</code> to prevent instantiation of a new object.
	 * @return	A <code>FlxRect</code> containing the world coordinates and size of the entire tilemap.]]></haxe_doc>
		</getBounds>
		<follow public="1" set="method" line="1452">
			<f a="?Camera:?Border:?UpdateWorld">
				<c path="org.flixel.FlxCamera"/>
				<c path="Int"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Call this function to lock the automatic camera to the map's edges.
	 * @param	Camera			Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @param	Border			Adjusts the camera follow boundary by whatever number of tiles you specify here.  Handy for blocking off deadends that are offscreen, etc.  Use a negative number to add padding instead of hiding the edges.
	 * @param	UpdateWorld		Whether to update the collision system's world size, default value is true.</haxe_doc>
		</follow>
		<setTileProperties public="1" set="method" line="1428">
			<f a="Tile:?AllowCollisions:?Callback:?CallbackFilter:?Range">
				<c path="Int"/>
				<c path="Int"/>
				<f a=":">
					<c path="org.flixel.FlxObject"/>
					<c path="org.flixel.FlxObject"/>
					<e path="Void"/>
				</f>
				<c path="Class"><d/></c>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Adjust collision settings and/or bind a callback function to a range of tiles.
	 * This callback function, if present, is triggered by calls to overlap() or overlapsWithCallback().
	 * @param	Tile			The tile or tiles you want to adjust.
	 * @param	AllowCollisions	Modify the tile or tiles to only allow collisions from certain directions, use FlxObject constants NONE, ANY, LEFT, RIGHT, etc.  Default is "ANY".
	 * @param	Callback		The function to trigger, e.g. <code>lavaCallback(Tile:FlxTile, Object:FlxObject)</code>.
	 * @param	CallbackFilter	If you only want the callback to go off for certain classes or objects based on a certain class, set that class here.
	 * @param	Range			If you want this callback to work for a bunch of different tiles, input the range here.  Default value is 1.]]></haxe_doc>
		</setTileProperties>
		<setTileByIndex public="1" set="method" line="1371">
			<f a="Index:Tile:?UpdateGraphics">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Change the data and graphic of a tile in the tilemap.
	 * @param	Index			The slot in the data array (Y * widthInTiles + X) where this tile is stored.
	 * @param	Tile			The new integer data you wish to inject.
	 * @param	UpdateGraphics	Whether the graphical representation of this tile should change.
	 * @return	Whether or not the tile was actually changed.</haxe_doc>
		</setTileByIndex>
		<setTile public="1" set="method" line="1355">
			<f a="X:Y:Tile:?UpdateGraphics">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Change the data and graphic of a tile in the tilemap.
	 * @param	X				The X coordinate of the tile (in tiles, not pixels).
	 * @param	Y				The Y coordinate of the tile (in tiles, not pixels).
	 * @param	Tile			The new integer data you wish to inject.
	 * @param	UpdateGraphics	Whether the graphical representation of this tile should change.
	 * @return	Whether or not the tile was actually changed.</haxe_doc>
		</setTile>
		<getTileCoords public="1" set="method" line="1318">
			<f a="Index:?Midpoint">
				<c path="Int"/>
				<e path="Bool"/>
				<c path="Array"><c path="org.flixel.FlxPoint"/></c>
			</f>
			<haxe_doc><![CDATA[* Returns a new Flash <code>Array</code> full of every coordinate of the requested tile type.
	 * @param	Index		The requested tile type.
	 * @param	Midpoint	Whether to return the coordinates of the tile midpoint, or upper left corner. Default is true, return midpoint.
	 * @return	An <code>Array</code> with a list of all the coordinates of that tile type.]]></haxe_doc>
		</getTileCoords>
		<getTileInstances public="1" set="method" line="1291">
			<f a="Index">
				<c path="Int"/>
				<c path="Array"><c path="Int"/></c>
			</f>
			<haxe_doc><![CDATA[* Returns a new Flash <code>Array</code> full of every map index of the requested tile type.
	 * @param	Index	The requested tile type.
	 * @return	An <code>Array</code> with a list of all map indices of that tile type.]]></haxe_doc>
		</getTileInstances>
		<getTileByIndex public="1" set="method" line="1281">
			<f a="Index">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>* Get the value of a tile in the tilemap by index.
	 * 
	 * @param	Index	The slot in the data array (Y * widthInTiles + X) where this tile is stored.
	 * 
	 * @return	A uint containing the value of the tile at this spot in the array.</haxe_doc>
		</getTileByIndex>
		<getTile public="1" set="method" line="1268">
			<f a="X:Y">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>* Check the value of a particular tile.
	 * @param	X		The X coordinate of the tile (in tiles, not pixels).
	 * @param	Y		The Y coordinate of the tile (in tiles, not pixels).
	 * @return	A uint containing the value of the tile at this spot in the array.</haxe_doc>
		</getTile>
		<overlapsPoint public="1" set="method" line="1245" override="1">
			<f a="point:?InScreenSpace:?Camera">
				<c path="org.flixel.FlxPoint"/>
				<e path="Bool"/>
				<c path="org.flixel.FlxCamera"/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Checks to see if a point in 2D world space overlaps this <code>FlxObject</code> object.
	 * @param	point			The point in world space you want to check.
	 * @param	InScreenSpace	Whether to take scroll factors into account when checking for overlap.
	 * @param	Camera			Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether or not the point overlaps this object.]]></haxe_doc>
		</overlapsPoint>
		<overlapsWithCallback public="1" set="method" line="1136">
			<f a="Object:?Callback:?FlipCallbackParams:?Position">
				<c path="org.flixel.FlxObject"/>
				<f a=":">
					<c path="org.flixel.FlxObject"/>
					<c path="org.flixel.FlxObject"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
				<c path="org.flixel.FlxPoint"/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Checks if the Object overlaps any tiles with any collision flags set,
	 * and calls the specified callback function (if there is one).
	 * Also calls the tile's registered callback if the filter matches.
	 * @param	Object				The <code>FlxObject</code> you are checking for overlaps against.
	 * @param	Callback			An optional function that takes the form "myCallback(Object1:FlxObject,Object2:FlxObject)", where Object1 is a FlxTile object, and Object2 is the object passed in in the first parameter of this method.
	 * @param	FlipCallbackParams	Used to preserve A-B list ordering from FlxObject.separate() - returns the FlxTile object as the second parameter instead.
	 * @param	Position			Optional, specify a custom position for the tilemap (useful for overlapsAt()-type funcitonality).
	 * @return	Whether there were overlaps, or if a callback was specified, whatever the return value of the callback was.]]></haxe_doc>
		</overlapsWithCallback>
		<overlapsAt public="1" set="method" line="1086" override="1">
			<f a="X:Y:ObjectOrGroup:?InScreenSpace:?Camera">
				<c path="Float"/>
				<c path="Float"/>
				<c path="org.flixel.FlxBasic"/>
				<e path="Bool"/>
				<c path="org.flixel.FlxCamera"/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Checks to see if this <code>FlxObject</code> were located at the given position, would it overlap the <code>FlxObject</code> or <code>FlxGroup</code>?
	 * This is distinct from overlapsPoint(), which just checks that point, rather than taking the object's size into account.
	 * WARNING: Currently tilemaps do NOT support screen space overlap checks! 
	 * @param	X				The X position you want to check.  Pretends this object (the caller, not the parameter) is located here.
	 * @param	Y				The Y position you want to check.  Pretends this object (the caller, not the parameter) is located here.
	 * @param	ObjectOrGroup	The object or group being tested.
	 * @param	InScreenSpace	Whether to take scroll factors into account when checking for overlap.  Default is false, or "only compare in world space."
	 * @param	Camera			Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether or not the two objects overlap.]]></haxe_doc>
		</overlapsAt>
		<overlaps public="1" set="method" line="1038" override="1">
			<f a="ObjectOrGroup:?InScreenSpace:?Camera">
				<c path="org.flixel.FlxBasic"/>
				<e path="Bool"/>
				<c path="org.flixel.FlxCamera"/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Checks to see if some <code>FlxObject</code> overlaps this <code>FlxObject</code> object in world space.
	 * If the group has a LOT of things in it, it might be faster to use <code>FlxG.overlaps()</code>.
	 * WARNING: Currently tilemaps do NOT support screen space overlap checks!
	 * @param	Object			The object being tested.
	 * @param	InScreenSpace	Whether to take scroll factors into account when checking for overlap.
	 * @param	Camera			Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether or not the two objects overlap.]]></haxe_doc>
		</overlaps>
		<walkPath set="method" line="947">
			<f a="Data:Start:Points">
				<c path="Array"><c path="Int"/></c>
				<c path="Int"/>
				<c path="Array"><c path="org.flixel.FlxPoint"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Pathfinding helper function, recursively walks the grid and finds a shortest path back to the start.
	 * @param	Data	A Flash <code>Array</code> of distance information.
	 * @param	Start	The tile we're on in our walk backward.
	 * @param	Points	A Flash <code>Array</code> of <code>FlxPoint</code> nodes composing the path from the start to the end, compiled in reverse order.]]></haxe_doc>
		</walkPath>
		<computePathDistance set="method" line="783">
			<f a="StartIndex:EndIndex:WideDiagonal">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
				<c path="Array"><c path="Int"/></c>
			</f>
			<haxe_doc><![CDATA[* Pathfinding helper function, floods a grid with distance information until it finds the end point.
	 * NOTE: Currently this process does NOT use any kind of fancy heuristic!  It's pretty brute.
	 * @param	StartIndex	The starting tile's map index.
	 * @param	EndIndex	The ending tile's map index.
	 * @param   WideDiagonal Whether to require an additional tile to make diagonal movement. Default value is true.
	 * @return	A Flash <code>Array</code> of <code>FlxPoint</code> nodes.  If the end tile could not be found, then a null <code>Array</code> is returned instead.]]></haxe_doc>
		</computePathDistance>
		<raySimplifyPath set="method" line="746">
			<f a="Points">
				<c path="Array"><c path="org.flixel.FlxPoint"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Pathfinding helper function, strips out even more points by raycasting from one point to the next and dropping unnecessary points.
	 * @param	Points		An array of <code>FlxPoint</code> nodes.]]></haxe_doc>
		</raySimplifyPath>
		<simplifyPath set="method" line="717">
			<f a="Points">
				<c path="Array"><c path="org.flixel.FlxPoint"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Pathfinding helper function, strips out extra points on the same line.
	 * @param	Points		An array of <code>FlxPoint</code> nodes.]]></haxe_doc>
		</simplifyPath>
		<findPath public="1" set="method" line="656">
			<f a="Start:End:?Simplify:?RaySimplify:?WideDiagonal">
				<c path="org.flixel.FlxPoint"/>
				<c path="org.flixel.FlxPoint"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="org.flixel.FlxPath"/>
			</f>
			<haxe_doc><![CDATA[* Find a path through the tilemap.  Any tile with any collision flags set is treated as impassable.
	 * If no path is discovered then a null reference is returned.
	 * @param	Start		The start point in world coordinates.
	 * @param	End			The end point in world coordinates.
	 * @param	Simplify	Whether to run a basic simplification algorithm over the path data, removing extra points that are on the same line.  Default value is true.
	 * @param	RaySimplify	Whether to run an extra raycasting simplification algorithm over the remaining path data.  This can result in some close corners being cut, and should be used with care if at all (yet).  Default value is false.
	 * @param   WideDiagonal   Whether to require an additional tile to make diagonal movement. Default value is true;
	 * @return	A <code>FlxPath</code> from the start to the end.  If no path could be found, then a null reference is returned.]]></haxe_doc>
		</findPath>
		<setDirty public="1" set="method" line="636">
			<f a="?Dirty">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the dirty flag on all the tilemap buffers.
	 * Basically forces a reset of the drawn tilemaps, even if it wasn'tile necessary.
	 * @param	Dirty		Whether to flag the tilemap buffers as dirty or not.</haxe_doc>
		</setDirty>
		<getData public="1" set="method" line="612">
			<f a="?Simple">
				<e path="Bool"/>
				<c path="Array"><c path="Int"/></c>
			</f>
			<haxe_doc>* Fetches the tilemap data array.
	 * @param	Simple		If true, returns the data as copy, as a series of 1s and 0s (useful for auto-tiling stuff). Default value is false, meaning it will return the actual data array (NOT a copy).
	 * @return	An array the size of the tilemap full of integers indicating tile placement.</haxe_doc>
		</getData>
		<draw public="1" set="method" line="551" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Draws the tilemap buffers to the cameras and handles flickering.</haxe_doc>
		</draw>
		<drawTilemap set="method" line="386">
			<f a="Buffer:Camera">
				<c path="org.flixel.system.FlxTilemapBuffer"/>
				<c path="org.flixel.FlxCamera"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Internal function that actually renders the tilemap to the tilemap buffer.  Called by draw().
	 * @param	Buffer		The <code>FlxTilemapBuffer</code> you are rendering to.
	 * @param	Camera		The related <code>FlxCamera</code>, mainly for scroll values.]]></haxe_doc>
		</drawTilemap>
		<update public="1" set="method" line="372" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Main logic loop for tilemap is pretty simple,
	 * just checks to see if visual debug got turned on.
	 * If it did, the tilemap is flagged as dirty so it
	 * will be redrawn with debug info on the next draw call.</haxe_doc>
		</update>
		<makeDebugTile set="method" line="343">
			<f a="Color">
				<t path="UInt"/>
				<t path="nme.display.BitmapData"/>
			</f>
			<haxe_doc>* Internal function to clean up the map loading code.
	 * Just generates a wireframe box the size of a tile with the specified color.</haxe_doc>
		</makeDebugTile>
		<loadMap public="1" set="method" line="223">
			<f a="MapData:TileGraphic:?TileWidth:?TileHeight:?AutoTile:?StartingIndex:?DrawIndex:?CollideIndex">
				<d/>
				<d/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="org.flixel.FlxTilemap"/>
			</f>
			<haxe_doc><![CDATA[* Load the tilemap with string data and a tile graphic.
	 * @param	MapData      	A string of comma and line-return delineated indices indicating what order the tiles should go in, or an <code>Array of Int</code>. YOU MUST SET <code>widthInTiles</code> and <code>heightInTyles</code> manually BEFORE CALLING <code>loadMap</code> if you pass an Array!
	 * @param	TileGraphic		All the tiles you want to use, arranged in a strip corresponding to the numbers in MapData.
	 * @param	TileWidth		The width of your tiles (e.g. 8) - defaults to height of the tile graphic if unspecified.
	 * @param	TileHeight		The height of your tiles (e.g. 8) - defaults to width if unspecified.
	 * @param	AutoTile		Whether to load the map using an automatic tile placement algorithm.  Setting this to either AUTO or ALT will override any values you put for StartingIndex, DrawIndex, or CollideIndex.
	 * @param	StartingIndex	Used to sort of insert empty tiles in front of the provided graphic.  Default is 0, usually safest ot leave it at that.  Ignored if AutoTile is set.
	 * @param	DrawIndex		Initializes all tile objects equal to and after this index as visible. Default value is 1.  Ignored if AutoTile is set.
	 * @param	CollideIndex	Initializes all tile objects equal to and after this index as allowCollisions = ANY.  Default value is 1.  Ignored if AutoTile is set.  Can override and customize per-tile-type collision behavior using <code>setTileProperties()</code>.	
	 * @return	A pointer this instance of FlxTilemap, for chaining as usual :)]]></haxe_doc>
		</loadMap>
		<destroy public="1" set="method" line="177" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_startingIndex>
			<c path="Int"/>
			<haxe_doc>* Internal, used to sort of insert blank tiles in front of the tiles in the provided graphic.</haxe_doc>
		</_startingIndex>
		<_lastVisualDebug>
			<e path="Bool"/>
			<haxe_doc>* Internal flag for checking to see if we need to refresh
	 * the tilemap display to show or hide the bounding boxes.</haxe_doc>
		</_lastVisualDebug>
		<_debugRect>
			<t path="nme.geom.Rectangle"/>
			<haxe_doc>* Internal, used for rendering the debug bounding box display.</haxe_doc>
		</_debugRect>
		<_debugTileSolid>
			<t path="nme.display.BitmapData"/>
			<haxe_doc>* Internal, used for rendering the debug bounding box display.</haxe_doc>
		</_debugTileSolid>
		<_debugTilePartial>
			<t path="nme.display.BitmapData"/>
			<haxe_doc>* Internal, used for rendering the debug bounding box display.</haxe_doc>
		</_debugTilePartial>
		<_debugTileNotSolid>
			<t path="nme.display.BitmapData"/>
			<haxe_doc>* Internal, used for rendering the debug bounding box display.</haxe_doc>
		</_debugTileNotSolid>
		<_tileObjects>
			<c path="Array"><c path="org.flixel.system.FlxTile"/></c>
			<haxe_doc>* Internal collection of tile objects, one for each type of tile in the map (NOTE one for every single tile in the whole map).</haxe_doc>
		</_tileObjects>
		<_tileHeight>
			<c path="Int"/>
			<haxe_doc>* Internal, the height of a single tile.</haxe_doc>
		</_tileHeight>
		<_tileWidth>
			<c path="Int"/>
			<haxe_doc>* Internal, the width of a single tile.</haxe_doc>
		</_tileWidth>
		<_rects>
			<c path="Array"><t path="nme.geom.Rectangle"/></c>
			<haxe_doc>* Internal representation of rectangles, one for each tile in the entire tilemap, used to speed up drawing.</haxe_doc>
		</_rects>
		<_data>
			<c path="Array"><c path="Int"/></c>
			<haxe_doc>* Internal representation of the actual tile data, as a large 1D array of integers.</haxe_doc>
		</_data>
		<_buffers>
			<c path="Array"><c path="org.flixel.system.FlxTilemapBuffer"/></c>
			<haxe_doc>* Internal list of buffers, one for each camera, used for drawing the tilemaps.</haxe_doc>
		</_buffers>
		<_tiles>
			<t path="nme.display.BitmapData"/>
			<haxe_doc>* Internal reference to the bitmap data object that stores the original tile graphics.</haxe_doc>
		</_tiles>
		<_flashRect>
			<t path="nme.geom.Rectangle"/>
			<haxe_doc>* Rendering helper, minimize new object instantiation on repetitive methods.</haxe_doc>
		</_flashRect>
		<_flashPoint>
			<t path="nme.geom.Point"/>
			<haxe_doc>* Rendering helper, minimize new object instantiation on repetitive methods.</haxe_doc>
		</_flashPoint>
		<totalTiles public="1">
			<c path="Int"/>
			<haxe_doc>* Read-only variable, do NOT recommend changing after the map is loaded!</haxe_doc>
		</totalTiles>
		<heightInTiles public="1">
			<c path="Int"/>
			<haxe_doc>* Read-only variable, do NOT recommend changing after the map is loaded!</haxe_doc>
		</heightInTiles>
		<widthInTiles public="1">
			<c path="Int"/>
			<haxe_doc>* Read-only variable, do NOT recommend changing after the map is loaded!</haxe_doc>
		</widthInTiles>
		<auto public="1">
			<c path="Int"/>
			<haxe_doc>* Set this flag to use one of the 16-tile binary auto-tile algorithms (OFF, AUTO, or ALT).</haxe_doc>
		</auto>
		<new public="1" set="method" line="137">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* The tilemap constructor just initializes some basic variables.</haxe_doc>
		</new>
		<haxe_doc>* This is a traditional tilemap display and collision class.
 * It takes a string of comma-separated numbers and then associates
 * those values with tiles from the sheet you pass in.
 * It also includes some handy static parsers that can convert
 * arrays or images into strings that can be loaded.</haxe_doc>
	</class>
	<class path="org.flixel.FlxTimer" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/FlxTimer.hx">
		<manager public="1" get="getManager" set="null" static="1"><c path="org.flixel.plugin.TimerManager"/></manager>
		<getManager public="1" set="method" line="180" static="1"><f a=""><c path="org.flixel.plugin.TimerManager"/></f></getManager>
		<getProgress public="1" set="method" line="166">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Read-only: how far along the timer is, on a scale of 0.0 to 1.0.</haxe_doc>
		</getProgress>
		<progress public="1" get="getProgress" set="null"><c path="Float"/></progress>
		<getLoopsLeft public="1" set="method" line="156">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* Read-only: check how many loops are left on the timer.</haxe_doc>
		</getLoopsLeft>
		<loopsLeft public="1" get="getLoopsLeft" set="null"><c path="Int"/></loopsLeft>
		<getTimeLeft public="1" set="method" line="146">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Read-only: check how much time is left on the timer.</haxe_doc>
		</getTimeLeft>
		<timeLeft public="1" get="getTimeLeft" set="null"><c path="Float"/></timeLeft>
		<stop public="1" set="method" line="131">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Stops the timer and removes it from the timer manager.</haxe_doc>
		</stop>
		<start public="1" set="method" line="103">
			<f a="?Time:?Loops:?Callback">
				<c path="Float"/>
				<c path="Int"/>
				<f a="">
					<c path="org.flixel.FlxTimer"/>
					<e path="Void"/>
				</f>
				<c path="org.flixel.FlxTimer"/>
			</f>
			<haxe_doc>* Starts or resumes the timer.  If this timer was paused,
	 * then all the parameters are ignored, and the timer is resumed.
	 * Adds the timer to the timer manager.
	 * @param	Time		How many seconds it takes for the timer to go off.
	 * @param	Loops		How many times the timer should go off.  Default is 1, or "just count down once."
	 * @param	Callback	Optional, triggered whenever the time runs out, once for each loop.  Callback should be formed "onTimer(Timer:FlxTimer);"
	 * @return	A reference to itself (handy for chaining or whatever).</haxe_doc>
		</start>
		<update public="1" set="method" line="74">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Called by the timer manager plugin to update the timer.
	 * If time runs out, the loop counter is advanced, the timer reset, and the callback called if it exists.
	 * If the timer runs out of loops, then the timer calls <code>stop()</code>.
	 * However, callbacks are called AFTER <code>stop()</code> is called.]]></haxe_doc>
		</update>
		<destroy public="1" set="method" line="62">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_loopsCounter>
			<c path="Int"/>
			<haxe_doc>* Internal tracker for the loops counting up.</haxe_doc>
		</_loopsCounter>
		<_timeCounter>
			<c path="Float"/>
			<haxe_doc>* Internal tracker for the actual timer counting up.</haxe_doc>
		</_timeCounter>
		<_callback>
			<f a="">
				<c path="org.flixel.FlxTimer"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Internal tracker for the time's-up callback function.
	 * Callback should be formed "onTimer(Timer:FlxTimer);"</haxe_doc>
		</_callback>
		<finished public="1">
			<e path="Bool"/>
			<haxe_doc>* Check to see if the timer is finished.</haxe_doc>
		</finished>
		<paused public="1">
			<e path="Bool"/>
			<haxe_doc>* Pauses or checks the pause state of the timer.</haxe_doc>
		</paused>
		<loops public="1">
			<c path="Int"/>
			<haxe_doc>* How many loops the timer was set for.</haxe_doc>
		</loops>
		<time public="1">
			<c path="Float"/>
			<haxe_doc>* How much time the timer was set for.</haxe_doc>
		</time>
		<new public="1" set="method" line="47">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Instantiate the timer.  Does not set or start the timer.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A simple timer class, leveraging the new plugins system.
 * Can be used with callbacks or by polling the <code>finished</code> flag.
 * Not intended to be added to a game state or group; the timer manager
 * is responsible for actually calling update(), not the user.]]></haxe_doc>
	</class>
	<class path="org.flixel.FlxU" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/FlxU.hx">
		<openURL public="1" get="inline" set="null" line="21" static="1">
			<f a="URL">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Opens a web page in a new tab or window.
	 * 
	 * @param	URL		The address of the web page.</haxe_doc>
		</openURL>
		<abs public="1" get="inline" set="null" line="31" static="1">
			<f a="Value">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>* Calculate the absolute value of a number.
	 * @param	Value	Any number.
	 * @return	The absolute value of that number.</haxe_doc>
		</abs>
		<floor public="1" get="inline" set="null" line="41" static="1">
			<f a="Value">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>* Round down to the next whole number. E.g. floor(1.7) == 1, and floor(-2.7) == -2.
	 * @param	Value	Any number.
	 * @return	The rounded value of that number.</haxe_doc>
		</floor>
		<ceil public="1" get="inline" set="null" line="52" static="1">
			<f a="Value">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>* Round up to the next whole number.  E.g. ceil(1.3) == 2, and ceil(-2.3) == -3.
	 * @param	Value	Any number.
	 * @return	The rounded value of that number.</haxe_doc>
		</ceil>
		<round public="1" get="inline" set="null" line="63" static="1">
			<f a="Value">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>* Round to the closest whole number. E.g. round(1.7) == 2, and round(-2.3) == -2.
	 * @param	Value	Any number.
	 * @return	The rounded value of that number.</haxe_doc>
		</round>
		<min public="1" get="inline" set="null" line="74" static="1">
			<f a="Number1:Number2">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>* Figure out which number is smaller.
	 * @param	Number1		Any number.
	 * @param	Number2		Any number.
	 * @return	The smaller of the two numbers.</haxe_doc>
		</min>
		<max public="1" get="inline" set="null" line="85" static="1">
			<f a="Number1:Number2">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>* Figure out which number is larger.
	 * @param	Number1		Any number.
	 * @param	Number2		Any number.
	 * @return	The larger of the two numbers.</haxe_doc>
		</max>
		<bound public="1" get="inline" set="null" line="99" static="1">
			<f a="Value:Min:Max">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>* Bound a number by a minimum and maximum.
	 * Ensures that this number is no smaller than the minimum,
	 * and no larger than the maximum.
	 * @param	Value	Any number.
	 * @param	Min		Any number.
	 * @param	Max		Any number.
	 * @return	The bounded value of the number.</haxe_doc>
		</bound>
		<srand public="1" get="inline" set="null" line="110" static="1">
			<f a="Seed">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Generates a random number based on the seed provided.
	 * @param	Seed	A number between 0 and 1, used to generate a predictable random number (very optional).
	 * @return	A <code>Number</code> between 0 and 1.]]></haxe_doc>
		</srand>
		<shuffle public="1" get="inline" set="null" line="127" static="1">
			<f a="Objects:HowManyTimes">
				<c path="Array"><d/></c>
				<c path="Int"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc><![CDATA[* Shuffles the entries in an array into a new random order.
	 * <code>FlxG.shuffle()</code> is deterministic and safe for use with replays/recordings.
	 * HOWEVER, <code>FlxU.shuffle()</code> is NOT deterministic and unsafe for use with replays/recordings.
	 * @param	A				A Flash <code>Array</code> object containing...stuff.
	 * @param	HowManyTimes	How many swaps to perform during the shuffle operation.  Good rule of thumb is 2-4 times as many objects are in the list.
	 * @return	The same Flash <code>Array</code> object that you passed in in the first place.]]></haxe_doc>
		</shuffle>
		<getRandom public="1" get="inline" set="null" line="155" static="1">
			<f a="Objects:?StartIndex:?Length">
				<c path="Array"><d/></c>
				<c path="Int"/>
				<c path="Int"/>
				<d/>
			</f>
			<haxe_doc><![CDATA[* Fetch a random entry from the given array.
	 * Will return null if random selection is missing, or array has no entries.
	 * <code>FlxG.getRandom()</code> is deterministic and safe for use with replays/recordings.
	 * HOWEVER, <code>FlxU.getRandom()</code> is NOT deterministic and unsafe for use with replays/recordings.
	 * @param	Objects		A Flash array of objects.
	 * @param	StartIndex	Optional offset off the front of the array. Default value is 0, or the beginning of the array.
	 * @param	Length		Optional restriction on the number of values you want to randomly select from.
	 * @return	The random object that was selected.]]></haxe_doc>
		</getRandom>
		<getTicks public="1" get="inline" set="null" line="181" static="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc><![CDATA[* Just grabs the current "ticks" or time in milliseconds that has passed since Flash Player started up.
	 * Useful for finding out how long it takes to execute specific blocks of code.
	 * @return	A <code>uint</code> to be passed to <code>FlxU.endProfile()</code>.]]></haxe_doc>
		</getTicks>
		<formatTicks public="1" get="inline" set="null" line="193" static="1">
			<f a="StartTicks:EndTicks">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Takes two "ticks" timestamps and formats them into the number of seconds that passed as a String.
	 * Useful for logging, debugging, the watch window, or whatever else.
	 * @param	StartTicks	The first timestamp from the system.
	 * @param	EndTicks	The second timestamp from the system.
	 * @return	A <code>String</code> containing the formatted time elapsed information.]]></haxe_doc>
		</formatTicks>
		<makeColor public="1" get="inline" set="null" line="209" static="1">
			<f a="Red:Green:Blue:?Alpha">
				<t path="UInt"/>
				<t path="UInt"/>
				<t path="UInt"/>
				<c path="Float"/>
				<t path="UInt"/>
			</f>
			<haxe_doc><![CDATA[* Generate a Flash <code>uint</code> color from RGBA components.
	 * 
	 * @param   Red     The red component, between 0 and 255.
	 * @param   Green   The green component, between 0 and 255.
	 * @param   Blue    The blue component, between 0 and 255.
	 * @param   Alpha   How opaque the color should be, either between 0 and 1 or 0 and 255.
	 * 
	 * @return  The color as a <code>uint</code>.]]></haxe_doc>
		</makeColor>
		<makeColorFromHSB public="1" get="inline" set="null" line="227" static="1">
			<f a="Hue:Saturation:Brightness:?Alpha">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<t path="UInt"/>
			</f>
			<haxe_doc><![CDATA[* Generate a Flash <code>uint</code> color from HSB components.
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Brightness	A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
	 * @param   Alpha   	How opaque the color should be, either between 0 and 1 or 0 and 255.
	 * @return	The color as a <code>uint</code>.]]></haxe_doc>
		</makeColorFromHSB>
		<getRGBA public="1" get="inline" set="null" line="299" static="1">
			<f a="Color:?Results">
				<t path="UInt"/>
				<c path="Array"><c path="Float"/></c>
				<c path="Array"><c path="Float"/></c>
			</f>
			<haxe_doc><![CDATA[* Loads an array with the RGBA values of a Flash <code>uint</code> color.
	 * RGB values are stored 0-255.  Alpha is stored as a floating point number between 0 and 1.
	 * @param	Color	The color you want to break into components.
	 * @param	Results	An optional parameter, allows you to use an array that already exists in memory to store the result.
	 * @return	An <code>Array</code> object containing the Red, Green, Blue and Alpha values of the given color.]]></haxe_doc>
		</getRGBA>
		<getHSB public="1" get="inline" set="null" line="324" static="1">
			<f a="Color:?Results">
				<t path="UInt"/>
				<c path="Array"><c path="Float"/></c>
				<c path="Array"><c path="Float"/></c>
			</f>
			<haxe_doc><![CDATA[* Loads an array with the HSB values of a Flash <code>uint</code> color.
	 * Hue is a value between 0 and 360.  Saturation, Brightness and Alpha
	 * are as floating point numbers between 0 and 1.
	 * @param	Color	The color you want to break into components.
	 * @param	Results	An optional parameter, allows you to use an array that already exists in memory to store the result.
	 * @return	An <code>Array</code> object containing the Red, Green, Blue and Alpha values of the given color.]]></haxe_doc>
		</getHSB>
		<formatTime public="1" get="inline" set="null" line="383" static="1">
			<f a="Seconds:?ShowMS">
				<c path="Int"/>
				<e path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Format seconds as minutes with a colon, an optionally with milliseconds too.
	 * @param	Seconds		The number of seconds (for example, time remaining, time spent, etc).
	 * @param	ShowMS		Whether to show milliseconds after a "." as well.  Default value is false.
	 * @return	A nicely formatted <code>String</code>, like "1:03".]]></haxe_doc>
		</formatTime>
		<formatArray public="1" get="inline" set="null" line="412" static="1">
			<f a="AnyArray">
				<c path="Array"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Generate a comma-separated string from an array.
	 * Especially useful for tracing or other debug output.
	 * @param	AnyArray	Any <code>Array</code> object.
	 * @return	A comma-separated <code>String</code> containing the <code>.toString()</code> output of each element in the array.]]></haxe_doc>
		</formatArray>
		<formatMoney public="1" get="inline" set="null" line="438" static="1">
			<f a="Amount:?ShowDecimal:?EnglishStyle">
				<c path="Float"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Automatically commas and decimals in the right places for displaying money amounts.
	 * Does not include a dollar sign or anything, so doesn't really do much
	 * if you call say <code>var results:String = FlxU.formatMoney(10,false);</code>
	 * However, very handy for displaying large sums or decimal money values.
	 * @param	Amount			How much moneys (in dollars, or the equivalent "main" currency - i.e. not cents).
	 * @param	ShowDecimal		Whether to show the decimals/cents component. Default value is true.
	 * @param	EnglishStyle	Major quantities (thousands, millions, etc) separated by commas, and decimal by a period.  Default value is true.
	 * @return	A nicely formatted <code>String</code>.  Does not include a dollar sign or anything!]]></haxe_doc>
		</formatMoney>
		<getClassName public="1" get="inline" set="null" line="492" static="1">
			<f a="Obj:?Simple">
				<d/>
				<e path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Get the <code>String</code> name of any <code>Object</code>.
	 * @param	Obj		The <code>Object</code> object in question.
	 * @param	Simple	Returns only the class name, not the package or packages.
	 * @return	The name of the <code>Class</code> as a <code>String</code> object.]]></haxe_doc>
		</getClassName>
		<compareClassNames public="1" get="inline" set="null" line="512" static="1">
			<f a="Object1:Object2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Check to see if two objects have the same class name.
	 * @param	Object1		The first object you want to check.
	 * @param	Object2		The second object you want to check.
	 * @return	Whether they have the same class name or not.</haxe_doc>
		</compareClassNames>
		<getClass public="1" get="inline" set="null" line="522" static="1">
			<f a="Name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc><![CDATA[* Look up a <code>Class</code> object by its string name.
	 * @param	Name	The <code>String</code> name of the <code>Class</code> you are interested in.
	 * @return	A <code>Class</code> object.]]></haxe_doc>
		</getClass>
		<computeVelocity public="1" get="inline" set="null" line="536" static="1">
			<f a="Velocity:Acceleration:Drag:Max">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>* A tween-like function that takes a starting velocity
	 * and some other factors and returns an altered velocity.
	 * @param	Velocity		Any component of velocity (e.g. 20).
	 * @param	Acceleration	Rate at which the velocity is changing.
	 * @param	Drag			Really kind of a deceleration, this is how much the velocity changes if Acceleration is not set.
	 * @param	Max				An absolute value cap for the velocity (0 for no cap).
	 * @return	The altered Velocity value.</haxe_doc>
		</computeVelocity>
		<rotatePoint public="1" get="inline" set="null" line="584" static="1">
			<f a="X:Y:PivotX:PivotY:Angle:?point">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="org.flixel.FlxPoint"/>
				<c path="org.flixel.FlxPoint"/>
			</f>
			<haxe_doc><![CDATA[* Rotates a point in 2D space around another point by the given angle.
	 * @param	X		The X coordinate of the point you want to rotate.
	 * @param	Y		The Y coordinate of the point you want to rotate.
	 * @param	PivotX	The X coordinate of the point you want to rotate around.
	 * @param	PivotY	The Y coordinate of the point you want to rotate around.
	 * @param	Angle	Rotate the point by this many degrees.
	 * @param	Point	Optional <code>FlxPoint</code> to store the results in.
	 * @return	A <code>FlxPoint</code> containing the coordinates of the rotated point.]]></haxe_doc>
		</rotatePoint>
		<getAngle public="1" get="inline" set="null" line="672" static="1">
			<f a="Point1:Point2">
				<c path="org.flixel.FlxPoint"/>
				<c path="org.flixel.FlxPoint"/>
				<c path="Float"/>
			</f>
			<haxe_doc>* Calculates the angle between two points.  0 degrees points straight up.
	 * @param	Point1		The X coordinate of the point.
	 * @param	Point2		The Y coordinate of the point.
	 * @return	The angle in degrees, between -180 and 180.</haxe_doc>
		</getAngle>
		<getDistance public="1" get="inline" set="null" line="710" static="1">
			<f a="Point1:Point2">
				<c path="org.flixel.FlxPoint"/>
				<c path="org.flixel.FlxPoint"/>
				<c path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Calculate the distance between two points.
	 * @param Point1	A <code>FlxPoint</code> object referring to the first location.
	 * @param Point2	A <code>FlxPoint</code> object referring to the second location.
	 * @return	The distance between the two points as a floating point <code>Number</code> object.]]></haxe_doc>
		</getDistance>
		<ArrayIndexOf public="1" get="inline" set="null" line="717" static="1"><f a="array:whatToFind:?fromIndex">
	<c path="Array"><d/></c>
	<d/>
	<c path="Int"/>
	<c path="Int"/>
</f></ArrayIndexOf>
		<SetArrayLength public="1" set="method" line="731" static="1"><f a="array:newLength">
	<c path="Array"><d/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></SetArrayLength>
		<fromIntToUInt public="1" get="inline" set="null" line="754" static="1"><f a="number">
	<c path="Int"/>
	<c path="Int"/>
</f></fromIntToUInt>
		<MIN_VALUE public="1" get="inline" set="null" line="760" static="1"><c path="Float"/></MIN_VALUE>
		<MAX_VALUE public="1" get="inline" set="null" line="764" static="1"><c path="Float"/></MAX_VALUE>
		<new public="1" set="method" line="14"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Zaphod</haxe_doc>
	</class>
	<class path="org.flixel.plugin.DebugPathDisplay" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/plugin/DebugPathDisplay.hx">
		<extends path="org.flixel.FlxBasic"/>
		<clear public="1" set="method" line="112">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Removes all the paths from the path debug display manager.</haxe_doc>
		</clear>
		<remove public="1" set="method" line="99">
			<f a="Path">
				<c path="org.flixel.FlxPath"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Remove a path from the path debug display manager.
	 * Usually called automatically by <code>FlxPath</code>'s <code>destroy()</code> function.
	 * @param	Path	The <code>FlxPath</code> you want to remove from the manager.]]></haxe_doc>
		</remove>
		<add public="1" set="method" line="89">
			<f a="Path">
				<c path="org.flixel.FlxPath"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Add a path to the path debug display manager.
	 * Usually called automatically by <code>FlxPath</code>'s constructor.
	 * @param	Path	The <code>FlxPath</code> you want to add to the manager.]]></haxe_doc>
		</add>
		<drawDebug public="1" set="method" line="65" override="1">
			<f a="?Camera">
				<c path="org.flixel.FlxCamera"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Similar to <code>FlxObject</code>'s <code>drawDebug()</code> functionality,
	 * this function calls <code>drawDebug()</code> on each <code>FlxPath</code> for the specified camera.
	 * Very helpful for debugging!
	 * @param	Camera	Which <code>FlxCamera</code> object to draw the debug data to.]]></haxe_doc>
		</drawDebug>
		<draw public="1" set="method" line="40" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Called by <code>FlxG.drawPlugins()</code> after the game state has been drawn.
	 * Cycles through cameras and calls <code>drawDebug()</code> on each one.]]></haxe_doc>
		</draw>
		<destroy public="1" set="method" line="29" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_paths><c path="Array"><c path="org.flixel.FlxPath"/></c></_paths>
		<new public="1" set="method" line="18">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Instantiates a new debug path display manager.</haxe_doc>
		</new>
		<haxe_doc>* A simple manager for tracking and drawing FlxPath debug data to the screen.</haxe_doc>
	</class>
	<class path="org.flixel.plugin.TimerManager" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/plugin/TimerManager.hx">
		<extends path="org.flixel.FlxBasic"/>
		<clear public="1" set="method" line="81">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Removes all the timers from the timer manager.</haxe_doc>
		</clear>
		<remove public="1" set="method" line="68">
			<f a="Timer">
				<c path="org.flixel.FlxTimer"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Remove a timer from the timer manager.
	 * Usually called automatically by <code>FlxTimer</code>'s <code>stop()</code> function.
	 * @param	Timer	The <code>FlxTimer</code> you want to remove from the manager.]]></haxe_doc>
		</remove>
		<add public="1" set="method" line="58">
			<f a="Timer">
				<c path="org.flixel.FlxTimer"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Add a new timer to the timer manager.
	 * Usually called automatically by <code>FlxTimer</code>'s constructor.
	 * @param	Timer	The <code>FlxTimer</code> you want to add to the manager.]]></haxe_doc>
		</add>
		<update public="1" set="method" line="39" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Called by <code>FlxG.updatePlugins()</code> before the game state has been updated.
	 * Cycles through timers and calls <code>update()</code> on each one.]]></haxe_doc>
		</update>
		<destroy public="1" set="method" line="28" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_timers><c path="Array"><c path="org.flixel.FlxTimer"/></c></_timers>
		<new public="1" set="method" line="17">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Instantiates a new timer manager.</haxe_doc>
		</new>
		<haxe_doc>* A simple manager for tracking and updating game timer objects.</haxe_doc>
	</class>
	<class path="org.flixel.plugin.pxText.PxBitmapFont" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/plugin/pxText/PxBitmapFont.hx">
		<_storedFonts line="22" static="1"><c path="Hash"><c path="org.flixel.plugin.pxText.PxBitmapFont"/></c></_storedFonts>
		<ZERO_POINT line="24" static="1"><t path="nme.geom.Point"/></ZERO_POINT>
		<store public="1" set="method" line="754" static="1">
			<f a="pHandle:pFont">
				<c path="String"/>
				<c path="org.flixel.plugin.pxText.PxBitmapFont"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Stores a font for global use using an identifier.
	 * @param	pHandle	String identifer for the font.
	 * @param	pFont	Font to store.</haxe_doc>
		</store>
		<fetch public="1" set="method" line="764" static="1">
			<f a="pHandle">
				<c path="String"/>
				<c path="org.flixel.plugin.pxText.PxBitmapFont"/>
			</f>
			<haxe_doc>* Retrieves a font previously stored.
	 * @param	pHandle	Identifier of font to fetch.
	 * @return	Stored font, or null if no font was found.</haxe_doc>
		</fetch>
		<clearStorage public="1" set="method" line="770" static="1"><f a=""><e path="Void"/></f></clearStorage>
		<get_numLetters public="1" set="method" line="740"><f a=""><c path="Int"/></f></get_numLetters>
		<numLetters public="1" get="get_numLetters" set="null">
			<c path="Int"/>
			<haxe_doc>* Returns number of letters available in this font.
	 * @return Number of letters available in this font.</haxe_doc>
		</numLetters>
		<getFontHeight public="1" set="method" line="708">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* Returns height of font in pixels.
	 * @return Height of font in pixels.</haxe_doc>
		</getFontHeight>
		<getTextWidth public="1" set="method" line="670">
			<f a="pText:?pLetterSpacing:?pFontScale">
				<c path="String"/>
				<c path="Int"/>
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>* Returns the width of a certain test string.
	 * @param	pText	String to measure.
	 * @param	pLetterSpacing	distance between letters
	 * @param	pFontScale	"size" of the font
	 * @return	Width in pixels.</haxe_doc>
		</getTextWidth>
		<render public="1" set="method" line="585">
			<f a="pBitmapData:pFontData:pText:pColor:pOffsetX:pOffsetY:pLetterSpacing">
				<t path="nme.display.BitmapData"/>
				<c path="Array"><t path="nme.display.BitmapData"/></c>
				<c path="String"/>
				<t path="UInt"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Renders a string of text onto bitmap data using the font.
	 * @param	pBitmapData	Where to render the text.
	 * @param	pText	Test to render.
	 * @param	pColor	Color of text to render.
	 * @param	pOffsetX	X position of thext output.
	 * @param	pOffsetY	Y position of thext output.</haxe_doc>
		</render>
		<setGlyph set="method" line="541"><f a="pCharID:pBitmapData">
	<c path="Int"/>
	<t path="nme.display.BitmapData"/>
	<e path="Void"/>
</f></setGlyph>
		<getFontData public="1" set="method" line="518">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Serializes font data to cryptic bit string.
	 * @return	Cryptic string with font as bits.</haxe_doc>
		</getFontData>
		<dispose public="1" set="method" line="484">
			<f a="?total">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Clears all resources used by the font.</haxe_doc>
		</dispose>
		<getPreparedGlyphs public="1" set="method" line="442"><f a="pScale:pColor:?pUseColorTransform">
	<c path="Float"/>
	<c path="Int"/>
	<e path="Bool"/>
	<c path="Array"><t path="nme.display.BitmapData"/></c>
</f></getPreparedGlyphs>
		<prepareAngelCodeBitmapData public="1" set="method" line="366"><f a="pBitmapData:pXMLData:pSymbols">
	<t path="nme.display.BitmapData"/>
	<c path="Xml"/>
	<c path="Array"><c path="org.flixel.plugin.pxText.HelperSymbol"/></c>
	<t path="nme.display.BitmapData"/>
</f></prepareAngelCodeBitmapData>
		<preparePixelizerBitmapData public="1" set="method" line="264"><f a="pBitmapData:pRects">
	<t path="nme.display.BitmapData"/>
	<c path="Array"><t path="nme.geom.Rectangle"/></c>
	<t path="nme.display.BitmapData"/>
</f></preparePixelizerBitmapData>
		<reset set="method" line="249">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* internal function. Resets current font</haxe_doc>
		</reset>
		<updateGlyphData public="1" set="method" line="140">
			<f a="?node">
				<c path="org.flixel.system.layer.Node"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* updates and caches tile data for passed node object</haxe_doc>
		</updateGlyphData>
		<loadAngelCode public="1" set="method" line="119">
			<f a="pBitmapData:pXMLData">
				<t path="nme.display.BitmapData"/>
				<c path="Xml"/>
				<c path="org.flixel.plugin.pxText.PxBitmapFont"/>
			</f>
			<haxe_doc>* Loads font data in AngelCode's format
	 * @param	pBitmapData	font image source
	 * @param	pXMLData	font data in XML format
	 * @return				this font</haxe_doc>
		</loadAngelCode>
		<loadPixelizer public="1" set="method" line="83">
			<f a="pBitmapData:pLetters">
				<t path="nme.display.BitmapData"/>
				<c path="String"/>
				<c path="org.flixel.plugin.pxText.PxBitmapFont"/>
			</f>
			<haxe_doc>* Loads font data in Pixelizer's format
	 * @param	pBitmapData	font source image
	 * @param	pLetters	all letters contained in this font
	 * @return				this font</haxe_doc>
		</loadPixelizer>
		<_bitmapDataKey><c path="String"/></_bitmapDataKey>
		<_pixels><t path="nme.display.BitmapData"/></_pixels>
		<_symbols><c path="Array"><c path="org.flixel.plugin.pxText.HelperSymbol"/></c></_symbols>
		<_tileRects><c path="Array"><t path="nme.geom.Rectangle"/></c></_tileRects>
		<_point><t path="nme.geom.Point"/></_point>
		<_colorTransform><t path="nme.geom.ColorTransform"/></_colorTransform>
		<_matrix><t path="nme.geom.Matrix"/></_matrix>
		<_maxHeight><c path="Int"/></_maxHeight>
		<_glyphString><c path="String"/></_glyphString>
		<_glyphs><c path="Array"><t path="nme.display.BitmapData"/></c></_glyphs>
		<new public="1" set="method" line="59">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Creates a new bitmap font using specified bitmap data and letter input.
	 * @param	pBitmapData	The bitmap data to copy letters from.
	 * @param	pLetters	String of letters available in the bitmap data.</haxe_doc>
		</new>
		<haxe_doc>* Holds information and bitmap glpyhs for a bitmap font.
 * @author Johan Peitz
 * @author Zaphod</haxe_doc>
	</class>
	<class path="org.flixel.plugin.pxText.HelperSymbol" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/plugin/pxText/PxBitmapFont.hx" module="org.flixel.plugin.pxText.PxBitmapFont">
		<charCode public="1"><c path="Int"/></charCode>
		<xadvance public="1"><c path="Int"/></xadvance>
		<yoffset public="1"><c path="Int"/></yoffset>
		<xoffset public="1"><c path="Int"/></xoffset>
		<height public="1"><c path="Int"/></height>
		<width public="1"><c path="Int"/></width>
		<y public="1"><c path="Int"/></y>
		<x public="1"><c path="Int"/></x>
		<new public="1" set="method" line="793"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="org.flixel.system.FlxAnim" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/system/FlxAnim.hx">
		<destroy public="1" set="method" line="47">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<looped public="1">
			<e path="Bool"/>
			<haxe_doc>* Whether or not the animation is looped</haxe_doc>
		</looped>
		<frames public="1">
			<c path="Array"><c path="Int"/></c>
			<haxe_doc><![CDATA[* A list of frames stored as <code>int</code> objects]]></haxe_doc>
		</frames>
		<delay public="1">
			<c path="Float"/>
			<haxe_doc>* Seconds between frames (basically the framerate)</haxe_doc>
		</delay>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* String name of the animation (e.g. "walk")</haxe_doc>
		</name>
		<new public="1" set="method" line="32">
			<f a="Name:Frames:?FrameRate:?Looped">
				<c path="String"/>
				<c path="Array"><c path="Int"/></c>
				<c path="Float"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * @param	Name		What this animation should be called (e.g. "run")
	 * @param	Frames		An array of numbers indicating what frames to play in what order (e.g. 1, 2, 3)
	 * @param	FrameRate	The speed in frames per second that the animation should play at (e.g. 40)
	 * @param	Looped		Whether or not the animation is looped or just plays once</haxe_doc>
		</new>
		<haxe_doc>* Just a helper structure for the FlxSprite animation system.</haxe_doc>
	</class>
	<class path="org.flixel.system.FlxDebugger" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/system/FlxDebugger.hx">
		<extends path="flash.display.Sprite"/>
		<resetLayout public="1" set="method" line="194">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Forces the debugger windows to reset to the last specified layout.
	 * The default layout is <code>FlxG.DEBUGGER_STANDARD</code>.]]></haxe_doc>
		</resetLayout>
		<setLayout public="1" set="method" line="184">
			<f a="Layout">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Rearrange the debugger windows using one of the constants specified in FlxG.
	 * @param	Layout		The layout style for the debugger windows, e.g. <code>FlxG.DEBUGGER_MICRO</code>.]]></haxe_doc>
		</setLayout>
		<onMouseOut set="method" line="175">
			<f a="?E">
				<t path="nme.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Mouse handler that helps with fake "mouse focus" type behavior.
	 * @param	E	Flash mouse event.</haxe_doc>
		</onMouseOut>
		<onMouseOver set="method" line="166">
			<f a="?E">
				<t path="nme.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Mouse handler that helps with fake "mouse focus" type behavior.
	 * @param	E	Flash mouse event.</haxe_doc>
		</onMouseOver>
		<destroy public="1" set="method" line="139">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_gutter>
			<c path="Int"/>
			<haxe_doc>* Internal, used to space out windows from the edges.</haxe_doc>
		</_gutter>
		<_screen>
			<t path="nme.geom.Point"/>
			<haxe_doc>* Internal, stores width and height of the Flash Player window.</haxe_doc>
		</_screen>
		<_layout>
			<c path="Int"/>
			<haxe_doc>* Internal, tracks what debugger window layout user has currently selected.</haxe_doc>
		</_layout>
		<hasMouse public="1">
			<e path="Bool"/>
			<haxe_doc>* Whether the mouse is currently over one of the debugger windows or not.</haxe_doc>
		</hasMouse>
		<vis public="1">
			<c path="org.flixel.system.debug.Vis"/>
			<haxe_doc>* Container for the visual debug mode toggle.</haxe_doc>
		</vis>
		<vcr public="1">
			<c path="org.flixel.system.debug.VCR"/>
			<haxe_doc>* Container for the record, stop and play buttons.</haxe_doc>
		</vcr>
		<watch public="1">
			<c path="org.flixel.system.debug.Watch"/>
			<haxe_doc>* Container for the watch window widget.</haxe_doc>
		</watch>
		<log public="1">
			<c path="org.flixel.system.debug.Log"/>
			<haxe_doc>* Container for the trace output widget.</haxe_doc>
		</log>
		<perf public="1">
			<c path="org.flixel.system.debug.Perf"/>
			<haxe_doc>* Container for the performance monitor widget.</haxe_doc>
		</perf>
		<new public="1" set="method" line="71">
			<f a="Width:Height">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Instantiates the debugger overlay.
	 * 
	 * @param Width		The width of the screen.
	 * @param Height	The height of the screen.</haxe_doc>
		</new>
		<haxe_doc>* Container for the new debugger overlay.
 * Most of the functionality is in the debug folder widgets,
 * but this class instantiates the widgets and handles their basic formatting and arrangement.</haxe_doc>
	</class>
	<class path="org.flixel.system.FlxList" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/system/FlxList.hx">
		<_NUM_CACHED_FLX_LIST public="1" line="16" static="1">
			<c path="Int"/>
			<haxe_doc>* Pooling mechanism, when FlxLists are destroyed, they get added to this collection, and when they get recycled they get removed.</haxe_doc>
		</_NUM_CACHED_FLX_LIST>
		<_cachedListsHead static="1"><c path="org.flixel.system.FlxList"/></_cachedListsHead>
		<recycle public="1" set="method" line="43" static="1">
			<f a=""><c path="org.flixel.system.FlxList"/></f>
			<haxe_doc>* Recycle a cached Linked List, or creates a new one if needed.</haxe_doc>
		</recycle>
		<clearCache public="1" set="method" line="62" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clear cached List nodes. You might want to do this when loading new levels (probably not though, no need to clear cache unless you run into memory problems).</haxe_doc>
		</clearCache>
		<destroy public="1" set="method" line="78">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<exists public="1"><e path="Bool"/></exists>
		<next public="1">
			<c path="org.flixel.system.FlxList"/>
			<haxe_doc>* Stores a reference to the next link in the list.</haxe_doc>
		</next>
		<object public="1">
			<c path="org.flixel.FlxObject"/>
			<haxe_doc><![CDATA[* Stores a reference to a <code>FlxObject</code>.]]></haxe_doc>
		</object>
		<new set="method" line="33">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Private, use recycle instead.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A miniature linked list class.
 * Useful for optimizing time-critical or highly repetitive tasks!
 * See <code>FlxQuadTree</code> for how to use it, IF YOU DARE.]]></haxe_doc>
	</class>
	<class path="org.flixel.system.FlxQuadTree" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/system/FlxQuadTree.hx">
		<extends path="org.flixel.FlxRect"/>
		<A_LIST public="1" get="inline" set="null" line="21" static="1">
			<c path="Int"/>
			<haxe_doc>* Flag for specifying that you want to add an object to the A list.</haxe_doc>
		</A_LIST>
		<B_LIST public="1" get="inline" set="null" line="25" static="1">
			<c path="Int"/>
			<haxe_doc>* Flag for specifying that you want to add an object to the B list.</haxe_doc>
		</B_LIST>
		<divisions public="1" static="1">
			<c path="Int"/>
			<haxe_doc>* Controls the granularity of the quad tree.  Default is 6 (decent performance on large and small worlds).</haxe_doc>
		</divisions>
		<_min static="1">
			<c path="Int"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_min>
		<_object static="1">
			<c path="org.flixel.FlxObject"/>
			<haxe_doc>* Internal, used to reduce recursive method parameters during object placement and tree formation.</haxe_doc>
		</_object>
		<_objectLeftEdge static="1">
			<c path="Float"/>
			<haxe_doc>* Internal, used to reduce recursive method parameters during object placement and tree formation.</haxe_doc>
		</_objectLeftEdge>
		<_objectTopEdge static="1">
			<c path="Float"/>
			<haxe_doc>* Internal, used to reduce recursive method parameters during object placement and tree formation.</haxe_doc>
		</_objectTopEdge>
		<_objectRightEdge static="1">
			<c path="Float"/>
			<haxe_doc>* Internal, used to reduce recursive method parameters during object placement and tree formation.</haxe_doc>
		</_objectRightEdge>
		<_objectBottomEdge static="1">
			<c path="Float"/>
			<haxe_doc>* Internal, used to reduce recursive method parameters during object placement and tree formation.</haxe_doc>
		</_objectBottomEdge>
		<_list static="1">
			<c path="Int"/>
			<haxe_doc>* Internal, used during tree processing and overlap checks.</haxe_doc>
		</_list>
		<_useBothLists static="1">
			<e path="Bool"/>
			<haxe_doc>* Internal, used during tree processing and overlap checks.</haxe_doc>
		</_useBothLists>
		<_processingCallback static="1">
			<f a=":">
				<c path="org.flixel.FlxObject"/>
				<c path="org.flixel.FlxObject"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Internal, used during tree processing and overlap checks.</haxe_doc>
		</_processingCallback>
		<_notifyCallback static="1">
			<f a=":">
				<c path="org.flixel.FlxObject"/>
				<c path="org.flixel.FlxObject"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Internal, used during tree processing and overlap checks.</haxe_doc>
		</_notifyCallback>
		<_iterator static="1">
			<c path="org.flixel.system.FlxList"/>
			<haxe_doc>* Internal, used during tree processing and overlap checks.</haxe_doc>
		</_iterator>
		<_objectHullX static="1">
			<c path="Float"/>
			<haxe_doc><![CDATA[* Internal, helpers for comparing actual object-to-object overlap - see <code>overlapNode()</code>.]]></haxe_doc>
		</_objectHullX>
		<_objectHullY static="1">
			<c path="Float"/>
			<haxe_doc><![CDATA[* Internal, helpers for comparing actual object-to-object overlap - see <code>overlapNode()</code>.]]></haxe_doc>
		</_objectHullY>
		<_objectHullWidth static="1">
			<c path="Float"/>
			<haxe_doc><![CDATA[* Internal, helpers for comparing actual object-to-object overlap - see <code>overlapNode()</code>.]]></haxe_doc>
		</_objectHullWidth>
		<_objectHullHeight static="1">
			<c path="Float"/>
			<haxe_doc><![CDATA[* Internal, helpers for comparing actual object-to-object overlap - see <code>overlapNode()</code>.]]></haxe_doc>
		</_objectHullHeight>
		<_checkObjectHullX static="1">
			<c path="Float"/>
			<haxe_doc><![CDATA[* Internal, helpers for comparing actual object-to-object overlap - see <code>overlapNode()</code>.]]></haxe_doc>
		</_checkObjectHullX>
		<_checkObjectHullY static="1">
			<c path="Float"/>
			<haxe_doc><![CDATA[* Internal, helpers for comparing actual object-to-object overlap - see <code>overlapNode()</code>.]]></haxe_doc>
		</_checkObjectHullY>
		<_checkObjectHullWidth static="1">
			<c path="Float"/>
			<haxe_doc><![CDATA[* Internal, helpers for comparing actual object-to-object overlap - see <code>overlapNode()</code>.]]></haxe_doc>
		</_checkObjectHullWidth>
		<_checkObjectHullHeight static="1">
			<c path="Float"/>
			<haxe_doc><![CDATA[* Internal, helpers for comparing actual object-to-object overlap - see <code>overlapNode()</code>.]]></haxe_doc>
		</_checkObjectHullHeight>
		<_NUM_CACHED_QUAD_TREES public="1" line="191" static="1">
			<c path="Int"/>
			<haxe_doc>* Pooling mechanism, turn FlxQuadTree into a linked list, when FlxQuadTrees are destroyed, they get added to the list, and when they get recycled they get removed.</haxe_doc>
		</_NUM_CACHED_QUAD_TREES>
		<_cachedTreesHead static="1"><c path="org.flixel.system.FlxQuadTree"/></_cachedTreesHead>
		<recycle public="1" set="method" line="212" static="1">
			<f a="X:Y:Width:Height:?Parent">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="org.flixel.system.FlxQuadTree"/>
				<c path="org.flixel.system.FlxQuadTree"/>
			</f>
			<haxe_doc>* Recycle a cached Quad Tree node, or creates a new one if needed.
	 * @param	X			The X-coordinate of the point in space.
	 * @param	Y			The Y-coordinate of the point in space.
	 * @param	Width		Desired width of this node.
	 * @param	Height		Desired height of this node.
	 * @param	Parent		The parent branch or node.  Pass null to create a root.</haxe_doc>
		</recycle>
		<clearCache public="1" set="method" line="229" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clear cached Quad Tree nodes. You might want to do this when loading new levels (probably not though, no need to clear cache unless you run into memory problems).</haxe_doc>
		</clearCache>
		<overlapNode set="method" line="631">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* An internal function for comparing an object against the contents of a node.
	 * @return	Whether or not any overlaps were found.</haxe_doc>
		</overlapNode>
		<execute public="1" set="method" line="577">
			<f a=""><e path="Bool"/></f>
			<haxe_doc><![CDATA[* <code>FlxQuadTree</code>'s other main function.  Call this after adding objects
	 * using <code>FlxQuadTree.load()</code> to compare the objects that you loaded.
	 * @return	Whether or not any overlaps were found.]]></haxe_doc>
		</execute>
		<addToList set="method" line="527">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Internal function for recursively adding objects to leaf lists.</haxe_doc>
		</addToList>
		<addObject set="method" line="436">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Internal function for recursively navigating and creating the tree
	 * while adding objects to the appropriate nodes.</haxe_doc>
		</addObject>
		<add public="1" set="method" line="384">
			<f a="ObjectOrGroup:list">
				<c path="org.flixel.FlxBasic"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Call this function to add an object to the root of the tree.
	 * This function will recursively add all group members, but
	 * not the groups themselves.
	 * @param	ObjectOrGroup	FlxObjects are just added, FlxGroups are recursed and their applicable members added accordingly.
	 * @param	List			A <code>int</code> flag indicating the list to which you want to add the objects.  Options are <code>A_LIST</code> and <code>B_LIST</code>.]]></haxe_doc>
		</add>
		<load public="1" set="method" line="361">
			<f a="ObjectOrGroup1:?ObjectOrGroup2:?NotifyCallback:?ProcessCallback">
				<c path="org.flixel.FlxBasic"/>
				<c path="org.flixel.FlxBasic"/>
				<f a=":">
					<c path="org.flixel.FlxObject"/>
					<c path="org.flixel.FlxObject"/>
					<e path="Void"/>
				</f>
				<f a=":">
					<c path="org.flixel.FlxObject"/>
					<c path="org.flixel.FlxObject"/>
					<e path="Bool"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Load objects and/or groups into the quad tree, and register notify and processing callbacks.
	 * @param ObjectOrGroup1	Any object that is or extends FlxObject or FlxGroup.
	 * @param ObjectOrGroup2	Any object that is or extends FlxObject or FlxGroup.  If null, the first parameter will be checked against itself.
	 * @param NotifyCallback	A function with the form <code>myFunction(Object1:FlxObject,Object2:FlxObject):void</code> that is called whenever two objects are found to overlap in world space, and either no ProcessCallback is specified, or the ProcessCallback returns true. 
	 * @param ProcessCallback	A function with the form <code>myFunction(Object1:FlxObject,Object2:FlxObject):Boolean</code> that is called whenever two objects are found to overlap in world space.  The NotifyCallback is only called if this function returns true.  See FlxObject.separate().]]></haxe_doc>
		</load>
		<destroy public="1" set="method" line="310">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<reset public="1" set="method" line="241"><f a="X:Y:Width:Height:?Parent">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="org.flixel.system.FlxQuadTree"/>
	<e path="Void"/>
</f></reset>
		<next><c path="org.flixel.system.FlxQuadTree"/></next>
		<_midpointY>
			<c path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_midpointY>
		<_midpointX>
			<c path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_midpointX>
		<_halfHeight>
			<c path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_halfHeight>
		<_halfWidth>
			<c path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_halfWidth>
		<_bottomEdge>
			<c path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_bottomEdge>
		<_topEdge>
			<c path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_topEdge>
		<_rightEdge>
			<c path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_rightEdge>
		<_leftEdge>
			<c path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_leftEdge>
		<_southWestTree>
			<c path="org.flixel.system.FlxQuadTree"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_southWestTree>
		<_southEastTree>
			<c path="org.flixel.system.FlxQuadTree"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_southEastTree>
		<_northEastTree>
			<c path="org.flixel.system.FlxQuadTree"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_northEastTree>
		<_northWestTree>
			<c path="org.flixel.system.FlxQuadTree"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_northWestTree>
		<_tailB>
			<c path="org.flixel.system.FlxList"/>
			<haxe_doc>* Refers to the internal A and B linked lists,
	 * which are used to store objects in the leaves.</haxe_doc>
		</_tailB>
		<_headB>
			<c path="org.flixel.system.FlxList"/>
			<haxe_doc>* Refers to the internal A and B linked lists,
	 * which are used to store objects in the leaves.</haxe_doc>
		</_headB>
		<_tailA>
			<c path="org.flixel.system.FlxList"/>
			<haxe_doc>* Refers to the internal A and B linked lists,
	 * which are used to store objects in the leaves.</haxe_doc>
		</_tailA>
		<_headA>
			<c path="org.flixel.system.FlxList"/>
			<haxe_doc>* Refers to the internal A and B linked lists,
	 * which are used to store objects in the leaves.</haxe_doc>
		</_headA>
		<_canSubdivide>
			<e path="Bool"/>
			<haxe_doc>* Whether this branch of the tree can be subdivided or not.</haxe_doc>
		</_canSubdivide>
		<exists public="1"><e path="Bool"/></exists>
		<new set="method" line="198">
			<f a="X:Y:Width:Height:?Parent">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="org.flixel.system.FlxQuadTree"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Private, use recycle instead.</haxe_doc>
		</new>
		<haxe_doc>* A fairly generic quad tree structure for rapid overlap checks.
 * FlxQuadTree is also configured for single or dual list operation.
 * You can add items either to its A list or its B list.
 * When you do an overlap check, you can compare the A list to itself,
 * or the A list against the B list.  Handy for different things!</haxe_doc>
	</class>
	<class path="org.flixel.system.FlxReplay" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/system/FlxReplay.hx">
		<rewind public="1" set="method" line="209">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Reset the replay back to the first frame.</haxe_doc>
		</rewind>
		<playNextFrame public="1" set="method" line="181">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Get the current frame record data and load it into the input managers.</haxe_doc>
		</playNextFrame>
		<recordFrame public="1" set="method" line="160">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Get the current input data from the input managers and store it in a new frame record.</haxe_doc>
		</recordFrame>
		<save public="1" set="method" line="142">
			<f a=""><c path="String"/></f>
			<haxe_doc><![CDATA[* Save the current recording data off to a <code>String</code> object.
	 * Basically goes through and calls <code>FrameRecord.save()</code> on each frame in the replay.
	 * return	The gameplay recording in simple ASCII format.]]></haxe_doc>
		</save>
		<init set="method" line="129">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Common initialization terms used by both <code>create()</code> and <code>load()</code> to set up the replay object.]]></haxe_doc>
		</init>
		<load public="1" set="method" line="98">
			<f a="FileContents">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Load replay data from a <code>String</code> object.
	 * Strings can come from embedded assets or external
	 * files loaded through the debugger overlay. 
	 * @param	FileContents	A <code>String</code> object containing a gameplay recording.]]></haxe_doc>
		</load>
		<create public="1" set="method" line="84">
			<f a="Seed">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Create a new gameplay recording.  Requires the current random number generator seed.
	 * 
	 * @param	Seed	The current seed from the random number generator.</haxe_doc>
		</create>
		<destroy public="1" set="method" line="65">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_marker>
			<c path="Int"/>
			<haxe_doc><![CDATA[* Internal helper variable for keeping track of where we are in <code>_frames</code> during recording or replay.]]></haxe_doc>
		</_marker>
		<_capacity>
			<c path="Int"/>
			<haxe_doc><![CDATA[* Internal tracker for max number of frames we can fit before growing the <code>_frames</code> again.]]></haxe_doc>
		</_capacity>
		<_frames>
			<c path="Array"><c path="org.flixel.system.replay.FrameRecord"/></c>
			<haxe_doc>* Internal container for all the frames in this replay.</haxe_doc>
		</_frames>
		<finished public="1">
			<e path="Bool"/>
			<haxe_doc>* Whether the replay has finished playing or not.</haxe_doc>
		</finished>
		<frameCount public="1">
			<c path="Int"/>
			<haxe_doc>* The number of frames in this recording.</haxe_doc>
		</frameCount>
		<frame public="1">
			<c path="Int"/>
			<haxe_doc>* The current frame for this recording.</haxe_doc>
		</frame>
		<seed public="1">
			<c path="Float"/>
			<haxe_doc>* The random number generator seed value for this recording.</haxe_doc>
		</seed>
		<new public="1" set="method" line="51">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Instantiate a new replay object.  Doesn't actually do much until you call create() or load().</haxe_doc>
		</new>
		<haxe_doc>* The replay object both records and replays game recordings,
 * as well as handle saving and loading replays to and from files.
 * Gameplay recordings are essentially a list of keyboard and mouse inputs,
 * but since Flixel is fairly deterministic, we can use these to play back
 * recordings of gameplay with a decent amount of fidelity.</haxe_doc>
	</class>
	<class path="org.flixel.system.FlxTile" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/system/FlxTile.hx">
		<extends path="org.flixel.FlxObject"/>
		<destroy public="1" set="method" line="71" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<mapIndex public="1">
			<c path="Int"/>
			<haxe_doc>* The current map index of this tile object at this moment.
	 * You can think of tile objects as moving around the tilemap helping with collisions.
	 * This value is only reliable and useful if used from the callback function.</haxe_doc>
		</mapIndex>
		<index public="1">
			<c path="Int"/>
			<haxe_doc>* The index of this tile type in the core map data.
	 * For example, if your map only has 16 kinds of tiles in it,
	 * this number is usually between 0 and 15.</haxe_doc>
		</index>
		<tilemap public="1">
			<c path="org.flixel.FlxTilemap"/>
			<haxe_doc>* A reference to the tilemap this tile object belongs to.</haxe_doc>
		</tilemap>
		<filter public="1">
			<c path="Class"><d/></c>
			<haxe_doc><![CDATA[* Each tile can store its own filter class for their callback functions.
	 * That is, the callback will only be triggered if an object with a class
	 * type matching the filter touched it.
	 * Defaults to null, set through <code>FlxTilemap.setTileProperties()</code>.]]></haxe_doc>
		</filter>
		<callbackFunction public="1">
			<f a=":">
				<c path="org.flixel.FlxObject"/>
				<c path="org.flixel.FlxObject"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* This function is called whenever an object hits a tile of this type.
	 * This function should take the form <code>myFunction(Tile:FlxTile,Object:FlxObject):void</code>.
	 * Defaults to null, set through <code>FlxTilemap.setTileProperties()</code>.]]></haxe_doc>
		</callbackFunction>
		<new public="1" set="method" line="52">
			<f a="Tilemap:Index:Width:Height:Visible:AllowCollisions">
				<c path="org.flixel.FlxTilemap"/>
				<c path="Int"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Bool"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Instantiate this new tile object.  This is usually called from <code>FlxTilemap.loadMap()</code>.
	 * @param Tilemap			A reference to the tilemap object creating the tile.
	 * @param Index				The actual core map data index for this tile type.
	 * @param Width				The width of the tile.
	 * @param Height			The height of the tile.
	 * @param Visible			Whether the tile is visible or not.
	 * @param AllowCollisions	The collision flags for the object.  By default this value is ANY or NONE depending on the parameters sent to loadMap().]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A simple helper object for <code>FlxTilemap</code> that helps expand collision opportunities and control.
 * You can use <code>FlxTilemap.setTileProperties()</code> to alter the collision properties and
 * callback functions and filters for this object to do things like one-way tiles or whatever.]]></haxe_doc>
	</class>
	<class path="org.flixel.system.FlxTilemapBuffer" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/system/FlxTilemapBuffer.hx">
		<draw public="1" set="method" line="133">
			<f a="Camera:FlashPoint">
				<c path="org.flixel.FlxCamera"/>
				<t path="nme.geom.Point"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Just stamps this buffer onto the specified camera at the specified location.
	 * @param	Camera		Which camera to draw the buffer onto.
	 * @param	FlashPoint	Where to draw the buffer at in camera coordinates.</haxe_doc>
		</draw>
		<getPixels public="1" set="method" line="123">
			<f a=""><t path="nme.display.BitmapData"/></f>
			<haxe_doc><![CDATA[* Read-only, nab the actual buffer <code>BitmapData</code> object.
	 * @return	The buffer bitmap data.]]></haxe_doc>
		</getPixels>
		<pixels public="1" get="getPixels" set="null"><t path="nme.display.BitmapData"/></pixels>
		<fill public="1" set="method" line="109">
			<f a="?Color">
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Fill the buffer with the specified color.
	 * Default value is transparent.
	 * @param	Color	What color to fill with, in 0xAARRGGBB hex format.</haxe_doc>
		</fill>
		<destroy public="1" set="method" line="94">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_flashRect><t path="nme.geom.Rectangle"/></_flashRect>
		<_pixels><t path="nme.display.BitmapData"/></_pixels>
		<columns public="1">
			<c path="Int"/>
			<haxe_doc>* How many columns of tiles fit in this buffer.</haxe_doc>
		</columns>
		<rows public="1">
			<c path="Int"/>
			<haxe_doc>* How many rows of tiles fit in this buffer.</haxe_doc>
		</rows>
		<dirty public="1">
			<e path="Bool"/>
			<haxe_doc>* Whether the buffer needs to be redrawn.</haxe_doc>
		</dirty>
		<height public="1">
			<c path="Float"/>
			<haxe_doc>* The height of the buffer (usually just a few tiles taller than the camera).</haxe_doc>
		</height>
		<width public="1">
			<c path="Float"/>
			<haxe_doc>* The width of the buffer (usually just a few tiles wider than the camera).</haxe_doc>
		</width>
		<y public="1">
			<c path="Float"/>
			<haxe_doc>* The current Y position of the buffer.</haxe_doc>
		</y>
		<x public="1">
			<c path="Float"/>
			<haxe_doc>* The current X position of the buffer.</haxe_doc>
		</x>
		<new public="1" set="method" line="59">
			<f a="TileWidth:TileHeight:WidthInTiles:HeightInTiles:?Camera">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="org.flixel.FlxCamera"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Instantiates a new camera-specific buffer for storing the visual tilemap data.
	 * @param TileWidth		The width of the tiles in this tilemap.
	 * @param TileHeight	The height of the tiles in this tilemap.
	 * @param WidthInTiles	How many tiles wide the tilemap is.
	 * @param HeightInTiles	How many tiles tall the tilemap is.
	 * @param Camera		Which camera this buffer relates to.</haxe_doc>
		</new>
		<haxe_doc>* A helper object to keep tilemap drawing performance decent across the new multi-camera system.
 * Pretty much don't even have to think about this class unless you are doing some crazy hacking.</haxe_doc>
	</class>
	<class path="org.flixel.system.FlxWindow" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/system/FlxWindow.hx">
		<extends path="flash.display.Sprite"/>
		<updateGUI set="method" line="350">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Figure out if the header or handle are highlighted.</haxe_doc>
		</updateGUI>
		<updateSize set="method" line="329">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Update the Flash shapes to match the new size, and reposition the header, shadow, and handle accordingly.</haxe_doc>
		</updateSize>
		<bound set="method" line="317">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Keep the window within the pre-specified bounding rectangle.</haxe_doc>
		</bound>
		<onMouseUp set="method" line="306">
			<f a="?E">
				<t path="nme.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* User let go of header bar or handler (or nothing), so turn off drag and resize behaviors.
	 * @param E		Flash mouse event.</haxe_doc>
		</onMouseUp>
		<onMouseDown set="method" line="286">
			<f a="?E">
				<t path="nme.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Figure out if window is being repositioned (clicked on header) or resized (clicked on handle).
	 * @param E		Flash mouse event.</haxe_doc>
		</onMouseDown>
		<onMouseMove set="method" line="254">
			<f a="?E">
				<t path="nme.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Mouse movement handler.  Figures out if mouse is over handle or header bar or what.
	 * @param E		Flash mouse event.</haxe_doc>
		</onMouseMove>
		<init set="method" line="233">
			<f a="?E">
				<t path="nme.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Used to set up basic mouse listeners.
	 * @param E		Flash event.</haxe_doc>
		</init>
		<reposition public="1" set="method" line="220">
			<f a="X:Y">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Change the position of the window.  Subject to pre-specified bounding rectangles.
	 * @param X		Desired X position of top left corner of the window.
	 * @param Y		Desired Y position of top left corner of the window.</haxe_doc>
		</reposition>
		<resize public="1" set="method" line="208">
			<f a="Width:Height">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Resize the window.  Subject to pre-specified minimums, maximums, and bounding rectangles.
	 * @param Width		How wide to make the window.
	 * @param Height	How tall to make the window.</haxe_doc>
		</resize>
		<destroy public="1" set="method" line="184">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_resizable>
			<e path="Bool"/>
			<haxe_doc>* Helper for interaction.</haxe_doc>
		</_resizable>
		<_resizing>
			<e path="Bool"/>
			<haxe_doc>* Helper for interaction.</haxe_doc>
		</_resizing>
		<_dragging>
			<e path="Bool"/>
			<haxe_doc>* Helper for interaction.</haxe_doc>
		</_dragging>
		<_drag>
			<t path="nme.geom.Point"/>
			<haxe_doc>* Helper for interaction.</haxe_doc>
		</_drag>
		<_overHandle>
			<e path="Bool"/>
			<haxe_doc>* Helper for interaction.</haxe_doc>
		</_overHandle>
		<_overHeader>
			<e path="Bool"/>
			<haxe_doc>* Helper for interaction.</haxe_doc>
		</_overHeader>
		<_handle>
			<t path="nme.display.Bitmap"/>
			<haxe_doc>* Window display element.</haxe_doc>
		</_handle>
		<_title>
			<t path="nme.text.TextField"/>
			<haxe_doc>* Window display element.</haxe_doc>
		</_title>
		<_shadow>
			<t path="nme.display.Bitmap"/>
			<haxe_doc>* Window display element.</haxe_doc>
		</_shadow>
		<_header>
			<t path="nme.display.Bitmap"/>
			<haxe_doc>* Window display element.</haxe_doc>
		</_header>
		<_background>
			<t path="nme.display.Bitmap"/>
			<haxe_doc>* Window display element.</haxe_doc>
		</_background>
		<_bounds>
			<t path="nme.geom.Rectangle"/>
			<haxe_doc>* Controls where the window is allowed to be positioned.</haxe_doc>
		</_bounds>
		<_height>
			<c path="Int"/>
			<haxe_doc>* Height of the window.  Using Sprite.height is super unreliable for some reason!</haxe_doc>
		</_height>
		<_width>
			<c path="Int"/>
			<haxe_doc>* Width of the window.  Using Sprite.width is super unreliable for some reason!</haxe_doc>
		</_width>
		<maxSize public="1">
			<t path="nme.geom.Point"/>
			<haxe_doc>* Maximum allowed X and Y dimensions for this window.</haxe_doc>
		</maxSize>
		<minSize public="1">
			<t path="nme.geom.Point"/>
			<haxe_doc>* Minimum allowed X and Y dimensions for this window.</haxe_doc>
		</minSize>
		<new public="1" set="method" line="102">
			<f a="Title:Width:Height:?Resizable:?Bounds:?BGColor:?TopColor">
				<c path="String"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Bool"/>
				<t path="nme.geom.Rectangle"/>
				<t path="UInt"/>
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new window object.  This Flash-based class is mainly (only?) used by <code>FlxDebugger</code>.
	 * @param Title			The name of the window, displayed in the header bar.
	 * @param Width			The initial width of the window.
	 * @param Height		The initial height of the window.
	 * @param Resizable		Whether you can change the size of the window with a drag handle.
	 * @param Bounds		A rectangle indicating the valid screen area for the window.
	 * @param BGColor		What color the window background should be, default is gray and transparent.
	 * @param TopColor		What color the window header bar should be, default is black and transparent.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A generic, Flash-based window class, created for use in <code>FlxDebugger</code>.]]></haxe_doc>
	</class>
	<class path="org.flixel.system.debug.Log" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/system/debug/Log.hx">
		<extends path="org.flixel.system.FlxWindow"/>
		<MAX_LOG_LINES line="15" static="1"><c path="Int"/></MAX_LOG_LINES>
		<updateSize set="method" line="117" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Adjusts the width and height of the text field accordingly.</haxe_doc>
		</updateSize>
		<add public="1" set="method" line="84">
			<f a="Text">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Adds a new line to the log window.
	 * @param Text		The line you want to add to the log window.</haxe_doc>
		</add>
		<destroy public="1" set="method" line="72" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_lines><c path="Array"><c path="String"/></c></_lines>
		<_text><t path="nme.text.TextField"/></_text>
		<new public="1" set="method" line="31">
			<f a="Title:Width:Height:?Resizable:?Bounds:?BGColor:?TopColor">
				<c path="String"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Bool"/>
				<t path="nme.geom.Rectangle"/>
				<t path="UInt"/>
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new window object.  This Flash-based class is mainly (only?) used by <code>FlxDebugger</code>.
	 * @param Title			The name of the window, displayed in the header bar.
	 * @param Width			The initial width of the window.
	 * @param Height		The initial height of the window.
	 * @param Resizable		Whether you can change the size of the window with a drag handle.
	 * @param Bounds		A rectangle indicating the valid screen area for the window.
	 * @param BGColor		What color the window background should be, default is gray and transparent.
	 * @param TopColor		What color the window header bar should be, default is black and transparent.]]></haxe_doc>
		</new>
		<haxe_doc>* A simple trace output window for use in the debugger overlay.</haxe_doc>
	</class>
	<class path="org.flixel.system.debug.Perf" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/system/debug/Perf.hx">
		<extends path="org.flixel.system.FlxWindow"/>
		<visibleObjects public="1" set="method" line="267">
			<f a="Count">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Keep track of how many objects were updated.
	 * @param Count	How many objects were updated.</haxe_doc>
		</visibleObjects>
		<activeObjects public="1" set="method" line="258">
			<f a="Count">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Keep track of how many objects were updated.
	 * @param Count	How many objects were updated.</haxe_doc>
		</activeObjects>
		<flash public="1" set="method" line="249">
			<f a="Time">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Keep track of how long the Flash player and browser take.
	 * @param Time	How long Flash/browser took.</haxe_doc>
		</flash>
		<flixelDraw public="1" set="method" line="240">
			<f a="Time">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Keep track of how long renders take.
	 * @param	Time	How long this render took.</haxe_doc>
		</flixelDraw>
		<flixelUpdate public="1" set="method" line="231">
			<f a="Time">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Keep track of how long updates take.
	 * @param Time	How long this update took.</haxe_doc>
		</flixelUpdate>
		<update public="1" set="method" line="139">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Called each frame, but really only updates once every second or so, to save on performance.
	 * Takes all the data in the accumulators and parses it into useful performance data.</haxe_doc>
		</update>
		<destroy public="1" set="method" line="118" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_visibleObject><c path="Array"><c path="Int"/></c></_visibleObject>
		<_flash><c path="Array"><c path="Float"/></c></_flash>
		<_activeObject><c path="Array"><c path="Int"/></c></_activeObject>
		<_flashMarker><c path="Int"/></_flashMarker>
		<_objectMarker><c path="Int"/></_objectMarker>
		<_visibleObjectMarker><c path="Int"/></_visibleObjectMarker>
		<_flixelDrawMarker><c path="Int"/></_flixelDrawMarker>
		<_flixelDraw><c path="Array"><c path="Int"/></c></_flixelDraw>
		<_flixelUpdateMarker><c path="Int"/></_flixelUpdateMarker>
		<_flixelUpdate><c path="Array"><c path="Int"/></c></_flixelUpdate>
		<_updateTimer><c path="Int"/></_updateTimer>
		<_lastTime><c path="Int"/></_lastTime>
		<_text><t path="nme.text.TextField"/></_text>
		<new public="1" set="method" line="53">
			<f a="Title:Width:Height:?Resizable:?Bounds:?BGColor:?TopColor">
				<c path="String"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Bool"/>
				<t path="nme.geom.Rectangle"/>
				<t path="UInt"/>
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates flashPlayerFramerate new window object.  This Flash-based class is mainly (only?) used by <code>FlxDebugger</code>.
	 * @param Title			The name of the window, displayed in the header bar.
	 * @param Width			The initial width of the window.
	 * @param Height		The initial height of the window.
	 * @param Resizable		Whether you can change the size of the window with flashPlayerFramerate drag handle.
	 * @param Bounds		A rectangle indicating the valid screen area for the window.
	 * @param BGColor		What color the window background should be, default is gray and transparent.
	 * @param TopColor		What color the window header bar should be, default is black and transparent.]]></haxe_doc>
		</new>
		<haxe_doc>* A simple performance monitor widget, for use in the debugger overlay.</haxe_doc>
	</class>
	<class path="org.flixel.system.debug.VCR" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/system/debug/VCR.hx">
		<extends path="flash.display.Sprite"/>
		<FILE_TYPES get="inline" set="null" line="33" static="1"><c path="Array"><c path="flash.net.FileFilter"/></c></FILE_TYPES>
		<DEFAULT_FILE_NAME get="inline" set="null" line="35" static="1"><c path="String"/></DEFAULT_FILE_NAME>
		<updateGUI set="method" line="634">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Figures out what buttons to highlight based on the _overWhatever and _pressingWhatever variables.</haxe_doc>
		</updateGUI>
		<unpress set="method" line="622">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Sets all the pressed state variables for the buttons to false.</haxe_doc>
		</unpress>
		<checkOver set="method" line="586">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* This function checks to see what button the mouse is currently over.
	 * Has some special behavior based on whether a recording is happening or not.
	 * @return	Whether the mouse was over any buttons or not.</haxe_doc>
		</checkOver>
		<onMouseUp set="method" line="533">
			<f a="?E">
				<t path="nme.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* If the mouse is released, check to see if it was released over a button that was pressed.
	 * If it was, take the appropriate action based on button state and visibility.
	 * @param	E	Flash mouse event.</haxe_doc>
		</onMouseUp>
		<onMouseDown set="method" line="503">
			<f a="?E">
				<t path="nme.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* If the mouse is pressed down, check to see if the user started pressing down a specific button.
	 * @param	E	Flash mouse event.</haxe_doc>
		</onMouseDown>
		<onMouseMove set="method" line="490">
			<f a="?E">
				<t path="nme.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* If the mouse moves, check to see if any buttons should be highlighted.
	 * @param	E	Flash mouse event.</haxe_doc>
		</onMouseMove>
		<init set="method" line="469">
			<f a="?E">
				<t path="nme.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Just sets up basic mouse listeners, a la FlxWindow.
	 * @param	E	Flash event.</haxe_doc>
		</init>
		<onStep public="1" set="method" line="454">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Called when the user presses the fast-forward-looking button.
	 * Requests a 1-frame step forward in the game loop.</haxe_doc>
		</onStep>
		<onPlay public="1" set="method" line="443">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Called when the user presses the Play button.
	 * This is different from user-defined unpause behavior, or focus gained behavior.</haxe_doc>
		</onPlay>
		<onPause public="1" set="method" line="432">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Called when the user presses the Pause button.
	 * This is different from user-defined pause behavior, or focus lost behavior.
	 * Does NOT pause music playback!!</haxe_doc>
		</onPause>
		<onRestart public="1" set="method" line="413">
			<f a="?StandardMode">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when the user presses the Rewind-looking button.
	 * If Alt is pressed, the entire game is reset.
	 * If Alt is NOT pressed, only the current state is reset.
	 * The GUI is updated accordingly.
	 * @param	StandardMode	Whether to reset the current game (== true), or just the current state.  Just resetting the current state can be very handy for debugging.</haxe_doc>
		</onRestart>
		<onStop public="1" set="method" line="401">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Called when the user presses the stop button.
	 * Stops the current replay.</haxe_doc>
		</onStop>
		<onSaveError set="method" line="386">
			<f a="?E">
				<t path="nme.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called if there is an error while saving the gameplay recording.
	 * @param	E	Flash Event.</haxe_doc>
		</onSaveError>
		<onSaveCancel set="method" line="372">
			<f a="?E">
				<t path="nme.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when the save file dialog is cancelled.
	 * @param	E	Flash Event.</haxe_doc>
		</onSaveCancel>
		<onSaveComplete set="method" line="357">
			<f a="?E">
				<t path="nme.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when the file is saved successfully.
	 * @param	E	Flash Event.</haxe_doc>
		</onSaveComplete>
		<stopRecording public="1" set="method" line="338">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Called when the user presses the red record button.
	 * Stops the current recording, opens the save file dialog, and registers event handlers.</haxe_doc>
		</stopRecording>
		<onRecord public="1" set="method" line="325">
			<f a="?StandardMode">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Called when the user presses the white record button.
	 * If Alt is pressed, the current state is reset, and a new recording is requested.
	 * If Alt is NOT pressed, the game is reset, and a new recording is requested.
	 * @param	StandardMode	Whether to reset the whole game, or just this <code>FlxState</code>.  StandardMode == false is useful for recording demos or attract modes.]]></haxe_doc>
		</onRecord>
		<onOpenError set="method" line="309">
			<f a="?E">
				<t path="nme.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called if there is a file open error.
	 * @param	E	Flash Event.</haxe_doc>
		</onOpenError>
		<onOpenCancel set="method" line="296">
			<f a="?E">
				<t path="nme.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called if the open file dialog is canceled.
	 * @param	E	Flash Event.</haxe_doc>
		</onOpenCancel>
		<onOpenComplete set="method" line="268">
			<f a="?E">
				<t path="nme.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when a file is opened successfully.
	 * If there's stuff inside, then the contents are loaded into a new replay.
	 * @param	E	Flash Event.</haxe_doc>
		</onOpenComplete>
		<onOpenSelect set="method" line="251">
			<f a="?E">
				<t path="nme.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when a file is picked from the file dialog.
	 * Attempts to load the file and registers file loading event handlers.
	 * @param	E	Flash event.</haxe_doc>
		</onOpenSelect>
		<onOpen public="1" set="method" line="236">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Called when the "open file" button is pressed.
	 * Opens the file dialog and registers event handlers for the file dialog.</haxe_doc>
		</onOpen>
		<updateRuntime public="1" set="method" line="220">
			<f a="Time">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Just updates the VCR GUI so the runtime displays roughly the right thing.</haxe_doc>
		</updateRuntime>
		<playing public="1" set="method" line="210">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Usually called by FlxGame when a requested replay has begun.
	 * Just updates the VCR GUI so the buttons are in the right state.</haxe_doc>
		</playing>
		<stopped public="1" set="method" line="199">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Usually called by FlxGame when a replay has been stopped.
	 * Just updates the VCR GUI so the buttons are in the right state.</haxe_doc>
		</stopped>
		<recording public="1" set="method" line="188">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Usually called by FlxGame when a requested recording has begun.
	 * Just updates the VCR GUI so the buttons are in the right state.</haxe_doc>
		</recording>
		<destroy public="1" set="method" line="154">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_runtime><c path="Int"/></_runtime>
		<_runtimeDisplay><t path="nme.text.TextField"/></_runtimeDisplay>
		<_file><c path="flash.net.FileReference"/></_file>
		<_pressingStep><e path="Bool"/></_pressingStep>
		<_pressingPause><e path="Bool"/></_pressingPause>
		<_pressingRestart><e path="Bool"/></_pressingRestart>
		<_pressingRecord><e path="Bool"/></_pressingRecord>
		<_pressingOpen><e path="Bool"/></_pressingOpen>
		<_overStep><e path="Bool"/></_overStep>
		<_overPause><e path="Bool"/></_overPause>
		<_overRestart><e path="Bool"/></_overRestart>
		<_overRecord><e path="Bool"/></_overRecord>
		<_overOpen><e path="Bool"/></_overOpen>
		<_step><t path="nme.display.Bitmap"/></_step>
		<_play><t path="nme.display.Bitmap"/></_play>
		<_pause><t path="nme.display.Bitmap"/></_pause>
		<_restart><t path="nme.display.Bitmap"/></_restart>
		<_flixel><t path="nme.display.Bitmap"/></_flixel>
		<_stop><t path="nme.display.Bitmap"/></_stop>
		<_recordOn><t path="nme.display.Bitmap"/></_recordOn>
		<_recordOff><t path="nme.display.Bitmap"/></_recordOff>
		<_open><t path="nme.display.Bitmap"/></_open>
		<stepRequested public="1">
			<e path="Bool"/>
			<haxe_doc>* Whether a "1 frame step forward" was requested.</haxe_doc>
		</stepRequested>
		<paused public="1">
			<e path="Bool"/>
			<haxe_doc>* Whether the debugger has been paused.</haxe_doc>
		</paused>
		<new public="1" set="method" line="80">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Creates the "VCR" control panel for debugger pausing, stepping, and recording.</haxe_doc>
		</new>
		<haxe_doc>* This class contains the record, stop, play, and step 1 frame buttons seen on the top edge of the debugger overlay.</haxe_doc>
	</class>
	<class path="org.flixel.system.debug.Vis" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/system/debug/Vis.hx">
		<extends path="flash.display.Sprite"/>
		<updateGUI set="method" line="163">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Figures out what buttons to highlight based on the _overWhatever and _pressingWhatever variables.</haxe_doc>
		</updateGUI>
		<unpress set="method" line="155">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Sets all the pressed state variables for the buttons to false.</haxe_doc>
		</unpress>
		<checkOver set="method" line="138">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* This function checks to see what button the mouse is currently over.
	 * Has some special behavior based on whether a recording is happening or not.
	 * @return	Whether the mouse was over any buttons or not.</haxe_doc>
		</checkOver>
		<onMouseUp set="method" line="120">
			<f a="?E">
				<t path="nme.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* If the mouse is released, check to see if it was released over a button that was pressed.
	 * If it was, take the appropriate action based on button state and visibility.
	 * @param	E	Flash mouse event.</haxe_doc>
		</onMouseUp>
		<onMouseDown set="method" line="106">
			<f a="?E">
				<t path="nme.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* If the mouse is pressed down, check to see if the user started pressing down a specific button.
	 * @param	E	Flash mouse event.</haxe_doc>
		</onMouseDown>
		<onMouseMove set="method" line="93">
			<f a="?E">
				<t path="nme.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* If the mouse moves, check to see if any buttons should be highlighted.
	 * @param	E	Flash mouse event.</haxe_doc>
		</onMouseMove>
		<init set="method" line="72">
			<f a="?E">
				<t path="nme.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Just sets up basic mouse listeners, a la FlxWindow.
	 * @param	E	Flash event.</haxe_doc>
		</init>
		<onBounds public="1" set="method" line="61">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Called when the bounding box toggle is pressed.</haxe_doc>
		</onBounds>
		<destroy public="1" set="method" line="46">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_pressingBounds><e path="Bool"/></_pressingBounds>
		<_overBounds><e path="Bool"/></_overBounds>
		<_bounds><t path="nme.display.Bitmap"/></_bounds>
		<new public="1" set="method" line="27">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Instantiate the visual debugger panel.</haxe_doc>
		</new>
		<haxe_doc>* This control panel has all the visual debugger toggles in it, in the debugger overlay.
 * Currently there is only one toggle that flips on all the visual debug settings.
 * This panel is heavily based on the VCR panel.</haxe_doc>
	</class>
	<class path="org.flixel.system.debug.Watch" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/system/debug/Watch.hx">
		<extends path="org.flixel.system.FlxWindow"/>
		<MAX_LOG_LINES get="inline" set="null" line="18" static="1"><c path="Int"/></MAX_LOG_LINES>
		<LINE_HEIGHT get="inline" set="null" line="19" static="1"><c path="Int"/></LINE_HEIGHT>
		<updateSize set="method" line="227" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Update the Flash shapes to match the new size, and reposition the header, shadow, and handle accordingly.
	 * Also adjusts the width of the entries and stuff, and makes sure there is room for all the entries.</haxe_doc>
		</updateSize>
		<submit public="1" set="method" line="207">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Force any watch entries currently being edited to submit their changes.</haxe_doc>
		</submit>
		<update public="1" set="method" line="190">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Update all the entries in the watch window.</haxe_doc>
		</update>
		<removeAll public="1" set="method" line="170">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Remove everything from the watch window.</haxe_doc>
		</removeAll>
		<remove public="1" set="method" line="138">
			<f a="AnyObject:?VariableName">
				<d/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Remove a variable from the watch window.
	 * @param AnyObject		The <code>Object</code> containing the variable you want to remove, e.g. this or Player.velocity.
	 * @param VariableName	The <code>String</code> name of the variable you want to remove, e.g. "width" or "x".  If left null, this will remove all variables of that object.]]></haxe_doc>
		</remove>
		<add public="1" set="method" line="111">
			<f a="AnyObject:VariableName:?DisplayName">
				<d/>
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Add a new variable to the watch window.
	 * Has some simple code in place to prevent
	 * accidentally watching the same variable twice.
	 * @param AnyObject		The <code>Object</code> containing the variable you want to track, e.g. this or Player.velocity.
	 * @param VariableName	The <code>String</code> name of the variable you want to track, e.g. "width" or "x".
	 * @param DisplayName	Optional <code>String</code> that can be displayed in the watch window instead of the basic class-name information.]]></haxe_doc>
		</add>
		<destroy public="1" set="method" line="87" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_watching><c path="Array"><c path="org.flixel.system.debug.WatchEntry"/></c></_watching>
		<_values><t path="nme.display.Sprite"/></_values>
		<_names><t path="nme.display.Sprite"/></_names>
		<editing public="1">
			<e path="Bool"/>
			<haxe_doc>* Whether a watch entry is currently being edited or not.</haxe_doc>
		</editing>
		<new public="1" set="method" line="41">
			<f a="Title:Width:Height:?Resizable:?Bounds:?BGColor:?TopColor">
				<c path="String"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Bool"/>
				<t path="nme.geom.Rectangle"/>
				<t path="UInt"/>
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new window object.  This Flash-based class is mainly (only?) used by <code>FlxDebugger</code>.
	 * @param Title			The name of the window, displayed in the header bar.
	 * @param Width			The initial width of the window.
	 * @param Height		The initial height of the window.
	 * @param Resizable		Whether you can change the size of the window with a drag handle.
	 * @param Bounds		A rectangle indicating the valid screen area for the window.
	 * @param BGColor		What color the window background should be, default is gray and transparent.
	 * @param TopColor		What color the window header bar should be, default is black and transparent.]]></haxe_doc>
		</new>
		<haxe_doc>* A Visual Studio-style "watch" window, for use in the debugger overlay.
 * Track the values of any public variable in real-time, and/or edit their values on the fly.</haxe_doc>
	</class>
	<class path="org.flixel.system.debug.WatchEntry" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/system/debug/WatchEntry.hx">
		<doneEditing set="method" line="215">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Helper function, switches the text field back to display mode.</haxe_doc>
		</doneEditing>
		<submit public="1" set="method" line="205">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Submit the current edits and stop editing.</haxe_doc>
		</submit>
		<cancel public="1" set="method" line="196">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Cancel the current edits and stop editing.</haxe_doc>
		</cancel>
		<onKeyUp public="1" set="method" line="178">
			<f a="FlashEvent">
				<t path="nme.events.KeyboardEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Check to see if Enter, Tab or Escape were just released.
	 * Enter or Tab submit the change, and Escape cancels it.
	 * @param	FlashEvent	Flash keyboard event.</haxe_doc>
		</onKeyUp>
		<onMouseUp public="1" set="method" line="162">
			<f a="FlashEvent">
				<t path="nme.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* A watch entry was clicked, so flip into edit mode for that entry.
	 * @param	FlashEvent	Flash mouse event.</haxe_doc>
		</onMouseUp>
		<updateValue public="1" set="method" line="147">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Update the variable value on display with the current in-game value.</haxe_doc>
		</updateValue>
		<updateWidth public="1" set="method" line="117">
			<f a="NameWidth:ValueWidth">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Adjust the width of the Flash <code>TextField</code> objects.]]></haxe_doc>
		</updateWidth>
		<setY public="1" set="method" line="108">
			<f a="Y">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Set the watch window Y height of the Flash <code>TextField</code> objects.]]></haxe_doc>
		</setY>
		<destroy public="1" set="method" line="93">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_blackText><t path="nme.text.TextFormat"/></_blackText>
		<_whiteText><t path="nme.text.TextFormat"/></_whiteText>
		<oldValue public="1">
			<d/>
			<haxe_doc>* The value of the field before it was edited.</haxe_doc>
		</oldValue>
		<editing public="1">
			<e path="Bool"/>
			<haxe_doc>* Whether the entry is currently being edited or not.</haxe_doc>
		</editing>
		<valueDisplay public="1">
			<t path="nme.text.TextField"/>
			<haxe_doc><![CDATA[* The Flash <code>TextField</code> object used to display and edit this entry's value.]]></haxe_doc>
		</valueDisplay>
		<nameDisplay public="1">
			<t path="nme.text.TextField"/>
			<haxe_doc><![CDATA[* The Flash <code>TextField</code> object used to display this entry's name.]]></haxe_doc>
		</nameDisplay>
		<custom public="1">
			<c path="String"/>
			<haxe_doc>* A custom display name for this object, if there is any.</haxe_doc>
		</custom>
		<field public="1">
			<c path="String"/>
			<haxe_doc>* The member variable of that object.</haxe_doc>
		</field>
		<object public="1">
			<d/>
			<haxe_doc><![CDATA[* The <code>Object</code> being watched.]]></haxe_doc>
		</object>
		<new public="1" set="method" line="58">
			<f a="Y:NameWidth:ValueWidth:Obj:Field:?Custom">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<d/>
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new watch entry in the watch window.
	 * @param Y				The initial height in the Watch window.
	 * @param NameWidth		The initial width of the name field.
	 * @param ValueWidth	The initial width of the value field.
	 * @param Obj			The <code>Object</code> containing the variable we want to watch.
	 * @param Field			The variable name we want to watch.
	 * @param Custom		A custom display name (optional).]]></haxe_doc>
		</new>
		<haxe_doc>* Helper class for the debugger overlay's Watch window.
 * Handles the display and modification of game variables on the fly.</haxe_doc>
	</class>
	<class path="org.flixel.system.input.Input" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/system/input/Input.hx">
		<destroy public="1" set="method" line="194">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<addKey set="method" line="185">
			<f a="KeyName:KeyCode">
				<c path="String"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* An internal helper function used to build the key array.
	 * @param	KeyName		String name of the key (e.g. "LEFT" or "A")
	 * @param	KeyCode		The numeric Flash code for this key.</haxe_doc>
		</addKey>
		<any public="1" set="method" line="166">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Check to see if any keys are pressed right now.
	 * @return	Whether any keys are currently pressed.</haxe_doc>
		</any>
		<getKeyCode public="1" set="method" line="157">
			<f a="KeyName">
				<c path="String"/>
				<c path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Look up the key code for any given string name of the key or button.
	 * @param	KeyName		The <code>String</code> name of the key.
	 * @return	The key code for that key.]]></haxe_doc>
		</getKeyCode>
		<playback public="1" set="method" line="130">
			<f a="Record">
				<c path="Array"><c path="org.flixel.system.replay.CodeValuePair"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* Part of the keystroke recording system.
	 * Takes data about key presses and sets it into array.
	 * 
	 * @param	Record	Array of data about key states.</haxe_doc>
		</playback>
		<record public="1" set="method" line="104">
			<f a=""><c path="Array"><c path="org.flixel.system.replay.CodeValuePair"/></c></f>
			<haxe_doc>* If any keys are not "released" (0),
	 * this function will return an array indicating
	 * which keys are pressed and what state they are in.
	 * @return	An array of key state data.  Null if there is no data.</haxe_doc>
		</record>
		<justReleased public="1" set="method" line="93">
			<f a="Key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Check to see if this key is just released.
	 * @param	Key		One of the key constants listed above (e.g. "LEFT" or "A").
	 * @return	Whether the key is just released.</haxe_doc>
		</justReleased>
		<justPressed public="1" set="method" line="83">
			<f a="Key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Check to see if this key was just pressed.
	 * @param	Key		One of the key constants listed above (e.g. "LEFT" or "A").
	 * @return	Whether the key was just pressed</haxe_doc>
		</justPressed>
		<pressed public="1" set="method" line="73">
			<f a="Key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Check to see if this key is pressed.
	 * @param	Key		One of the key constants listed above (e.g. "LEFT" or "A").
	 * @return	Whether the key is pressed</haxe_doc>
		</pressed>
		<reset public="1" set="method" line="56">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Resets all the keys.</haxe_doc>
		</reset>
		<update public="1" set="method" line="40">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Updates the key states (for tracking just pressed, just released, etc).</haxe_doc>
		</update>
		<_total>
			<c path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</_total>
		<_map>
			<c path="Array"><c path="org.flixel.system.input.MapObject"/></c>
			<haxe_doc>* @private</haxe_doc>
		</_map>
		<_lookup>
			<c path="Hash"><c path="Int"/></c>
			<haxe_doc>* @private</haxe_doc>
		</_lookup>
		<new public="1" set="method" line="28">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Constructor</haxe_doc>
		</new>
		<haxe_doc>* Basic input class that manages the fast-access Booleans and detailed key-state tracking.
 * Keyboard extends this with actual specific key data.</haxe_doc>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="org.flixel.system.input.Keyboard" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/system/input/Keyboard.hx">
		<extends path="org.flixel.system.input.Input"/>
		<handleKeyUp public="1" set="method" line="211">
			<f a="FlashEvent">
				<t path="nme.events.KeyboardEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Event handler so FlxGame can toggle keys.
	 * @param	FlashEvent	A <code>KeyboardEvent</code> object.]]></haxe_doc>
		</handleKeyUp>
		<handleKeyDown public="1" set="method" line="198">
			<f a="FlashEvent">
				<t path="nme.events.KeyboardEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Event handler so FlxGame can toggle keys.
	 * @param	FlashEvent	A <code>KeyboardEvent</code> object.]]></haxe_doc>
		</handleKeyDown>
		<RIGHT public="1"><e path="Bool"/></RIGHT>
		<LEFT public="1"><e path="Bool"/></LEFT>
		<DOWN public="1"><e path="Bool"/></DOWN>
		<UP public="1"><e path="Bool"/></UP>
		<SPACE public="1"><e path="Bool"/></SPACE>
		<ALT public="1"><e path="Bool"/></ALT>
		<CONTROL public="1"><e path="Bool"/></CONTROL>
		<NUMPADSLASH public="1"><e path="Bool"/></NUMPADSLASH>
		<SLASH public="1"><e path="Bool"/></SLASH>
		<NUMPADPERIOD public="1"><e path="Bool"/></NUMPADPERIOD>
		<PERIOD public="1"><e path="Bool"/></PERIOD>
		<COMMA public="1"><e path="Bool"/></COMMA>
		<M public="1"><e path="Bool"/></M>
		<N public="1"><e path="Bool"/></N>
		<B public="1"><e path="Bool"/></B>
		<V public="1"><e path="Bool"/></V>
		<C public="1"><e path="Bool"/></C>
		<X public="1"><e path="Bool"/></X>
		<Z public="1"><e path="Bool"/></Z>
		<SHIFT public="1"><e path="Bool"/></SHIFT>
		<ENTER public="1"><e path="Bool"/></ENTER>
		<QUOTE public="1"><e path="Bool"/></QUOTE>
		<SEMICOLON public="1"><e path="Bool"/></SEMICOLON>
		<L public="1"><e path="Bool"/></L>
		<K public="1"><e path="Bool"/></K>
		<J public="1"><e path="Bool"/></J>
		<H public="1"><e path="Bool"/></H>
		<G public="1"><e path="Bool"/></G>
		<F public="1"><e path="Bool"/></F>
		<D public="1"><e path="Bool"/></D>
		<S public="1"><e path="Bool"/></S>
		<A public="1"><e path="Bool"/></A>
		<CAPSLOCK public="1"><e path="Bool"/></CAPSLOCK>
		<BACKSLASH public="1"><e path="Bool"/></BACKSLASH>
		<RBRACKET public="1"><e path="Bool"/></RBRACKET>
		<LBRACKET public="1"><e path="Bool"/></LBRACKET>
		<P public="1"><e path="Bool"/></P>
		<O public="1"><e path="Bool"/></O>
		<I public="1"><e path="Bool"/></I>
		<U public="1"><e path="Bool"/></U>
		<Y public="1"><e path="Bool"/></Y>
		<T public="1"><e path="Bool"/></T>
		<R public="1"><e path="Bool"/></R>
		<E public="1"><e path="Bool"/></E>
		<W public="1"><e path="Bool"/></W>
		<Q public="1"><e path="Bool"/></Q>
		<TAB public="1"><e path="Bool"/></TAB>
		<BACKSPACE public="1"><e path="Bool"/></BACKSPACE>
		<DELETE public="1"><e path="Bool"/></DELETE>
		<NUMPADPLUS public="1"><e path="Bool"/></NUMPADPLUS>
		<PLUS public="1"><e path="Bool"/></PLUS>
		<NUMPADMINUS public="1"><e path="Bool"/></NUMPADMINUS>
		<MINUS public="1"><e path="Bool"/></MINUS>
		<INSERT public="1"><e path="Bool"/></INSERT>
		<END public="1"><e path="Bool"/></END>
		<HOME public="1"><e path="Bool"/></HOME>
		<PAGEDOWN public="1"><e path="Bool"/></PAGEDOWN>
		<PAGEUP public="1"><e path="Bool"/></PAGEUP>
		<NUMPADZERO public="1"><e path="Bool"/></NUMPADZERO>
		<NUMPADNINE public="1"><e path="Bool"/></NUMPADNINE>
		<NUMPADEIGHT public="1"><e path="Bool"/></NUMPADEIGHT>
		<NUMPADSEVEN public="1"><e path="Bool"/></NUMPADSEVEN>
		<NUMPADSIX public="1"><e path="Bool"/></NUMPADSIX>
		<NUMPADFIVE public="1"><e path="Bool"/></NUMPADFIVE>
		<NUMPADFOUR public="1"><e path="Bool"/></NUMPADFOUR>
		<NUMPADTHREE public="1"><e path="Bool"/></NUMPADTHREE>
		<NUMPADTWO public="1"><e path="Bool"/></NUMPADTWO>
		<NUMPADONE public="1"><e path="Bool"/></NUMPADONE>
		<ZERO public="1"><e path="Bool"/></ZERO>
		<NINE public="1"><e path="Bool"/></NINE>
		<EIGHT public="1"><e path="Bool"/></EIGHT>
		<SEVEN public="1"><e path="Bool"/></SEVEN>
		<SIX public="1"><e path="Bool"/></SIX>
		<FIVE public="1"><e path="Bool"/></FIVE>
		<FOUR public="1"><e path="Bool"/></FOUR>
		<THREE public="1"><e path="Bool"/></THREE>
		<TWO public="1"><e path="Bool"/></TWO>
		<ONE public="1"><e path="Bool"/></ONE>
		<F12 public="1"><e path="Bool"/></F12>
		<F11 public="1"><e path="Bool"/></F11>
		<F10 public="1"><e path="Bool"/></F10>
		<F9 public="1"><e path="Bool"/></F9>
		<F8 public="1"><e path="Bool"/></F8>
		<F7 public="1"><e path="Bool"/></F7>
		<F6 public="1"><e path="Bool"/></F6>
		<F5 public="1"><e path="Bool"/></F5>
		<F4 public="1"><e path="Bool"/></F4>
		<F3 public="1"><e path="Bool"/></F3>
		<F2 public="1"><e path="Bool"/></F2>
		<F1 public="1"><e path="Bool"/></F1>
		<ESCAPE public="1"><e path="Bool"/></ESCAPE>
		<new public="1" set="method" line="102"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Keeps track of what keys are pressed and how with handy Bools or strings.</haxe_doc>
	</class>
	<class path="org.flixel.system.input.MapObject" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/system/input/MapObject.hx">
		<last public="1"><c path="Int"/></last>
		<current public="1"><c path="Int"/></current>
		<name public="1"><c path="String"/></name>
		<new public="1" set="method" line="14"><f a="name:current:last">
	<c path="String"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Zaphod</haxe_doc>
	</class>
	<class path="org.flixel.system.input.Mouse" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/system/input/Mouse.hx">
		<extends path="org.flixel.FlxPoint"/>
		<playback public="1" set="method" line="367">
			<f a="Record">
				<c path="org.flixel.system.replay.MouseRecord"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Part of the keystroke recording system.
	 * Takes data about key presses and sets it into array.
	 * @param	KeyStates	Array of data about key states.</haxe_doc>
		</playback>
		<record public="1" set="method" line="350">
			<f a=""><c path="org.flixel.system.replay.MouseRecord"/></f>
			<haxe_doc>* If the mouse changed state or is pressed, return that info now
	 * @return	An array of key state data.  Null if there is no data.</haxe_doc>
		</record>
		<handleMouseWheel public="1" set="method" line="341">
			<f a="FlashEvent">
				<t path="nme.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Event handler so FlxGame can update the mouse.
	 * 
	 * @param	FlashEvent	A <code>MouseEvent</code> object.]]></haxe_doc>
		</handleMouseWheel>
		<handleMouseUp public="1" set="method" line="330">
			<f a="FlashEvent">
				<t path="nme.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Event handler so FlxGame can update the mouse.
	 * @param	FlashEvent	A <code>MouseEvent</code> object.]]></haxe_doc>
		</handleMouseUp>
		<handleMouseDown public="1" set="method" line="320">
			<f a="FlashEvent">
				<t path="nme.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Event handler so FlxGame can update the mouse.
	 * @param	FlashEvent	A <code>MouseEvent</code> object.]]></haxe_doc>
		</handleMouseDown>
		<justReleased public="1" set="method" line="314">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Check to see if the mouse was just released.
	 * @return	Whether the mouse was just released.</haxe_doc>
		</justReleased>
		<justPressed public="1" set="method" line="308">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Check to see if the mouse was just pressed.
	 * @return Whether the mouse was just pressed.</haxe_doc>
		</justPressed>
		<pressed public="1" set="method" line="302">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Check to see if the mouse is pressed.
	 * @return	Whether the mouse is pressed.</haxe_doc>
		</pressed>
		<reset public="1" set="method" line="292">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Resets the just pressed/just released flags and sets mouse to not pressed.</haxe_doc>
		</reset>
		<getScreenPosition public="1" set="method" line="274">
			<f a="?Camera:?point">
				<c path="org.flixel.FlxCamera"/>
				<c path="org.flixel.FlxPoint"/>
				<c path="org.flixel.FlxPoint"/>
			</f>
			<haxe_doc>* Fetch the screen position of the mouse on any given camera.
	 * NOTE: Mouse.screenX and Mouse.screenY also store the screen position of the mouse cursor on the main camera.
	 * @param Camera	If unspecified, first/main global camera is used instead.
	 * @param point		An existing point object to store the results (if you don't want a new one created). 
	 * @return The mouse's location in screen space.</haxe_doc>
		</getScreenPosition>
		<getWorldPosition public="1" set="method" line="251">
			<f a="?Camera:?point">
				<c path="org.flixel.FlxCamera"/>
				<c path="org.flixel.FlxPoint"/>
				<c path="org.flixel.FlxPoint"/>
			</f>
			<haxe_doc>* Fetch the world position of the mouse on any given camera.
	 * NOTE: Mouse.x and Mouse.y also store the world position of the mouse cursor on the main camera.
	 * @param Camera	If unspecified, first/main global camera is used instead.
	 * @param point		An existing point object to store the results (if you don't want a new one created). 
	 * @return The mouse's location in world space.</haxe_doc>
		</getWorldPosition>
		<updateCursor set="method" line="226">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Internal function for helping to update the mouse cursor and world coordinates.</haxe_doc>
		</updateCursor>
		<update public="1" set="method" line="206">
			<f a="X:Y">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called by the internal game loop to update the mouse pointer's position in the game world.
	 * Also updates the just pressed/just released flags.
	 * @param	X			The current X position of the mouse in the window.
	 * @param	Y			The current Y position of the mouse in the window.</haxe_doc>
		</update>
		<unload public="1" set="method" line="184">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Unload the current cursor graphic.  If the current cursor is visible,
	 * then the default system cursor is loaded up to replace the old one.</haxe_doc>
		</unload>
		<load public="1" set="method" line="143">
			<f a="?Graphic:?Scale:?XOffset:?YOffset">
				<d/>
				<c path="Float"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Load a new mouse cursor graphic
	 * @param	Graphic		The image you want to use for the cursor.
	 * @param	Scale		Change the size of the cursor.
	 * @param	XOffset		The number of pixels between the mouse's screen position and the graphic's top left corner.
	 * @param	YOffset		The number of pixels between the mouse's screen position and the graphic's top left corner.</haxe_doc>
		</load>
		<getVisible public="1" get="inline" set="null" line="131">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Read only, check visibility of mouse cursor.</haxe_doc>
		</getVisible>
		<hide public="1" get="inline" set="null" line="122">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Hides the mouse cursor</haxe_doc>
		</hide>
		<show public="1" set="method" line="105">
			<f a="?Graphic:?Scale:?XOffset:?YOffset">
				<d/>
				<c path="Float"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Either show an existing cursor or load a new one.
	 * @param	Graphic		The image you want to use for the cursor.
	 * @param	Scale		Change the size of the cursor.  Default = 1, or native size.  2 = 2x as big, 0.5 = half size, etc.
	 * @param	XOffset		The number of pixels between the mouse's screen position and the graphic's top left corner.
	 * @param	YOffset		The number of pixels between the mouse's screen position and the graphic's top left corner.</haxe_doc>
		</show>
		<destroy public="1" set="method" line="90">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_globalScreenPosition><c path="org.flixel.FlxPoint"/></_globalScreenPosition>
		<_point><c path="org.flixel.FlxPoint"/></_point>
		<_lastWheel><c path="Int"/></_lastWheel>
		<_lastY><c path="Int"/></_lastY>
		<_lastX>
			<c path="Int"/>
			<haxe_doc>* Helper variables for recording purposes.</haxe_doc>
		</_lastX>
		<_cursor>
			<t path="nme.display.Bitmap"/>
			<haxe_doc>* This is just a reference to the current cursor image, if there is one.</haxe_doc>
		</_cursor>
		<_updateCursorContainer>
			<e path="Bool"/>
			<haxe_doc>* Don't update cursor unless we have to (this is essentially a "visible" bool, so we avoid checking the visible property in the Sprite which is slow in cpp).</haxe_doc>
		</_updateCursorContainer>
		<_cursorContainer>
			<t path="nme.display.Sprite"/>
			<haxe_doc>* A display container for the mouse cursor.
	 * This container is a child of FlxGame and sits at the right "height".</haxe_doc>
		</_cursorContainer>
		<_last>
			<c path="Int"/>
			<haxe_doc>* Helper variable for tracking whether the mouse was just pressed or just released.</haxe_doc>
		</_last>
		<_current>
			<c path="Int"/>
			<haxe_doc>* Helper variable for tracking whether the mouse was just pressed or just released.</haxe_doc>
		</_current>
		<visible public="1" get="getVisible" set="null">
			<e path="Bool"/>
			<haxe_doc>* Property to check if the cursor is visible or not.</haxe_doc>
		</visible>
		<screenY public="1">
			<c path="Int"/>
			<haxe_doc>* Current Y position of the mouse pointer on the screen.</haxe_doc>
		</screenY>
		<screenX public="1">
			<c path="Int"/>
			<haxe_doc>* Current X position of the mouse pointer on the screen.</haxe_doc>
		</screenX>
		<wheel public="1">
			<c path="Int"/>
			<haxe_doc>* Current "delta" value of mouse wheel.  If the wheel was just scrolled up, it will have a positive value.  If it was just scrolled down, it will have a negative value.  If it wasn't just scroll this frame, it will be 0.</haxe_doc>
		</wheel>
		<new public="1" set="method" line="73">
			<f a="CursorContainer">
				<t path="nme.display.Sprite"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor.</haxe_doc>
		</new>
		<haxe_doc>* This class helps contain and track the mouse pointer in your game.
 * Automatically accounts for parallax scrolling, etc.</haxe_doc>
	</class>
	<class path="org.flixel.system.input.Touch" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/system/input/Touch.hx">
		<extends path="org.flixel.FlxPoint"/>
		<isActive public="1" set="method" line="218">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Check to see if the touch is active.
	 * @return	Whether the touch is active.</haxe_doc>
		</isActive>
		<justReleased public="1" set="method" line="212">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Check to see if the touch was just ended.
	 * @return	Whether the touch was just ended.</haxe_doc>
		</justReleased>
		<justPressed public="1" set="method" line="206">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Check to see if the touch was just began.
	 * @return Whether the touch was just began.</haxe_doc>
		</justPressed>
		<pressed public="1" set="method" line="200">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Check to see if the touch is pressed.
	 * @return	Whether the touch is pressed.</haxe_doc>
		</pressed>
		<deactivate public="1" set="method" line="190"><f a=""><e path="Void"/></f></deactivate>
		<reset public="1" set="method" line="182">
			<f a="X:Y:PointID">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Resets the just pressed/just released flags and sets touch to not pressed.</haxe_doc>
		</reset>
		<getScreenPosition public="1" set="method" line="164">
			<f a="?Camera:?point">
				<c path="org.flixel.FlxCamera"/>
				<c path="org.flixel.FlxPoint"/>
				<c path="org.flixel.FlxPoint"/>
			</f>
			<haxe_doc>* Fetch the screen position of the touch on any given camera.
	 * NOTE: Touch.screenX and Touch.screenY also store the screen position of the touch point on the main camera.
	 * @param Camera	If unspecified, first/main global camera is used instead.
	 * @param point		An existing point object to store the results (if you don't want a new one created). 
	 * @return The touch point's location in screen space.</haxe_doc>
		</getScreenPosition>
		<getWorldPosition public="1" set="method" line="141">
			<f a="?Camera:?point">
				<c path="org.flixel.FlxCamera"/>
				<c path="org.flixel.FlxPoint"/>
				<c path="org.flixel.FlxPoint"/>
			</f>
			<haxe_doc>* Fetch the world position of the touch on any given camera.
	 * NOTE: Touch.x and Touch.y also store the world position of the touch point on the main camera.
	 * @param Camera	If unspecified, first/main global camera is used instead.
	 * @param point		An existing point object to store the results (if you don't want a new one created). 
	 * @return The touch point's location in world space.</haxe_doc>
		</getWorldPosition>
		<updateCursor set="method" line="123">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Internal function for helping to update world coordinates.</haxe_doc>
		</updateCursor>
		<updateTouchPosition public="1" set="method" line="109">
			<f a="X:Y">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Function for updating touch coordinates. Called by the TouchManager.
	 * @param	X	stageX touch coordinate
	 * @param	Y	stageY touch coordinate</haxe_doc>
		</updateTouchPosition>
		<update public="1" set="method" line="91">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Called by the internal game loop to update the just pressed/just released flags.</haxe_doc>
		</update>
		<get_touchPointID set="method" line="83"><f a=""><c path="Int"/></f></get_touchPointID>
		<touchPointID public="1" get="get_touchPointID" set="null">
			<c path="Int"/>
			<haxe_doc>* A unique identification number (as an Int) assigned to the touch point.</haxe_doc>
		</touchPointID>
		<destroy public="1" set="method" line="71">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_flashPoint public="1"><t path="nme.geom.Point"/></_flashPoint>
		<_globalScreenPosition><c path="org.flixel.FlxPoint"/></_globalScreenPosition>
		<_point>
			<c path="org.flixel.FlxPoint"/>
			<haxe_doc>* Helper variables for recording purposes.</haxe_doc>
		</_point>
		<_last public="1">
			<c path="Int"/>
			<haxe_doc>* Helper variable for tracking whether the touch was just began or just ended.</haxe_doc>
		</_last>
		<_current public="1">
			<c path="Int"/>
			<haxe_doc>* Helper variable for tracking whether the touch was just began or just ended.</haxe_doc>
		</_current>
		<screenY public="1">
			<c path="Int"/>
			<haxe_doc>* Current Y position of the touch point on the screen.</haxe_doc>
		</screenY>
		<screenX public="1">
			<c path="Int"/>
			<haxe_doc>* Current X position of the touch point on the screen.</haxe_doc>
		</screenX>
		<_touchPointID>
			<c path="Int"/>
			<haxe_doc>* A unique identification number (as an Int) assigned to the touch point.</haxe_doc>
		</_touchPointID>
		<new public="1" set="method" line="53">
			<f a="?X:?Y:?PointID">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * @param	X			stageX touch coordinate
	 * @param	Y			stageX touch coordinate
	 * @param	PointID		touchPointID of the touch</haxe_doc>
		</new>
		<haxe_doc>* Helper class, contains and track touch points in your game.
 * Automatically accounts for parallax scrolling, etc.</haxe_doc>
	</class>
	<class path="org.flixel.system.input.TouchManager" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/system/input/TouchManager.hx">
		<recycle set="method" line="243">
			<f a="X:Y:PointID">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Int"/>
				<c path="org.flixel.system.input.Touch"/>
			</f>
			<haxe_doc>* Internal function for touch reuse
	 * @param	X			stageX touch coordinate
	 * @param	Y			stageY touch coordinate
	 * @param	PointID		id of the touch
	 * @return				recycled touch object</haxe_doc>
		</recycle>
		<add set="method" line="229">
			<f a="touch">
				<c path="org.flixel.system.input.Touch"/>
				<c path="org.flixel.system.input.Touch"/>
			</f>
			<haxe_doc>* Internal function for adding new touches to the manager
	 * @param	touch	new touch object
	 * @return			added touch object</haxe_doc>
		</add>
		<justReleasedTouches public="1" set="method" line="200">
			<f a="?TouchArray">
				<c path="Array"><c path="org.flixel.system.input.Touch"/></c>
				<c path="Array"><c path="org.flixel.system.input.Touch"/></c>
			</f>
			<haxe_doc>* Gets all touches which were just ended
	 * @param	TouchArray		optional array to fill with touch objects
	 * @return					array with touches</haxe_doc>
		</justReleasedTouches>
		<justStartedTouches public="1" set="method" line="171">
			<f a="?TouchArray">
				<c path="Array"><c path="org.flixel.system.input.Touch"/></c>
				<c path="Array"><c path="org.flixel.system.input.Touch"/></c>
			</f>
			<haxe_doc>* Gets all touches which were just started
	 * @param	TouchArray		optional array to fill with touch objects
	 * @return					array with touches</haxe_doc>
		</justStartedTouches>
		<handleTouchMove public="1" set="method" line="157">
			<f a="FlashEvent">
				<t path="nme.events.TouchEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Event handler so FlxGame can update touches.
	 * @param	FlashEvent	A <code>TouchEvent</code> object.]]></haxe_doc>
		</handleTouchMove>
		<handleTouchEnd public="1" set="method" line="137">
			<f a="FlashEvent">
				<t path="nme.events.TouchEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Event handler so FlxGame can update touches.
	 * @param	FlashEvent	A <code>TouchEvent</code> object.]]></haxe_doc>
		</handleTouchEnd>
		<handleTouchBegin public="1" set="method" line="112">
			<f a="FlashEvent">
				<t path="nme.events.TouchEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Event handler so FlxGame can update touches.
	 * @param	FlashEvent	A <code>TouchEvent</code> object.]]></haxe_doc>
		</handleTouchBegin>
		<reset public="1" set="method" line="92">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Resets all touches to inactive state.</haxe_doc>
		</reset>
		<update public="1" set="method" line="64">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Called by the internal game loop to update the touch position in the game world.
	 * Also updates the just pressed/just released flags.</haxe_doc>
		</update>
		<destroy public="1" set="method" line="43">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_touchesCache>
			<c path="IntHash"><c path="org.flixel.system.input.Touch"/></c>
			<haxe_doc>* Helper storage for active touches (for faster access)</haxe_doc>
		</_touchesCache>
		<_inactiveTouches>
			<c path="Array"><c path="org.flixel.system.input.Touch"/></c>
			<haxe_doc>* Storage for inactive touches (some sort of cache for them).</haxe_doc>
		</_inactiveTouches>
		<touches public="1">
			<c path="Array"><c path="org.flixel.system.input.Touch"/></c>
			<haxe_doc>* All active touches including just created, moving and just released.</haxe_doc>
		</touches>
		<new public="1" set="method" line="33">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Constructor</haxe_doc>
		</new>
		<haxe_doc>* ...
 * @author Zaphod</haxe_doc>
	</class>
	<class path="org.flixel.system.layer.Atlas" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/system/layer/Atlas.hx">
		<_atlasCache line="19" static="1">
			<c path="Hash"><c path="org.flixel.system.layer.Atlas"/></c>
			<haxe_doc>* Storate for all created atlases in current state</haxe_doc>
		</_atlasCache>
		<getAtlas public="1" set="method" line="97" static="1">
			<f a="Key:BmData:?Unique">
				<c path="String"/>
				<t path="nme.display.BitmapData"/>
				<e path="Bool"/>
				<c path="org.flixel.system.layer.Atlas"/>
			</f>
			<haxe_doc>* Gets atlas from cache or creates new one.
	 * @param	Key			atlas' key (name)
	 * @param	BmData		atlas' bitmapdata
	 * @return	atlas from cache</haxe_doc>
		</getAtlas>
		<getUniqueKey public="1" set="method" line="116" static="1"><f a="Key">
	<c path="String"/>
	<c path="String"/>
</f></getUniqueKey>
		<removeAtlas public="1" set="method" line="135" static="1">
			<f a="atlas:?destroy">
				<c path="org.flixel.system.layer.Atlas"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Removes atlas from cache
	 * @param	atlas	Atlas to remove
	 * @param	destroy	if you set this param to true then atlas will be destroyed. Be carefull with it.</haxe_doc>
		</removeAtlas>
		<clearAtlasCache public="1" set="method" line="153" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clears atlas cache. Please don't use it if you don't know what are you doing.</haxe_doc>
		</clearAtlasCache>
		<findNodeToInsert set="method" line="570"><f a="insertWidth:insertHeight">
	<c path="Int"/>
	<c path="Int"/>
	<c path="org.flixel.system.layer.Node"/>
</f></findNodeToInsert>
		<deleteSubtree set="method" line="559"><f a="node">
	<c path="org.flixel.system.layer.Node"/>
	<e path="Void"/>
</f></deleteSubtree>
		<clone public="1" set="method" line="541">
			<f a="cloneName">
				<c path="String"/>
				<c path="org.flixel.system.layer.Atlas"/>
			</f>
			<haxe_doc>* Gets cloned atlas.
	 * @param	cloneName	the name of new atlas
	 * @return	atlas clone</haxe_doc>
		</clone>
		<clearAndFillWith public="1" set="method" line="515">
			<f a="bmd">
				<t path="nme.display.BitmapData"/>
				<c path="org.flixel.system.layer.Node"/>
			</f>
			<haxe_doc>* This method is used by FlxText objects only.
	 * @param	bmd		updated FlxText's bitmapdata</haxe_doc>
		</clearAndFillWith>
		<clear public="1" set="method" line="496">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clears all data in atlas. Use it when you want reuse this atlas</haxe_doc>
		</clear>
		<destroy public="1" set="method" line="477">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Destroys atlas. Use only if you want to clear memory and don't need this atlas anymore</haxe_doc>
		</destroy>
		<generateAtlasFromQueue public="1" set="method" line="458">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Adds all objects in "queue" to existing atlas. Doesn't erase any node</haxe_doc>
		</generateAtlasFromQueue>
		<addToQueue public="1" set="method" line="445">
			<f a="data:key">
				<t path="nme.display.BitmapData"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Adds new object to queue for later creation of new node
	 * @param	data	bitmapData to hold
	 * @param	key		"name" of bitmapData</haxe_doc>
		</addToQueue>
		<createQueue public="1" set="method" line="435">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Creates new "queue" for adding new nodes</haxe_doc>
		</createQueue>
		<bitmapSorter set="method" line="406"><f a="bmd1:bmd2">
	<t path="nme.display.BitmapData"/>
	<t path="nme.display.BitmapData"/>
	<c path="Int"/>
</f></bitmapSorter>
		<indexOf set="method" line="393"><f a="bitmaps:bmd">
	<c path="Array"><t path="nme.display.BitmapData"/></c>
	<t path="nme.display.BitmapData"/>
	<c path="Int"/>
</f></indexOf>
		<addNodes public="1" set="method" line="364">
			<f a="bitmaps:keys">
				<c path="Array"><t path="nme.display.BitmapData"/></c>
				<c path="Array"><c path="String"/></c>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Optimized version of method for adding multiple nodes to atlas. Uses less atlas' area
	 * @param	bitmaps		BitmapData's to insert
	 * @param	keys		Names of these bitmapData's
	 * @return				true if ALL nodes were added successfully.</haxe_doc>
		</addNodes>
		<getNodeByBitmap public="1" set="method" line="345">
			<f a="bitmap">
				<t path="nme.display.BitmapData"/>
				<c path="org.flixel.system.layer.Node"/>
			</f>
			<haxe_doc>* Get's node by bitmapData
	 * @param	bitmap	bitmapdata to search
	 * @return			node with searched bitmapData. Null if atlas doesn't contain node with a such bitmapData</haxe_doc>
		</getNodeByBitmap>
		<getNodeByKey public="1" set="method" line="330">
			<f a="key">
				<c path="String"/>
				<c path="org.flixel.system.layer.Node"/>
			</f>
			<haxe_doc>* Gets node by it's name
	 * @param	key		node name to search
	 * @return	node with searched name. Null if atlas doesn't contain node with a such name</haxe_doc>
		</getNodeByKey>
		<hasNodeWithName public="1" set="method" line="320">
			<f a="nodeName">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Checks if atlas already contains node with the same name
	 * @param	nodeName	node name to check
	 * @return				true if atlas already contains node with the name</haxe_doc>
		</hasNodeWithName>
		<get_height public="1" set="method" line="310"><f a=""><c path="Int"/></f></get_height>
		<height public="1" get="get_height" set="null">
			<c path="Int"/>
			<haxe_doc>* Total height of atlas</haxe_doc>
		</height>
		<get_width set="method" line="300"><f a=""><c path="Int"/></f></get_width>
		<width public="1" get="get_width" set="null">
			<c path="Int"/>
			<haxe_doc>* Total width of atlas</haxe_doc>
		</width>
		<addNode public="1" set="method" line="236">
			<f a="data:key">
				<t path="nme.display.BitmapData"/>
				<c path="String"/>
				<c path="org.flixel.system.layer.Node"/>
			</f>
			<haxe_doc>* Simply adds new node to atlas.
	 * @param	data	image to hold
	 * @param	key		image name
	 * @return			added node</haxe_doc>
		</addNode>
		<resize public="1" set="method" line="217">
			<f a="newWidth:newHeight">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Resizes atlas to new dimensions. Don't use it</haxe_doc>
		</resize>
		<redrawAll public="1" set="method" line="200">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Redraws all nodes on atlasBitmapData</haxe_doc>
		</redrawAll>
		<redrawNode public="1" set="method" line="184">
			<f a="node">
				<c path="org.flixel.system.layer.Node"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* This method will update atlas bitmapData 
	 * so it will show changes in node's bitmapDatas</haxe_doc>
		</redrawNode>
		<rebuildAtlas public="1" set="method" line="168">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* This method could optimize atlas after adding new nodes with addNode() method.
	 * Don't use it!!!</haxe_doc>
		</rebuildAtlas>
		<_fromBitmapData>
			<e path="Bool"/>
			<haxe_doc>* Bool flag for internal use.</haxe_doc>
		</_fromBitmapData>
		<borderY public="1"><c path="Int"/></borderY>
		<borderX public="1">
			<c path="Int"/>
			<haxe_doc>* Offsets between nodes in atlas</haxe_doc>
		</borderX>
		<atlasBitmapData public="1"><t path="nme.display.BitmapData"/></atlasBitmapData>
		<nodes public="1"><c path="Hash"><c path="org.flixel.system.layer.Node"/></c></nodes>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* Name of the atlas. Don't change it manually!!!</haxe_doc>
		</name>
		<root public="1">
			<c path="org.flixel.system.layer.Node"/>
			<haxe_doc>* Root node of atlas</haxe_doc>
		</root>
		<tempStorage public="1"><c path="Array"><t path="org.flixel.system.layer.TempAtlasObj"/></c></tempStorage>
		<new public="1" set="method" line="58">
			<f a="name:width:height:?borderX:?borderY:?bitmapData">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<t path="nme.display.BitmapData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Atlas constructor
	 * @param	width		atlas width
	 * @param	height		atlas height
	 * @param	borderX		horizontal distance between nodes
	 * @param	borderY		vertical distance between nodes</haxe_doc>
		</new>
		<haxe_doc>* Atlas class
 * @author Zaphod</haxe_doc>
	</class>
	<typedef path="org.flixel.system.layer.TempAtlasObj" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/system/layer/Atlas.hx" module="org.flixel.system.layer.Atlas"><a>
	<keyStr><c path="String"/></keyStr>
	<bmd><t path="nme.display.BitmapData"/></bmd>
</a></typedef>
	<class path="org.flixel.system.layer.Node" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/system/layer/Node.hx">
		<destroy public="1" set="method" line="95"><f a=""><e path="Void"/></f></destroy>
		<get_height set="method" line="68"><f a=""><c path="Int"/></f></get_height>
		<get_width set="method" line="63"><f a=""><c path="Int"/></f></get_width>
		<get_y set="method" line="58"><f a=""><c path="Int"/></f></get_y>
		<get_x set="method" line="53"><f a=""><c path="Int"/></f></get_x>
		<height public="1" get="get_height" set="null"><c path="Int"/></height>
		<width public="1" get="get_width" set="null"><c path="Int"/></width>
		<y public="1" get="get_y" set="null"><c path="Int"/></y>
		<x public="1" get="get_x" set="null"><c path="Int"/></x>
		<canPlace public="1" set="method" line="43"><f a="width:height">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></canPlace>
		<get_isEmpty set="method" line="38"><f a=""><e path="Bool"/></f></get_isEmpty>
		<isEmpty public="1" get="get_isEmpty" set="null"><e path="Bool"/></isEmpty>
		<key public="1"><c path="String"/></key>
		<point public="1"><t path="nme.geom.Point"/></point>
		<rect public="1"><t path="nme.geom.Rectangle"/></rect>
		<right public="1"><c path="org.flixel.system.layer.Node"/></right>
		<left public="1"><c path="org.flixel.system.layer.Node"/></left>
		<item public="1"><t path="nme.display.BitmapData"/></item>
		<atlas public="1"><c path="org.flixel.system.layer.Atlas"/></atlas>
		<new public="1" set="method" line="25"><f a="atlas:rect:?item:?key">
	<c path="org.flixel.system.layer.Atlas"/>
	<t path="nme.geom.Rectangle"/>
	<t path="nme.display.BitmapData"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* Atlas Node holds BitmapData and it's position on Atlas
 * @author Zaphod</haxe_doc>
	</class>
	<class path="org.flixel.system.replay.CodeValuePair" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/system/replay/CodeValuePair.hx">
		<convertFromFlashToCpp public="1" get="inline" set="null" line="19" static="1"><f a="pair">
	<c path="org.flixel.system.replay.CodeValuePair"/>
	<c path="org.flixel.system.replay.CodeValuePair"/>
</f></convertFromFlashToCpp>
		<value public="1"><c path="Int"/></value>
		<code public="1"><c path="Int"/></code>
		<new public="1" set="method" line="13"><f a="?code:?value">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Zaphod</haxe_doc>
	</class>
	<class path="org.flixel.system.replay.FrameRecord" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/system/replay/FrameRecord.hx">
		<load public="1" set="method" line="93">
			<f a="Data">
				<c path="String"/>
				<c path="org.flixel.system.replay.FrameRecord"/>
			</f>
			<haxe_doc><![CDATA[* Load the frame record data from array simple ASCII string.
	 * @param	Data	A <code>String</code> object containing the relevant frame record data.]]></haxe_doc>
		</load>
		<save public="1" set="method" line="60">
			<f a=""><c path="String"/></f>
			<haxe_doc><![CDATA[* Save the frame record data to array simple ASCII string.
	 * @return	A <code>String</code> object containing the relevant frame record data.]]></haxe_doc>
		</save>
		<destroy public="1" set="method" line="50">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<create public="1" set="method" line="38">
			<f a="Frame:?Keys:?Mouse">
				<c path="Float"/>
				<c path="Array"><c path="org.flixel.system.replay.CodeValuePair"/></c>
				<c path="org.flixel.system.replay.MouseRecord"/>
				<c path="org.flixel.system.replay.FrameRecord"/>
			</f>
			<haxe_doc><![CDATA[* Load this frame record with input data from the input managers.
	 * @param Frame		What frame it is.
	 * @param Keys		Keyboard data from the keyboard manager.
	 * @param Mouse		Mouse data from the mouse manager.
	 * @return A reference to this <code>FrameRecord</code> object.]]></haxe_doc>
		</create>
		<mouse public="1">
			<c path="org.flixel.system.replay.MouseRecord"/>
			<haxe_doc>* A container for the 4 mouse state integers.</haxe_doc>
		</mouse>
		<keys public="1">
			<c path="Array"><c path="org.flixel.system.replay.CodeValuePair"/></c>
			<haxe_doc>* An array of simple integer pairs referring to what key is pressed, and what state its in.</haxe_doc>
		</keys>
		<frame public="1">
			<c path="Int"/>
			<haxe_doc>* Which frame of the game loop this record is from or for.</haxe_doc>
		</frame>
		<new public="1" set="method" line="24">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Instantiate array new frame record.</haxe_doc>
		</new>
		<haxe_doc>* Helper class for the new replay system.  Represents all the game inputs for one "frame" or "step" of the game loop.</haxe_doc>
	</class>
	<class path="org.flixel.system.replay.MouseRecord" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/system/replay/MouseRecord.hx">
		<wheel public="1">
			<c path="Int"/>
			<haxe_doc>* The state of the mouse wheel.</haxe_doc>
		</wheel>
		<button public="1">
			<c path="Int"/>
			<haxe_doc>* The state of the left mouse button.</haxe_doc>
		</button>
		<y public="1">
			<c path="Int"/>
			<haxe_doc>* The main Y value of the mouse in screen space.</haxe_doc>
		</y>
		<x public="1">
			<c path="Int"/>
			<haxe_doc>* The main X value of the mouse in screen space.</haxe_doc>
		</x>
		<new public="1" set="method" line="32">
			<f a="X:Y:Button:Wheel">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Instantiate a new mouse input record.
	 * @param X			The main X value of the mouse in screen space.
	 * @param Y			The main Y value of the mouse in screen space.
	 * @param Button	The state of the left mouse button.
	 * @param Wheel		The state of the mouse wheel.</haxe_doc>
		</new>
		<haxe_doc>* A helper class for the frame records, part of the replay/demo/recording system.</haxe_doc>
	</class>
	<typedef path="org.flixel.tweens.CompleteCallback" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/tweens/FlxTween.hx" module="org.flixel.tweens.FlxTween"><f a=""><e path="Void"/></f></typedef>
	<typedef path="org.flixel.tweens.FriendTween" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/tweens/FlxTween.hx" module="org.flixel.tweens.FlxTween">
		<a>
			<finish set="method"><f a=""><e path="Void"/></f></finish>
			<_prev><t path="org.flixel.tweens.FriendTween"/></_prev>
			<_parent><c path="org.flixel.FlxBasic"/></_parent>
			<_next><t path="org.flixel.tweens.FriendTween"/></_next>
			<_finish><e path="Bool"/></_finish>
		</a>
		<haxe_doc>* Friend class for access to Tween private members</haxe_doc>
	</typedef>
	<class path="org.flixel.tweens.FlxTween" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/tweens/FlxTween.hx">
		<PERSIST public="1" get="inline" set="null" line="25" static="1">
			<c path="Int"/>
			<haxe_doc>* Persistent Tween type, will stop when it finishes.</haxe_doc>
		</PERSIST>
		<LOOPING public="1" get="inline" set="null" line="30" static="1">
			<c path="Int"/>
			<haxe_doc>* Looping Tween type, will restart immediately when it finishes.</haxe_doc>
		</LOOPING>
		<PINGPONG public="1" get="inline" set="null" line="35" static="1">
			<c path="Int"/>
			<haxe_doc>* "To and from" Tween type, will play tween hither and thither</haxe_doc>
		</PINGPONG>
		<ONESHOT public="1" get="inline" set="null" line="40" static="1">
			<c path="Int"/>
			<haxe_doc>* Oneshot Tween type, will stop and remove itself from its core container when it finishes.</haxe_doc>
		</ONESHOT>
		<BACKWARD public="1" get="inline" set="null" line="45" static="1">
			<c path="Int"/>
			<haxe_doc>* Backward Tween type, will play tween in reverse direction</haxe_doc>
		</BACKWARD>
		<_backward><e path="Bool"/></_backward>
		<_next><t path="org.flixel.tweens.FriendTween"/></_next>
		<_prev><t path="org.flixel.tweens.FriendTween"/></_prev>
		<_parent><c path="org.flixel.FlxBasic"/></_parent>
		<_finish><e path="Bool"/></_finish>
		<_target><c path="Float"/></_target>
		<_time><c path="Float"/></_time>
		<_t><c path="Float"/></_t>
		<_ease><t path="org.flixel.tweens.util.EaseFunction"/></_ease>
		<_type><c path="Int"/></_type>
		<getScale set="method" line="172"><f a=""><c path="Float"/></f></getScale>
		<scale public="1" get="getScale" set="null"><c path="Float"/></scale>
		<setPercent set="method" line="169"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></setPercent>
		<getPercent set="method" line="168"><f a=""><c path="Float"/></f></getPercent>
		<percent public="1" get="getPercent" set="setPercent"><c path="Float"/></percent>
		<finish set="method" line="139">
			<f a=""><e path="Void"/></f>
			<haxe_doc>@private Called when the Tween completes.</haxe_doc>
		</finish>
		<cancel public="1" set="method" line="129">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Immediately stops the Tween and removes it from its Tweener without calling the complete callback.</haxe_doc>
		</cancel>
		<start public="1" set="method" line="115">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Starts the Tween, or restarts it if it's currently running.</haxe_doc>
		</start>
		<update public="1" set="method" line="86">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Updates the Tween, called by World.</haxe_doc>
		</update>
		<destroy public="1" set="method" line="76"><f a=""><e path="Void"/></f></destroy>
		<complete public="1"><t path="org.flixel.tweens.CompleteCallback"/></complete>
		<active public="1"><e path="Bool"/></active>
		<new public="1" set="method" line="57">
			<f a="duration:?type:?complete:?ease">
				<c path="Float"/>
				<c path="Int"/>
				<t path="org.flixel.tweens.CompleteCallback"/>
				<t path="org.flixel.tweens.util.EaseFunction"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor. Specify basic information about the Tween.
	 * @param	duration		Duration of the tween (in seconds or frames).
	 * @param	type			Tween type, one of Tween.PERSIST (default), Tween.LOOPING, or Tween.ONESHOT.
	 * @param	complete		Optional callback for when the Tween completes.
	 * @param	ease			Optional easer function to apply to the Tweened value.</haxe_doc>
		</new>
	</class>
	<class path="org.flixel.tweens.misc.MultiVarTween" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/tweens/misc/MultiVarTween.hx">
		<extends path="org.flixel.tweens.FlxTween"/>
		<_range><c path="Array"><c path="Float"/></c></_range>
		<_start><c path="Array"><c path="Float"/></c></_start>
		<_vars><c path="Array"><c path="String"/></c></_vars>
		<_object><d/></_object>
		<update public="1" set="method" line="85" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>@private Updates the Tween.</haxe_doc>
		</update>
		<tween public="1" set="method" line="39">
			<f a="object:properties:duration:?ease">
				<d/>
				<d/>
				<c path="Float"/>
				<t path="org.flixel.tweens.util.EaseFunction"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Tweens multiple numeric public properties.
	 * @param	object		The object containing the properties.
	 * @param	properties	An object containing key/value pairs of properties and target values.
	 * @param	duration	Duration of the tween.
	 * @param	ease		Optional easer function.</haxe_doc>
		</tween>
		<destroy public="1" set="method" line="26" override="1"><f a=""><e path="Void"/></f></destroy>
		<new public="1" set="method" line="17">
			<f a="?complete:?type">
				<t path="org.flixel.tweens.CompleteCallback"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor.
	 * @param	complete		Optional completion callback.
	 * @param	type			Tween type.</haxe_doc>
		</new>
		<haxe_doc>* Tweens multiple numeric public properties of an Object simultaneously.</haxe_doc>
	</class>
	<typedef path="org.flixel.tweens.util.EaseFunction" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/tweens/util/Ease.hx" module="org.flixel.tweens.util.Ease"><f a="">
	<c path="Float"/>
	<c path="Float"/>
</f></typedef>
	<class path="org.flixel.tweens.util.Ease" params="" file="/usr/lib/haxe/lib/flixel/1,07/org/flixel/tweens/util/Ease.hx">
		<quadIn public="1" set="method" line="11" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Quadratic in.</haxe_doc>
		</quadIn>
		<quadOut public="1" set="method" line="17" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Quadratic out.</haxe_doc>
		</quadOut>
		<quadInOut public="1" set="method" line="23" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Quadratic in and out.</haxe_doc>
		</quadInOut>
		<cubeIn public="1" set="method" line="29" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Cubic in.</haxe_doc>
		</cubeIn>
		<cubeOut public="1" set="method" line="35" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Cubic out.</haxe_doc>
		</cubeOut>
		<cubeInOut public="1" set="method" line="41" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Cubic in and out.</haxe_doc>
		</cubeInOut>
		<quartIn public="1" set="method" line="47" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Quart in.</haxe_doc>
		</quartIn>
		<quartOut public="1" set="method" line="53" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Quart out.</haxe_doc>
		</quartOut>
		<quartInOut public="1" set="method" line="59" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Quart in and out.</haxe_doc>
		</quartInOut>
		<quintIn public="1" set="method" line="65" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Quint in.</haxe_doc>
		</quintIn>
		<quintOut public="1" set="method" line="71" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Quint out.</haxe_doc>
		</quintOut>
		<quintInOut public="1" set="method" line="77" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Quint in and out.</haxe_doc>
		</quintInOut>
		<sineIn public="1" set="method" line="83" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Sine in.</haxe_doc>
		</sineIn>
		<sineOut public="1" set="method" line="89" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Sine out.</haxe_doc>
		</sineOut>
		<sineInOut public="1" set="method" line="95" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Sine in and out.</haxe_doc>
		</sineInOut>
		<bounceIn public="1" set="method" line="101" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Bounce in.</haxe_doc>
		</bounceIn>
		<bounceOut public="1" set="method" line="111" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Bounce out.</haxe_doc>
		</bounceOut>
		<bounceInOut public="1" set="method" line="120" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Bounce in and out.</haxe_doc>
		</bounceInOut>
		<circIn public="1" set="method" line="138" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Circle in.</haxe_doc>
		</circIn>
		<circOut public="1" set="method" line="144" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Circle out.</haxe_doc>
		</circOut>
		<circInOut public="1" set="method" line="150" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Circle in and out.</haxe_doc>
		</circInOut>
		<expoIn public="1" set="method" line="156" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Exponential in.</haxe_doc>
		</expoIn>
		<expoOut public="1" set="method" line="162" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Exponential out.</haxe_doc>
		</expoOut>
		<expoInOut public="1" set="method" line="168" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Exponential in and out.</haxe_doc>
		</expoInOut>
		<backIn public="1" set="method" line="174" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Back in.</haxe_doc>
		</backIn>
		<backOut public="1" set="method" line="180" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Back out.</haxe_doc>
		</backOut>
		<backInOut public="1" set="method" line="186" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Back in and out.</haxe_doc>
		</backInOut>
		<PI get="inline" set="null" line="195" static="1"><c path="Float"/></PI>
		<PI2 get="inline" set="null" line="196" static="1"><c path="Float"/></PI2>
		<EL get="inline" set="null" line="197" static="1"><c path="Float"/></EL>
		<B1 get="inline" set="null" line="198" static="1"><c path="Float"/></B1>
		<B2 get="inline" set="null" line="199" static="1"><c path="Float"/></B2>
		<B3 get="inline" set="null" line="200" static="1"><c path="Float"/></B3>
		<B4 get="inline" set="null" line="201" static="1"><c path="Float"/></B4>
		<B5 get="inline" set="null" line="202" static="1"><c path="Float"/></B5>
		<B6 get="inline" set="null" line="203" static="1"><c path="Float"/></B6>
		<haxe_doc>* Static class with useful easer functions that can be used by Tweens.</haxe_doc>
	</class>
</haxe>